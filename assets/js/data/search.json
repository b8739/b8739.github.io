[ { "title": "BOJ 3184번 양 파이썬", "url": "/posts/3184%EB%B2%88/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, BFS", "date": "2022-05-23 00:00:00 +0900", "snippet": "문제미키의 뒷마당에는 특정 수의 양이 있다. 그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.마당은 행과 열로 이루어진 직사각형 모양이다. 글자 ‘.’ (점)은 빈 필드를 의미하며, 글자 ‘#’는 울타리를, ‘o’는 양, ‘v’는 늑대를 의미한다.한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다. 마당에서 “탈출”할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.입력첫 줄에는 두 정수 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.다음 R개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다.출력하나의 줄에 아침까지 살아있는 양과 늑대의 수를 의미하는 두 정수를 출력한다.import syssys.setrecursionlimit(100000)R,C = map(int,input().split())yard = [list(input()) for _ in range(R)]dx = [-1,1,0,0]dy = [0,0,-1,1]total_v = 0total_o = 0o = 0v = 0def dfs(x,y): global v,o # 개수 세기 for i in range(4): nx = x + dx[i] ny = y + dy[i] if -1&lt;nx&lt;R and -1&lt;ny&lt;C and yard[nx][ny]!='#': if yard[nx][ny] == 'v': v+=1 elif yard[nx][ny] == 'o': o+=1 yard[nx][ny]='#' #방문처리 dfs(nx,ny) returnfor x in range(R): for y in range(C): if yard[x][y] != '#': if yard[x][y] == 'v': v+=1 elif yard[x][y] == 'o': o+=1 yard[x][y] = '#' dfs(x,y) if o&gt;v: total_o+=o else: total_v+=v o = 0 v = 0print(total_o,total_v)풀이방식방문하는 기준은 # 샵이 아닐 경우이다.방문하면 해당 위치를 #으로 만든다 (visited를 만들 필요 없음)해당 위치의 값이 v인 경우 v의 개수를 세고, o인 경우 o의 개수를 센다.결국 dfs가 return될 때마다 해당 영역의 v 수와 o 수를 알 수 있고, 개수를 비교해서 o가 v보다 더 많을 때에만 전체 양 수에 o를 더해준다. 반대로 그 외 모든 경우에는 전체 늑대 수에 v를 더해준다." }, { "title": "BOJ 16948번 데스 나이트 파이썬", "url": "/posts/16948%EB%B2%88/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, BFS", "date": "2022-05-23 00:00:00 +0900", "snippet": "문제게임을 좋아하는 큐브러버는 체스에서 사용할 새로운 말 “데스 나이트”를 만들었다. 데스 나이트가 있는 곳이 (r, c)라면, (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)로 이동할 수 있다.크기가 N×N인 체스판과 두 칸 (r1, c1), (r2, c2)가 주어진다. 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 구해보자. 체스판의 행과 열은 0번부터 시작한다.데스 나이트는 체스판 밖으로 벗어날 수 없다.입력첫째 줄에 체스판의 크기 N(5 ≤ N ≤ 200)이 주어진다. 둘째 줄에 r1, c1, r2, c2가 주어진다.출력첫째 줄에 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 출력한다. 이동할 수 없는 경우에는 -1을 출력한다.from collections import dequeN = int(input())r1,c1,r2,c2 = map(int,input().split())visited = [[0 for _ in range(N)]for _ in range(N)]dx = [-2,-2,0,0,2,2]dy = [-1,1,-2,2,-1,1]def bfs(x,y): queue = deque([(x,y)]) while queue: a,b = queue.popleft() if a == r2 and b == c2: return visited[a][b] for i in range(6): nx = a+dx[i] ny = b+dy[i] if -1&lt;nx&lt;N and -1&lt;ny&lt;N and not visited[nx][ny]: visited[nx][ny] = visited[a][b]+1 queue.append((nx,ny))result = bfs(r1,c1)if result == None: result=-1print(result)" }, { "title": "BOJ 6118번 숨바꼭질", "url": "/posts/6118%EB%B2%88/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, BFS", "date": "2022-05-22 00:00:00 +0900", "snippet": "BOJ 6118번 파이썬문제재서기는 수혀니와 교외 농장에서 숨바꼭질을 하고 있다. 농장에는 헛간이 많이 널려있고 재서기는 그 중에 하나에 숨어야 한다. 헛간의 개수는 N(2 &lt;= N &lt;= 20,000)개이며, 1 부터 샌다고 하자.재서기는 수혀니가 1번 헛간부터 찾을 것을 알고 있다. 모든 헛간은 M(1&lt;= M &lt;= 50,000)개의 양방향 길로 이어져 있고, 그 양 끝을 A_i 와 B_i(1&lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N; A_i != B_i)로 나타낸다. 또한 어떤 헛간에서 다른 헛간으로는 언제나 도달 가능하다고 생각해도 좋다.재서기는 발냄새가 지독하기 때문에 최대한 냄새가 안나게 숨을 장소를 찾고자 한다. 냄새는 1번 헛간에서의 거리(여기서 거리라 함은 지나야 하는 길의 최소 개수이다)가 멀어질수록 감소한다고 한다. 재서기의 발냄새를 최대한 숨길 수 있는 헛간을 찾을 수 있게 도와주자!입력첫 번째 줄에는 N과 M이 공백을 사이에 두고 주어진다.이후 M줄에 걸쳐서 A_i와 B_i가 공백을 사이에 두고 주어진다.출력출력은 한줄로 이루어지며, 세 개의 값을 공백으로 구분지어 출력해야한다.첫 번째는 숨어야 하는 헛간 번호를(만약 거리가 같은 헛간이 여러개면 가장 작은 헛간 번호를 출력한다), 두 번째는 그 헛간까지의 거리를, 세 번째는 그 헛간과 같은 거리를 갖는 헛간의 개수를 출력해야한다.거리를 찾는다는 점에서 DFS보다 BFS가 더 적합하다는 것에는 이견이 없었다.다만, 왠지 Queue를 사용하지 않고도 BFS를 구현할 수 있을 것 같아서, for문 두개를 엮어서 인접행렬을 도는 코드를 작성했다. 예제 TC는 통과했지만 제출하면 4%에서 ‘틀렸습니다’가 떴다.생각해보니 내가 작성한대로 반복문을 돌리면, BFS의 취지와는 다르게, for문에서 index를 하나씩 더해가며 순서대로 방문하게 된다.결론적으로, queue랑 사용원리는 매우 비슷하게 구현이 되었는데, 방문 안한곳은 frontier라는 배열에 넣어두고, while문안에서 계속 돌린다. queue를 사용할때랑 마찬가지로 frontier라는 배열이 빌 때까지.BFS Queue 사용from collections import dequeN,M = map(int,input().split())S = [[] for _ in range(N+1)]dist = [0] * (N+1)for i in range(M): a,b = map(int,input().split()) S[a].append(b) S[b].append(a)def bfs(): global dist queue = deque() queue.append(1) dist[1]=1 while queue: node = queue.popleft() for n in S[node]: if dist[n] ==0: dist[n] = dist[node]+1 queue.append(n) returnbfs()maxv = max(dist)print(dist.index(maxv),maxv-1,dist.count(maxv))BFS Queue 사용 ❌from collections import dequeN,M = map(int,input().split())S = [[] for _ in range(N+1)]dist = [0] * (N+1)for i in range(M): a,b = map(int,input().split()) S[a].append(b) S[b].append(a)def bfs(): global dist node = 1 dist[node]=1 frontier = [node] while frontier: next_frontier = [] for i in frontier: for j in S[i]: if dist[j] ==0: dist[j] = dist[i]+1 next_frontier.append(j) frontier = next_frontier returnbfs()maxv = max(dist)print(dist.index(maxv),maxv-1,dist.count(maxv))queue를 사용하지 않는 bfs 참고 링크https://gist.github.com/dpapathanasiou/21d3d9b4fcad562dd048d51742340955" }, { "title": "BOJ 5568번 카드 놓기", "url": "/posts/5568%EB%B2%88/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 큐, javascript", "date": "2022-05-21 00:00:00 +0900", "snippet": "BOJ 5568번 카드 놓기문제상근이는 카드 n(4 ≤ n ≤ 10)장을 바닥에 나란히 놓고 놀고있다. 각 카드에는 1이상 99이하의 정수가 적혀져 있다. 상근이는 이 카드 중에서 k(2 ≤ k ≤ 4)장을 선택하고, 가로로 나란히 정수를 만들기로 했다. 상근이가 만들 수 있는 정수는 모두 몇 가지일까?예를 들어, 카드가 5장 있고, 카드에 쓰여 있는 수가 1, 2, 3, 13, 21라고 하자. 여기서 3장을 선택해서 정수를 만들려고 한다. 2, 1, 13을 순서대로 나열하면 정수 2113을 만들 수 있다. 또, 21, 1, 3을 순서대로 나열하면 2113을 만들 수 있다. 이렇게 한 정수를 만드는 조합이 여러 가지 일 수 있다.n장의 카드에 적힌 숫자가 주어졌을 때, 그 중에서 k개를 선택해서 만들 수 있는 정수의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 n이, 둘째 줄에 k가 주어진다. 셋째 줄부터 n개 줄에는 카드에 적혀있는 수가 주어진다.출력첫째 줄에 상근이가 만들 수 있는 정수의 개수를 출력한다.핵심은, 중복 정수를 Set으로 없애주면 된다.단, 유의할 점은 permutations의 결과값 (ex. [(‘1’, ‘2’), (‘1’, ‘12’), (‘1’, ‘1’), (‘2’, ‘1’)…]와 같은 형태)을 set에 넣어서 중복값을 없애고 끝내면 안된다.이 집합값들을 붙여서 정수로 만들면 (ex. [12,112,11,21 …]) 여기서 예상치 못한 중복값이 생길 수 있다는 것이다.그래서 permutations을 만든 이후에, 각 조합을 join으로 붙여서 정수 형태 (실제로 int는 아님, join은 str에만 쓸 수 있기 때문에)이를 set으로 만든 길이를 출력해야 한다.from itertools import permutationsn = int(input())k = int(input())s = []for _ in range(n): s.append(input())permute = list(permutations(s,k))result = []for i in permute: result.append(\"\".join(list(i)))print(len(set(result)))" }, { "title": "React 이벤트 처리하기", "url": "/posts/React-%EC%9D%B4%EB%B2%A4%ED%8A%B8/", "categories": "Reacts", "tags": "React, 이벤트", "date": "2022-05-15 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.컴포넌트에는 여러 이벤트가 발생 → 이벤트에 대한 처리를 커스텀웹브라우저의 HTML이벤트를 기본적으로 지원 이벤트 핸들러 속성명은 camelCase로만 작성 (HTML에서는 onclick, 리액트는 onClick) 이벤트 핸들러에는 필히 함수를 지정 (HTML에서는 문자열로 코드를 지정)HTML&lt;div onclick=\"console.log('hello')\"&gt;&lt;/div&gt;React&lt;div onClick=\"{console.log('hello')}\"&gt; &lt;/div&gt;DOM 요소에만 이벤트가 지원됨 커스텀 리액트 컴포넌트에서는 HTML 이벤트를 지원하지 않음 html의 기본태그, &lt;div&gt;나 &lt;p&gt; 등에는 onClick과 같은 함수가 내장되어 있지만, 직접 만든 컴포넌트 (ex. Counter.js)의 경우에는 지원되지 않음 하지만 내부 Element에 DOM 요소를 담아, 핸들러를 지정할 수 있음 Arrow Function 사용 상탯값 접근/변경 등을 위해 this로 접근해야 하기 때문에 function 문법을 사용하면, this의 scope이 function 내부로 바뀌어버림 " }, { "title": "React 속성값", "url": "/posts/React-%EC%86%8D%EC%84%B1%EA%B0%92/", "categories": "Reacts", "tags": "React, props", "date": "2022-05-15 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.속성값컴포넌트 생성시에 넘겨지는 값의 목록읽기 전용으로 취급하고, 변경하지 않음자식 컴포넌트 입장에서는 데이터/함수를 전달받는 유일한 통로 (But, Context API로 인해, 새로운 통로가 생김)부모 컴포넌트의 데이터/함수를 자식 컴포넌트에게 넘겨주게 됨컴포넌트는 HOC 기법을 통해, Redux의 값이나 함수를 넘겨받기도 함.값 지정 시에 중괄호를 통해 다양한 탕비의 값 및 표현식 지적 가능.중괄호를 빼면 문자열 타입의 값만 지정 가능&lt;div&gt;&lt;Counter color=\"red\" size=\"10\"&gt;&lt;Counter color={\"green\"} size={10}&gt;&lt;/div&gt;EX)class CustomComponent extends React.Component { state = { messageLength: this.props.message.length, counter: 0, };}초기에만 message 속성값을 참조.message 속성값 변경에는 반영하지 못함경우에 따라 3가지를 적절히 활용 State는 아니지만, 변경되는 props값에 의존적인 속성을 정의. 변경 불가.get messageLength(){\treturn this.props.message.length;} state는 아니지만, 이를 함수로서 대응. 변경 불가.getMessageLength(){\treturn this.props.message;} render 호출 직전에 속성값으로부터 상탯값을 계산하여 반영 상탯값으로 반영이 되기에 필요시에 변경도 가능state = {\tmessageLength:0}//render 메서드 호출 직전에 호출static getDerivedStateFromProps(props,state){\treturn{\t\tmessageLength: props.message.length\t}}속성값이 변경될 때, API 호출하기getDerivedStateFromProps는 정적 메서드이기에 this 객체에 접근 불가 속성값 → 상탯값 루틴에 집중하도록, 원천적인 봉쇄그렇기에 componentDidUpdate(props)에서 처리함componentDidUpdate(prevProps){\tconst {postId} = this.props;\tif (prevProps.postId !== postId){\t\tthis.requestPost(postId);\t}} 함수형 컴포넌트에서는 useEffect 훅을 활용하여, 속성값/상탯값이 변경될 때 원하는 함수를 호출할 수 있음" }, { "title": "Javascript 꼭 알아야 할 ES6+ 문법", "url": "/posts/es6%EB%AC%B8%EB%B2%95/", "categories": "Javascript", "tags": "javascript, ES6, Arrow Function", "date": "2022-05-14 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.var 대신 let과 const를 사용var를 사용하면 Javascript의 호이스팅 때문에, 변수 관리에 예기치 않은 혼란이 생길 수 있음왜냐하면, var 변수를 선언하기 전에 호출을 하고, 그 이후에 호출을 해도 ReferenceError가 발생하기 않기 때문그에 반해 let과 const는 block scope를 갖고 있기 때문에, 호이스팅이 발생하지 않음 → 선언을 해야만 사용을 할 수 있음 (의도치 않게 역순서 (호출→선언)로 사용해서 변수를 혼동해서 사용하는 것을 미연에 방지할 수 있음)예) 호이스팅 예시console.log(name);var name = \"jaeho\";// 위 코드는 호이스팅에 의해 실은 아래 코드와// 동일하게 동작함var name;console.log(name);name = \"jaeho\";// 만약 아래에 \"var name='jaeho'\"코드가 없다면// ReferenceError가 발생하게 됨let과 const의 차이let: Lexical Variable Scoping을 지원하는 변수 선언 문법. 재할당 가능Lexical Scope는 함수와 변수의 Scope를 선언된 위치를 기준으로 정함const: let과 달리 상수문법이기 떄문에 선언한 값을 재할당할 수 없음. 내부 속성값은 수정 가능 이와 같은 특성 덕분에, const 문법을 잘 활용하면 버그 발생률을 줄일 수 있음//불가능const hobby = 'soccer'hobby = 'basketball'//가능const tom = {'hobby:'soccer'}tom.hobby = 'basketball'Object 선언Object 선언 (1/3)Key 따옴표파이썬과 달리, key에 따옴표를 넣어도 안 넣어도 똑같음//tom1과 tom2는 동일let tom1={\tname='tom'}let tom2={\t'name'='tom'}Object 선언 (2/3)Key 계산이 필요한 경우 []로 묶어줘야 함[ ] 라고 해서 Array문법은 아님연산을 하는 경우const tom = { [\"score\" + \"1\"]: 100,};변수를 key로 사용하는 경우const key = \"location\";const tom = { [key]: \"seoul\",};Object 선언 (3/3)단축 속성명key랑 value가 값이 같을 경우, 하나로 통일해서 적어도 됨함수의 경우에도 key:value 형태가 아니라 그냥 함수를 선언해주듯이 적으면 됨//아래 두 변수는 동일let tom1 = { name: name, print: function () { console.log(); },};let tom2 = { name, print() { console.log(); },};객체 복사JS는 Object/Array에 대해서는 대입 시에 얕은 복사 (Shallow Copy)const obj1 = { value1: 10 };//얕은 복사const obj2 = obj1;//깊은 복사const obj3 = JSON.parse(JSON.stringify(obj1));obj1.value += 1; //objconsole.log(\"obj1:\", obj1);console.log(\"obj2:\", obj2);console.log(\"obj3:\", obj3);//결과//11//11//10Template Literalsbacktick과 ${expression}를 사용비구조화배열은 [ ]로 묶고, 객체는 { }로 묶음배열 비구조화파이썬에서는 좌우항이 개수가 같아야 하지만, Javascript는 달라도 오류가 안남//tom이 할당됨let [name] = [\"tom\", 10, \"seoul\"];//10이 할당됨let [, age] = [\"tom\", 10, \"seoul\"];//height에 undefined가 할당됨let [name, age, region, height] = [\"tom\", 10, \"seoul\"];//height은 디폴트값 150let [name, age, region, height = 150] = [\"tom\", 10, \"seoul\"];//디폴트값 함수function get_default_value() { return 150;}let [name, age, region, height = get_default_value()] = [\"tom\", 10, \"seoul\"];객체 비구조화const tom = {\tname='tom',\tage=10,\tregion:\"Seoul\"}// 객체에서 해당 key값의 value를 뽑아냄.// height은 정의안되어있으니 undefinedconst {age,name,height}=tom;//고전적인 방법const age = tome.age;const name = tom.name;객체의 속성값을 함수의 인자로 사용하고자 할 때key값을 중괄호로 묶어서 인자로 넘김//동일한 결과가 출력됨const print_person1 = (person) =&gt; { console.log(person.name);};const print_person2 = ({ name }) =&gt; { console.log(name);};print_person1(tom);print_person2(tom);객체가 담긴 배열이 각각 동일한 key값을 가지고 있고 반복문으로 출력하고자 할 떄const people = [ { name: \"tom\", age: 10 }, { name: \"steve\", age: 15 },];//아래 두 반복문은 동일한 결과for (const person of people) { console.log(person.name, person.age);}for (const { name, age } of people) { console.log(name, age);}전개 연산자 (Spread Operator)배열//name에는 첫번째 원소인 Tom이 들어가고,// rest에는 배열의 나머지 인자가 배열 형태로 들어감let [name, ...rest] = [\"Tom\", 10, \"Seoul\"];let names = [\"Steve\", \"John\"];let students = [\"Tom\", ...names, ...names];//결과: students = [\"Tom\",\"Steve\",\"John\",\"Steve\",\"John\"]//배열의 인자들을 일일이 안 적고 다 받으려고 할 떄let printArgs = (...args) =&gt; { console.log(args);};객체 (많이 사용됨)//속성명이 중복될 경우, 마지막값이 남음let tom = { name: \"tom\", age: 10, region: \"seoul\",};let steve = { ...tom, name: \"Steve\",};// 결과:// steve = {//\t age:10,//\t region:\"seoul\",//\t name:\"Steve\"// }TIP 전개 연산자를 많이 쓰면, 구조가 복잡할 경우, 가독성이 떨어짐. 이 때, immer라이브러리를 쓰는 것이 도움됨https://github.com/immerls/immer디폴트값에 함수를 적용할 경우함수 인자의 기본값으로 디폴트 함수를 지정했을때, nodejs와 python 비교nodejs//node.js의 경우 get_default_height는 필요할떄마다 호출됨function say_hello(name,height=get_default_height(){\tconsole.log('hello')}python#파이썬의 경우, 함수가 만들어질때 딱 한번 호출됨def say_hello(name,height=get_default_height(){\tprint'hello')}Arrow Function//return을 안 적어도 구문이 한 줄이라면// 괄호로 묶거나 안 묶어도 반환됨const fn = () =&gt; () function(){}을 사용할 경우, this가 내부로 바인딩 됨 Arrow Function은 this와 arguments를 바인딩하지 않음❌" }, { "title": "React 엘리먼트", "url": "/posts/React-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8/", "categories": "Reacts", "tags": "React, React 엘리먼트", "date": "2022-05-13 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.리액트UI 라이브러리 (웹 프론트엔드 및 앱 Native, VR등에서 활용)UI 데이터를 관리하는 방법을 제공 부모 컴포넌트로부터 내려받는 속성값 → props 컴포넌트 내부에서 생성/관리되는 상탯값 → stateUI 데이터 (UI에 연결된 속성값/상탯값)가 변경되면, 해당 컴포넌트의 render() 함수가 호출이 되어서 화면을 자동으로 개싱 클래스형 컴포넌트에서는 render()함수가 호출 함수형 컴포넌트에서는 그 함수가 매번 호출. 컴포넌트에서 유지해야할 값들은 Hook을 통해 관리리액트의 핵심 - 선언적 UI (Declarative UI)UI에 변화를 가할 때마다 일일이 코드를 수행하는 것이 아니라, 데이터 (속성값/상탯값)에 맞춰 보여질 UI를 미리 선언해두면 데이터가 변경되면, 그 즉시 데이터에 맞춰 UI가 그려집니다.리액트 개발의 핵심 UI에 보여질 값 (속성값/상탯값)등을 효율적으로 관리하고, 그 값들의 변경에 맞춰서, UI가 불필요하게 업데이트 되지 않도록 하기지양하는 패턴 jQuery에서처럼 DOM에 직접 접근하여 추가/변경/삭제를 하는 방식을 지양함. 필요하다면 할 수는 있음 (ref 사용)React Element화면을 담당하며, React 앱의 가장 작은 단위//jsx문법const reactElement1 = &lt;h1&gt; Hello, React!&lt;/h1&gt;//js문법const reactElement2 = React.createElement('h1',null,'Hello, React'))jsx문법에서의 태그는 html 태그처럼 보이지만 react componentReact DOM은 React Element와 일치하도록 DOM을 업데이트Element는 Component에서 화면을 담당 컴포넌트의 주요 구성요소: 속성값 (props), 상탯값(state),엘리먼트(element), 그리고 로직React ComponentComponent를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나뉨 개념적으로 Javascript 함수와 유사 속성값을 전달받아, Element를 반환클래스로 구현하는 컴포넌트가 먼저 지원되었으며, 최근에 함수로 구현하는 컴포넌트를 지원Class 형태//class 형태class Person1 extends React.Component { render() { &lt;div&gt;Person: (this.props.name)&lt;/div&gt;; }}함수 형태 (비록, 함수이지만 component이기 때문에 대문자로 안쓰면 react가 인식 못 함)function Person2(props) { return &lt;div&gt;Person: (props.name)&lt;/div&gt;;}" }, { "title": "React 순수함수와 커링기법", "url": "/posts/React-%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98%EC%99%80-%EC%BB%A4%EB%A7%81-%EA%B8%B0%EB%B2%95/", "categories": "Reacts", "tags": "React, 순수함수, 커링", "date": "2022-05-13 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.리액트는 함수형 프로그래밍을 적극 활용순수함수하나 이상의 인자를 받고, 인자를 변경하지 않고, 참조하여 새로운 값을 반환Side Effects가 없도록 구성let tom = {\tname=\"tom\"\tcanRun=fa;se}//순수함수 X// 인자도 받지 않고, 기존 객체 속성도 변경해버림function not_pure_fn(){\ttom.canRun = true}//순수함수 O//인자를 받아서 참조하여 새로운 값을 반환function pure_fn1(person){\treturn{\t\t...person,\t\tcanRun:true\t}}function pure_fn2=(person)=&gt;({\t\t...person,\t\tcanRun:true});컴포넌의 많은 루틴을 순수 함수로서 작성하기를 요구 상탯값/속성값이 같으면, 항상 같은 값 반환 다른 Side Effects를 발생 시키지 말아야 함❌ (HTTP 요청 데이터 저장, 쿠키 조작 등)컴포넌의 상태값은 불변 객체 (Immutable Object)로 관리해야만 함 수정할 떄에는 기존 값을 변경하는것이 아니라, 같은 이름의 새로운 객체를 생성이를 통해, UI 개발의 복잡도를 낮추고, 버그 발생 활률을 줄임커링 (Currying)일부의 인자를 고정한 새로운 함수를 반환하는 함수를 만드는 기법//방법 1function userLogs(username) { function wrap(message) { console.log(`${username} - ${message}`); } return wrap;}const log = userLogs(\"Jaeho Chung\");log(\"Hello World\");//방법2const userLogs = (username) =&gt; (message) =&gt; { console.log(`${username}-${message}`);};const log = userLogs(\"Jaeho Chung\");log(\"Hello World\");" }, { "title": "React 상탯값 (state) (feat. 클래스형 컴포넌트)", "url": "/posts/React-%EC%83%81%ED%83%AF%EA%B0%92/", "categories": "Reacts", "tags": "React, 상탯값", "date": "2022-05-13 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.UI (엘리먼트)로의 반영을 위해, 유지해야할 값들의 묶음상탯값은 어디에 저장/관리? 각 컴포넌트 내에서만 사용되는 값들은 컴포넌트 안에서 생성/갱신 → 리액트 기본 동작 여러 컴포넌트에서 사용되는 값들은 별도 공간에서 생성/갱신 이때 Redux, Context API, MobX 등을 활용하면 편리 컴포넌트에서 상탯값에 대한 getter/setter 함수를 제공해줍니다. 상탯값을 직접 변경하지는 않음 → 성능 하락클래스 컴포넌트 기본 형식class Counter extends React.Component { //이 부분 state = { counter: 0, }; onClick = () =&gt; { //this.state.count += 1 (setState를 통하지 않ㄱ소 변경하려고 하면 UI에 반영안됨) const counter = this.state.counter + 1; this.setState({ counter }); }; render() { const { counter } = this.state; return &lt;p onClick={this.onClick}&gt;Counter: {counter}&lt;/p&gt;; }}클래스 컴포넌트에서의 상탯값 this.state 객체를 통해 상탯값에 접근 this.setState 함수를 통해 상탯값을 변경 인자로 객체 또는 함수 this.setState((prevState) =&gt; {}); 비동기로 동작 //value가 0이라고 할 때 다음과 같이 하면, 값은 3이 아니라 1이 됨//위 코드의 계산이 수행되기도 전에, 원본 state를 참조하기 때문에this.setState({value:this.state.value+1)};this.setState({value:this.state.value+1)};this.setState({value:this.state.value+1)}; 비동기지만 순서대로 하고 싶을 때 함수의 인자로 들어간 prevState 역할: 가장 최근 state를 불러옴 //value가 0이라고 할 때 다음과 같이 하면, 값은 3이 됨this.setState((prevState) =&gt; { const { value } = prevState; return { value: value + 1 };});this.setState((prevState) =&gt; { const { value } = prevState; return { value: value + 1 };});this.setState((prevState) =&gt; { const { value } = prevState; return { value: value + 1 };}); setState호출은 컴포넌트가 무안트된 이우헤만 유효해서 contructor안에서의 호출은 무시됨 상탯값 어디 저장/관리1. 컴포넌트 내부각 컴포넌트 객체 단위로 상탯값을 유지하고, 하위 컴포넌트의 속성값으로 전달상탯값 setter 함수를 통해 상탯값을 직접 변경 (Reducer 개념을 적용할 수도 있음)this.setState함수, useState 훅 활용문제점: 컴포넌트 계층이 복잡할 때, 상탯값/속성값 전파의 번거로움.하지만 리액트 16.3에 소개된 Context API로 전파가 쉬워졍ㅆ음2. 컴포넌트 외부에서 “전역 상태 관리”컴포넌트 외부에 별도의 상탯값 저장소를 둠여러 컴포넌트들에 의해 공유될 상탯값 (로그인 정보 등)을 관리함컴포넌트에세 상탯값 setter 함수를 제공한다기보다, dispatch함수를 제공함" }, { "title": "React 개발환경 세팅", "url": "/posts/React-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85/", "categories": "Reacts", "tags": "React, yarn, npm", "date": "2022-05-13 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.npm (node package manager): nodejs 기본 패키지 npm install —global 패키지명 npm install 패키지명주의파이썬은 디폴트 전역에 설치되며 로컬 설치를 위해 가상환경을 사용nodejs는 디폴트 로컬에 설치되며 전역 설치를 위해 global 옵션을 사용yarn: 페이스북 주도로 개발된 패키지 관리자설치: npm install —global yarnyarn global add 패키지명yarn add —dev 패키지명 개발 의존성으로 추가하고자 할 때 dev 속 성을 붙임yarn add주의yarn add global 패키지명 (add랑 global 위치를 변경하면) global 이름의 패키지가 설치됨TIP 주로 유틸리티성은 global로 설치Visual Studio Code 추천 확장 Korean Language Pack for Visual Studio Code: UI를 한국어로 변경 Active File in StatusBar: 최하단 바에 작업중인 파일 경로 노출 Auto Rename Tag: 짝이 되는 태그도 동시에 수정 Color Highlight: 컬러코드 텍스트의 배경색을 해당 색상으로 보여줌 debugger-for-chrome: 크롬 개발자 도구에서 디버깅하던 것을 VSCode에서 가능 DotENV: .env파일에 대한 문법 강조 ESLINT: Javascript 코드 정적 분석 → “eslint.autoFixOnSave”:true 설정 추천 .eslintignore: 특정 파일에 대한 분석을 무시하고 싶을때 (.gitignore 같음) Prettier: code formatter → “editor.formatOnSave”: true 설정 추천 .prettierrc: 값 커스터마이즈 {\"arrowParens\": \"always\",\"orderedImports\": true,\"printWidth\": 80,\"singleQuote\": true,\"semi\": true,\"tabWidth\": 2,\"trailingComma\": \"all\",\"useTabs\": false} prettier가 바로 적용이 안될때는 설정→문서서식→prettier 선택 TODO Highlight: TODO highlightReact 프로젝트 생성다음 명령어를 입력해주면 뭐가 이것저것 생성됨yarn create-react-app react-frontend" }, { "title": "React babal과 weback, 그리고 create-react-app", "url": "/posts/babal%EA%B3%BC-weback/", "categories": "Etc", "tags": "Babel, Webpack", "date": "2022-05-13 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.babel/webpack의 역할에 대한 간단한 이해create react-app 명령어에 포함되어 있음Babel목적: Transpiling: 상위 버전의 자바스크립트로 작성된 코드를 하위 버전으로 변경해주는것다양한 babel presetbabel-preset-es2015:es6babel-preset-es2016:es7babel-preset-es2017:es8babel-preset-env 디폴트 동작으로 ES6 이상의 preset을 적용하여, ES6로 transpilling 개별 지정보다 본 preset을 권장Webpack (module bundler)javascript, jsx, css, sass, ess, es6, 이미지, HTML, 폰트 등 거의 모든 것이 모듈이 될 수 있으며, 하나의 파일 (bundle)로 묶을 수 있다.모듈성과 네트워크 성능 향상Features 코드를 필요할 때 로딩 가능 Minifying: 불필요한 코드, 공백/줄바꿈, 긴 이름 등을 줄여, 파일 크기 줄이기 HMR (Hot module replacement): 개발모드에서 원본 소스코드 변경을 감지하여, 변경된 모듈만 즉시 갱신지원 Loaders babel-loader: ES6나 리액트코드를 transpilling css-loader: 설정에 따라 postcss-loader를 추가로 설정. css를 HTML내에서 link엘리먼트를 포함할 필요 없이 js/jsx단에서 임포트하여 React 컴포넌트에 즉시 적용 가능create-react-appwebpack, babel,eslint 등의 기본 설정이 된 리액트 프로젝트 생성yarn global add create-react-appreact 앱 실행 (package.json에서 명령어 변경 가능)yarn start상대경로 import를 절대경로로 지정하기다음 내용을 작성: jsconfig.json//jsconfig.json{\t\"compileOptions\":{\t\t\"baseUrl\": \"src\"\t}\t\"include\":[\"src\"]}" }, { "title": "Jekyll \"The following destination is shared by multiple files.\"", "url": "/posts/django_error/", "categories": "Jekyll", "tags": "jekyll, error", "date": "2022-05-12 00:00:00 +0900", "snippet": "만약에 tags에 앞글자를 대문자로 Django를 넣으면 다음과 같은 충돌이 생김Generating... Conflict: The following destination is shared by multiple files. The written file may end up with unexpected contents. /Users/jeongjaeho/Downloads/gitblog/_site/tags/django/index.html - tags/django/index.html - tags/django/index.html해결방법: django (소문자)로 변경" }, { "title": "Django Queryset을 통한 간단 검색 구현", "url": "/posts/django_search/", "categories": "Django", "tags": "django, 인프런 강의, 검색구현", "date": "2022-05-12 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.각 앱에서 urls.py가 없다면 만들어주고, 프로젝트 urls.py에서 path를 지정해주어야 사용 가능#(프로젝트 디렉토리)/urls.pyfrom django.contrib import adminfrom django.urls import path, includefrom django.conf import settingsfrom django.conf.urls.static import staticurlpatterns = [ path(\"admin/\", admin.site.urls), path(\"blog/\", include(\"blog.urls\")), path(\"instagram/\", include(\"instagram.urls\")),]urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)함수 기반으로 view를 생성해주는 과정#(앱 디렉토리)/urls.py (여기서 앱 이름은 instagram)from django.shortcuts import renderfrom .models import Post# Create your views here.def post_list(request): qs = Post.objects.all() q = request.GET.get(\"q\", \"\") # 두번째 인자는, 첫번째 인자가 없을 때 대신 반환할 값 # request.POST # request.FILES if q: qs = qs.filter( message__icontains=q ) # 검색어가 포함이 되었는지에 대한 조건이 추가가 되고, 이에 대한 새로운 queryset이 반환됨 # instagram/templates/instagram/post_list.html (templates는 고정이고 그 이후 부분을 아래 두번째 인자에서 지정해준것) return render( request, \"instagram/post_list.html\", { # 2번째 인자로 '앱이름/원하는이름의html' 을 넘김 \"post_list\": qs, # post_list.html 파일에서 로 참조하게 됨 (공교롭게 지금 함수랑 이름이 같지만, 중요한건 3번째 인자로 들어간 이 이름) }, )instagram 디렉토리에 수동으로 templates/instagram/post_list.html을 만들어줌 (위에서 지정한 경로대로)post_list.html에는 임시로 다음을 참조해서 화면에 보여주도록 함&lt;!-- post_list.html --&gt;{{post_list}}다음과 같이 뜨면 정상 (새로고침해도 해당 url의 template이 없다고 뜬다면 서버를 재시동)메세지를 추가하고 새로 고침해도 반영된다.Style이 너무 없다싶으면 아래처럼 table을 추가한다는식으로 추가해준다.&lt;!-- post_list.html--&gt;...&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;!-- 인코딩 지정 --&gt; &lt;!-- Get Boostrap CSS --&gt; &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3\" crossorigin=\"anonymous\" /&gt; &lt;title&gt;Instagram/ Post List&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 아래 class에 들어간것은 boostrap class --&gt; &lt;table class=\"table table-bordered table-hover\"&gt; &lt;tbody&gt; ...&lt;/body&gt;검색창 구현...&lt;body&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;input type=\"text\" name=\"q\" /&gt; &lt;input type=\"submit\" value=\"검색\" /&gt; &lt;/form&gt; ...&lt;/body&gt;text type의 input을 q라는 이름(name)으로 받아서 submit하면 action에 넣은 주소로 get 방식으로 보내겠다는 의미검색이 동작한다.검색 버튼을 누르고 나면, 원래는 검색창이 refresh되는데 남겨둘려면 다음과 같이 하면 된다.#views.py...return render( request, \"instagram/post_list.html\", { \"post_list\": qs, \"q\": q, # 이 부분을 추가해줌 }, )&lt;form action=\"\" method=\"get\"&gt; &lt;input type=\"text\" name=\"q\" value=\"\" /&gt; &lt;!-- value 부분을 추가 --&gt; &lt;input type=\"submit\" value=\"검색\" /&gt;&lt;/form&gt;" }, { "title": "Django Queryset의 정렬 및 범위 조건", "url": "/posts/django_query_order/", "categories": "Django", "tags": "django, 인프런 강의, sql", "date": "2022-05-12 00:00:00 +0900", "snippet": "정렬 조건을 추가하지 않으면 일관된 순서를 보장 못 함 ❌DB에서 다수 필드에 대한 정렬을 지원 하지만 가급적 단일 필드로 하는 것이 성능에 이익 시간순 역순 정렬이 필요할 경우, id 필드를 활용해볼 수 있음정렬 조건을 지정하는 2가지 방법 모델 클래스의 meta 속성으로 ordering 설정: list로 지정 모든 queryset에 order_by(…)에 지정Django Extensions 설치pip3 install django-extensionssettings.py에 추가#settings.pyINSTALLED_APPS = [ # django apps \"django.contrib.admin\", \"django.contrib.auth\", \"django.contrib.contenttypes\", \"django.contrib.sessions\", \"django.contrib.messages\", \"django.contrib.staticfiles\", # third apps \"django_extensions\", #여기 추가됨 # local apps \"blog\", \"instagram\",]python3 manage.py shell_plus --print-sql --ipythonshell_plus의 장점은 필요한 기본적인 것들을 미리 import해줌(myenv) jeongjaeho@jeongjaehoui-MacBookPro djangostudy % python3 manage.py shell_plus --print-sql --ipython# Shell Plus Model Importsfrom django.contrib.admin.models import LogEntryfrom django.contrib.auth.models import Group, Permission, Userfrom django.contrib.contenttypes.models import ContentTypefrom django.contrib.sessions.models import Sessionfrom instagram.models import Post# Shell Plus Django Importsfrom django.core.cache import cachefrom django.conf import settingsfrom django.contrib.auth import get_user_modelfrom django.db import transactionfrom django.db.models import Avg, Case, Count, F, Max, Min, Prefetch, Q, Sum, Whenfrom django.utils import timezonefrom django.urls import reversefrom django.db.models import Exists, OuterRef, SubqueryPython 3.7.10 (default, Feb 27 2021, 02:19:57)Type 'copyright', 'credits' or 'license' for more informationIPython 7.32.0 -- An enhanced Interactive Python. Type '?' for help.In [1]:#models.py에 다음을 추가해주면 역순으로 정렬됨#다시 order_by를 지정하면 이는 무시됨class Meta: ordering = [\"-id\"]슬라이싱을 통한 범위조건 추가 (SELECT 쿼리에 “OFFSET/LIMIT” 추가)역순 슬라이싱은 지원하지 않음사용법: 객체[start:stop:step] offset → start limit → stop-start주의 step은 쿼리에 대응되지 않기 때문에 사용 비추천Post.objects.all[0:2:1]start와 stop은 sql이 처리하지만, step은 장고의 쿼리셋이 처리함.즉, start와 stop은 실제로 쿼리를 던지지 않고, lazy하게 동작하며, query set 객체를 반환반면, step은 실제로 실제로 쿼리를 던지기 때문에, list를 반환하고, lazy하게 동작하지 않음" }, { "title": "Django OneToOneField", "url": "/posts/django_onetoone/", "categories": "Django", "tags": "django, 인프런 강의, sql", "date": "2022-05-12 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.1:1 관계에서 어느 쪽이라도 가능ForeignKey(unique=True)와 유사하지만, reverse 차이User:Profile을 FK로 지정한다면 → profile.user_set.first() → userUser:Profile를 O2O로 지정한다면 → profile.user → userOneToOneField(to, on_delete)Foreign Key와 마찬가지로, to와 on_delete를 인자로 주어야 함실습accounts라는 앱을 만들어줌python3 manage.py startapp accountssettings.py에 추가INSTALLED_APPS = [... \"accounts\",]accounts 디렉토리에 urls.py 추가#urls.pyurlpatterns = []프로젝트 디렉토리 urls.py에 urlpatterns에 추가urlpatterns = [\t\t... path(\"accounts/\", include(\"accounts,urls\")),\t\t...]accounts/models.py에 Profile이라는 모델 추가from django.conf import settingsfrom django.db import models# Create your models here.class Profile(models.Model): user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE) address= models.CharField(max_length=100) zipcode = models.CharField(max_length=6)makemigrations 하고 migratepython3 manage.py makemigrations accountspython3 manage.py migrate accounts" }, { "title": "Django 관계를 표현하는 모델 필드 (ForeignKey)", "url": "/posts/django_foreign_key/", "categories": "Django", "tags": "django, 인프런 강의, Foreign Key", "date": "2022-05-12 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.Django 관계를 표현하는 모델 필드 (ForeignKey)ORM은 SQL 생성을 도와주는 라이브러리DB에 대한 모든 것을 알아서 처리해주지는 않음성능 높은 애플리케이션을 만들고자 한다면, 사용할 DB 엔진과 SQL에 대한 높은 이해가 필요ForeignKey?가상 Key임.실제로 저장되는 값은 대상 모델의 pk1:N 관계에서 N측에 명시주의 Django 2 부터는 아래 두 인자를 필수로 지정해야 함 ForeignKey(to, on_delete)to: 대상모델클래스를 직접 지정하거나,클래스명을 문자열로 지정. 자기 참조는 self로 지정on_delete: Record 삭제 시 rule CASCADE: FK로 참조하는 다른 모델의 Record도 삭제 (장고 1.X에서의 디폴트값) PROJECT: ProtectedError를 발생시키며 삭제 방지 SET_NULL: null로 대체. 필드에 null=True 옵션 필수 SET_DEFAULT: 디폴트 값으로 대체. 필드에 디폴트값 지정 피수 SET: 대체할 값이나 함수 지정. 함수의 경우 호출하여 리턴값을 사용. DO_NOTHING: 어떠한 액션 X. DB에 따라 오류가 발생할 수도 있음RDBMS에서의 관계 예시설계하기 나름.✑ 1:N 관계 → models.ForeignKey로 표현: N쪽에 ForeignKey를 지정 1명의 유저(User)가 쓰는 다수의 포스팅 (Post) 1명의 유저(User)가 쓰는 다수의 댓글(Comment) 1개의 포스팅(Post)에 다수의 댓글 (Comment)✑ 1:1 관계 → models.OneToOneField로 표현: 양측 중 어느쪽에 ForeignKey를 지정해도 상관없음user↔ profile 관계의 경우, 대개는 profile측에 지정 (왜냐하면 User의 경우는 Django auth에서 제공해줌. customize를 할 수는 있지만, 사용하고자하는 user class를 변경하는것일뿐, 실제 해당 class자체를 변경하지는 않음)1명의 유저(User)는 1개의 프로필 (Profile)✑ M:N 관계 → models.ManyToManyField로 표현:1개의 포스팅(Post)에는 다수의 태그(Tag)1개의 태그(Tag)에는 다수의 포스팅(Post)#앱 (instagram)의 models.pyclass Comment(models.Model): post = models.ForignKey(Post, on_delete=models.CASCADE)\t\t#다른 앱을 참조하고자 하는 경우, 최상단에 앱을 import하고 아래처럼 앱 이름을 명시해주면 됨\t\t#post = models.ForignKey((다른앱).Post, on_delete=models.CASCADE) message = models.TextField() created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now_add=True)직접 만든 User Model를 사용하고자 할 때settings.py에 AUTH_USER_MODEL 변수를 만들어줌#settings.pyAUTH_USER_MODEL = \"instagram.User\" #Default값은 auth user.#기본 User말고 직접 만든 앱의 User를 사용하고자 할 때#앱 만들자마자 이 라인을 추가해주는게 삽질을 줄일 수 있음#근데 instagram.User 만들기전에 일단 주석처리그럼 아래와 같이 settings.AUTH_USER_MODEL을 추가해서 사용 가능from django.db import models# from django.contrib.auth.models import User &lt;-- Default Auth Userfrom django.conf import settings # &lt;-- 이 부분을 추가# Create your models here.class Post(models.Model): author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE) message = models.TextField()admin.py에 Comment Admin 추가#앱 admin.pyfrom .models import Post, Comment...@admin.register(Comment)class CommentAdmin(admin.ModelAdmin): passmakemigraions, migrateadmin에서 Comment 생성다음과 같이 shell에서 접근 가능In [2]: Comment.objects.all()Out[2]: SELECT \"instagram_comment\".\"id\", \"instagram_comment\".\"post_id\", \"instagram_comment\".\"message\", \"instagram_comment\".\"created_at\", \"instagram_comment\".\"updated_at\" FROM \"instagram_comment\" LIMIT 21Execution time: 0.001503s [Database: default]&lt;QuerySet [&lt;Comment: Comment object (1)&gt;]&gt;In [3]: comment = Comment.objects.first()SELECT \"instagram_comment\".\"id\", \"instagram_comment\".\"post_id\", \"instagram_comment\".\"message\", \"instagram_comment\".\"created_at\", \"instagram_comment\".\"updated_at\" FROM \"instagram_comment\" ORDER BY \"instagram_comment\".\"id\" ASC LIMIT 1Execution time: 0.000419s [Database: default]In [4]: commentOut[4]: &lt;Comment: Comment object (1)&gt;In [5]: comment.postSELECT \"instagram_post\".\"id\", \"instagram_post\".\"author_id\", \"instagram_post\".\"message\", \"instagram_post\".\"is_public\", \"instagram_post\".\"created_at\", \"instagram_post\".\"updated_at\" FROM \"instagram_post\" WHERE \"instagram_post\".\"id\" = 2 LIMIT 21Execution time: 0.000434s [Database: default]Out[5]: &lt;Post: 샘플 메세지&gt;related_name (reverse 역 참조)N:1 관계에서 N측에서는 바로 1측을 참조할 수 있음(정참조)Comment.objects.filter(post_id=4)하지만 반대로 1측에서 N측을 참조하면 역참조를 하여야 함 (class이름+_set.all를 사용)즉, 1측에서 N측을 참조할 때 related_name 을사용post가 1, comment가 N이라고 할 때 post.comment_set.all()로 참조 가능하지만 앱 이름은 고려하지 않고, 모델명만 고려하기 때문에 만약 post라는 모델이 여러 앱에 있는데 related_name을 사용하려고 한다면 충돌이 일어날 수 있음해결방법 어느 한 쪽의 FK에 대해, relatedname을 포기 → related_name=’+’ → **+는 relatedname을 사용안한다는 의미** 어느 한 쪽의 (혹은 모두) FK의 related_name을 변경 ex) FK(User,…,related_name=”blog_post_set”) ex) FK(User,…,related_name=”shop_post_set” " }, { "title": "Django django-debug-toolbar를 통한 SQL 디버깅", "url": "/posts/django_debug_toolbar/", "categories": "Django", "tags": "django, 인프런 강의, 검색구현", "date": "2022-05-12 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.Django django-debug-toolbar를 통한 SQL 디버깅Third Party App현재 request/response에 대한 다양한 디버깅 정보를 보여줌응답 포멧이 html 포멧일 때만 사용 가능 (API 응답에 대해서는 보여줄 수 없음)다양한 Panel 지원 SQLPanel을 통해, 각 요청 처리 시에 발생한 SQL 내역 확인 가능 Ajax 요청에 대한 지원은 불가능 (웹 브라우저에서 바로 보여지지 않기 때문에)Installation공식 Documentation 참고Installation - Django Debug Toolbar 3.4.0 documentation주의사항웹페이지의 템플릿에 꼭 body태그가 있어야만, django-debug-toolbar가 동작함이유: dbt의 html/script 디폴트 주입 타겟이 body태그 (INSERT_BEFORE 설정 디폴트: body태그)필요한 부분을 다 채워넣으면, 브라우저 화면 우측에 다음과 같은 toolbar가 생김SQL의 경우 소요시간도 확인 가능 (확실히 flask보다 체계적인 관리가 가능하겠다는 느낌)코드를 통한 SQL 내역 확인QuerySet의 query 속성 참조ex) print(Post.objects.all().query) → 실제 문자열 참조 시에 SQ 생성settings.DEBUG=True시에만 쿼리 실행내역을 메모리에 누적from django.db import connection, connectionsfor row_dict in connection.queries:\tprint(`{time} {sql}`.format(**row_dict))connections['default'].queries쿼리 초기화메모리에 누적되기에, 프로세스가 재시작되면 초기화django.db.reset_queries()를 통해서 수동 초기화도 가능주의 배포시에는 Debug를 True로 하면, 메모리가 계속 누적되기 때문에 성능 저하될 수 있어서 꼭 False로 하고 배포" }, { "title": "학교 홈페이지_트렌드 조사", "url": "/posts/trend_search/", "categories": "Projects", "tags": "React, django, 풀스택, 학교 홈페이지", "date": "2022-05-11 00:00:00 +0900", "snippet": "First PageMain Article요즘은 웬만한 웹사이트에 들어가면 Article이 화면에서 대문짝만하게 자리를 차지하고 있다.마치 잡지의 맨 앞 겉표지를 연상시킨다.UX Principle중에 Visibiltiy (가시성)이라고 있는데, 그것에 올빵한 느낌.기능이 더 중요시되는 웹 어플리케이션이라면, 이와 같은 화면 구조가 UX를 낮출수도 있겠다.하지만 우리가 흔히 아는 홈페이지 형식의 웹사이트는 정보 제공의 목적이 강하다.게다가 첫 화면 같은 경우에는 텍스트 많은 Information을 제공하려하기보다는, 흥미를 낚으려는 목적이 더 크기 때문에 대문짝만한 Article이 들어간 첫화면이 괜찮은 구조라는 생각이 든다.이러한 인상을 받은건 아래 세 사이트에서이다.사실 학교 홈페이지 말고 요즘 대부분의 사이트들을 (ex.애플, 삼성 등)을 들어가봐도, 첫 화면이 거의 다 이러한 모양새이다.마치 잡지나 온라인 기사와 같은 인상을 준다.심지어, 첫 화면에 영상을 띄우기도 한다.요즘 사이트의 첫 화면은, 어떠한 강렬하고도 상징적인 (스스로를 representing하는) 첫 인상을 주고싶어함을 알 수 있다.HomeStanford UniversityUCLA서울대학교Sub Articles가장 사이즈가 큰 Article이 맨 처음에 나오고, 스크롤을 내릴수록 세부 Article이 Row 형태로 나온다.역시 첫 화면은 개요의 역할을 하는 듯 하다.각 카테고리의 가장 최근 정보, 혹은 돋보이고 싶은 정보들을 선발대 느낌으로 보이게 해서, 유저로 하여금 직접 모든 메뉴에 들어가지 않고도 개괄적으로 학교에 대한 정보를 습득할 수 있게 된다.Navigation한양대학교 상단 Nav전통적인 느낌의 상단 Nav이다.많이 접한 형태의 Nav구조라서, 이질적이지 않고 (UX 용어로 Natural Mapping 잘 돼고), 메뉴 아키텍쳐도 잘 구분되어 있는 느낌이다.그리고 아래 서울대학교에 비해, 더 메뉴 텍스트가 눈에 잘 들어온다.한양대학교는 흰 배경에 채도가 짙은 파란색과 짙은 회색을 사용한 것에 비해, 서울대학교의 메뉴 색 사용은 이와 대조된다.서울대학교 좌측 Nav서울대학교의 좌측 Nav는 참신한 인상을 준다.좌측에 Nav가 있다고해서, 메뉴 위치와 구조가 난해한 것은 절대 아니다.하지만 하필 텍스트 색상도 배경과 구분되지 않는 색을 사용해서, 한양대 홈페이지에 비해 눈에 확 들어오는 Nav라는 인상을 주지는 않는다.국민대학교 상단 Nav (화면 전체 차지)국민대학교는 서울대와 한양대 홈페이지를 섞어놓은 것 같아서 또 인상깊다.Nav 위치는 한양대와 마찬가지로 상단에 있지만 (메뉴를 클릭하면 화면 전체를 차지함), 좌측에 부가서비스를 위한 사이드바가 있다. (그림 아이콘이 정부 24를 연상케한다.)Contents해외 사이트일수록 도전적인? Animation이 많이 들어간 스타일의 디자인이 있다.하버드의 경우 유독 사진도 많고, css animation도 많이 걸려있다.처음엔 시각요소가 많아서 재밌었지만, 자주 방문하게 될 학생 입장에서는 난잡하다고 느낄수도 있겠다는 생각이 들었다.그리고, 바로 띄울 수 있는것을 거의 다 딜레이를 걸어놨기 때문에 이러한 부분이 UX를 헤칠 수도 있겠다는 생각이 들었다." }, { "title": "학교 홈페이지_개발 시작", "url": "/posts/school_project_0/", "categories": "Projects", "tags": "React, django, 풀스택, 학교 홈페이지", "date": "2022-05-10 00:00:00 +0900", "snippet": "학교 홈페이지를 풀스택으로 1인 개발하게 되었다.저번에 풀스택으로 개발할 때 사용했던 기술스택은 Vue.js + Flask + MongoDB + AWS였다.프론트엔드와 벡엔드 프레임워크로 Vue와 Flask를 고른 이유 중 하나는 낮은 러닝커브이기도 했다.당시 나는 경험도, 기술적인 자문을 구할 사수도 없었고, 그럼에도 나름의 생산성은 내야했던 상황에서 나름의 합리적인 판단을 했다.우여곡절이 있었지만, 그렇게 무작정 덤벼서 개발을 해보니 메리트가 있었다.,Vue를 진득하게 개발해보니, React에 대한 근자감이 생겼고, Flask를 진득하게 개발해보니, Django에 대한 근자감이 생겼다…이번에는 프론트엔드로 React, 벡엔드로 Django, 데이터베이스는 안 정했지만 RDBMS중 하나를 사용하게 될 거 같은데, 이번에는 개발 과정을 블로그에 기록해보려고 한다.React를 사용하는 이유는… 워낙 React, Vue, Angular 3대장 중에서 독보적으로 상승기류를 타기도 했고, Django를 사용하는 이유는 배워보니 좀 더 큰 규모의 사이트를 운영할 때는 flask보다 더 이점이 많다고 느꼈기 때문이다 (관리자 페이지도 쉽게 만들 수 있고, DB 관리도 더 체계적으로 관리할 수 있을 것 같고)본격적인 개발 기간까지는 시간이 있으니 할 것 React 온라인 수업 완강 Django 온라인 수업 완강 CSS와 반응형 복습 웹 사이트 아키텍쳐 개발 관습 최근 웹사이트 프론트엔드 트렌드 리서치 웹 사이트 개발 시 안티패턴 리서치" }, { "title": "프로그래머스 - 캐시 Javascript", "url": "/posts/%EC%BA%90%EC%8B%9C/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 큐, javascript", "date": "2022-05-07 00:00:00 +0900", "snippet": "2018 KAKAO BLIND RECRUITMENT문제 설명지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.입력 형식 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다. cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다. cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다. 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.출력 형식 입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.조건 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은 5이다.입출력 예제 캐시크기(cacheSize) 도시이름(cities) 실행시간 3 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] 50 3 [“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”] 21 2 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”] 60 5 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”] 52 2 [“Jeju”, “Pangyo”, “NewYork”, “newyork”] 16 0 [“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] 25 function solution(cacheSize, cities) { var answer = 0; let queue = []; for (let city of cities) { city = city.toLowerCase(); // 없을 경우 if (cacheSize == 0) return cities.length * 5; if (!queue.includes(city)) { if (queue.length == cacheSize) queue.shift(); queue.push(city); answer += 5; } // 있을 경우 else { const index = queue.indexOf(city); queue.splice(index, 1); queue.push(city); answer += 1; } } return answer;}" }, { "title": "프로그래머스 - 스킬트리 Javascript", "url": "/posts/%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 정규표현식, 문자열", "date": "2022-05-07 00:00:00 +0900", "snippet": "프로그래머스 - 스킬트리 Javascript스킬트리문제 설명선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.제한 조건 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 “CBD”로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return “CBD” [“BACDE”, “CBADF”, “AECB”, “BDA”] 2 입출력 예 설명 “BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. “CBADF”: 가능한 스킬트리입니다. “AECB”: 가능한 스킬트리입니다. “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.정규식으로 풀면 되겠다는 아이디어는 금새 떠올랐는데, 변수를 넣어서 패턴을 만들어본적이 없어서 한참 헤맸다.정규표현식 같은 경우 다음과 같이 만들 수도 있다.//new RegExp (/매칭패턴/,\"옵션\") //리터럴 방식new RegExp(/ab+c/, \"옵션\");//new RegExp (\"매칭패턴\",\"옵션\") //생성자 방식new RegExp(\"ab+c\", \"옵션\");주의할 점은 생성자 함수를 사용할때는 이스케이프 규칙을 준수해야 한다.//다음 두 패턴은 동일한 정규표현식을 생성한다let re = /\\w+/;let re = new RegExp(\"\\\\w+\");안에 변수를 넣을거라면 백틱과 ${}를 사용해주면 된다.let alphabet = \"abc\";let parttern = new RegExp(`[^${alphabet}]`, \"g\");//사용 시 examplelet converted = tree.replace(pattern, \"\");^의 경우, 대괄호 밖에서 사용되면 ^뒤에 넣은 문자 다음으로 오는 문자를 매칭하는데 (ex. abc에 /^a/를 하면 bc를 선택함) 대괄호 안에서 사용되면 특정 문자를 ‘제외한’ 모든 문자를 선택한다.정답코드function solution(skill, skill_trees) { var answer = skill_trees.length; let pattern = new RegExp(`[^${skill}]`, \"g\"); for (let tree of skill_trees) { let converted = tree.replace(pattern, \"\"); for (let i = 0; i &lt; converted.length; i++) { if (skill[i] != converted[i]) { answer--; break; } } } return answer;}" }, { "title": "프로그래머스 - 거리두기 Javascript", "url": "/posts/%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 배열, javascript", "date": "2022-05-07 00:00:00 +0900", "snippet": "문제 설명개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다. 대기실은 5개이며, 각 대기실은 5x5 크기입니다.거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.예를 들어, 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다. 응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다. 5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.제한사항 places의 행 길이(대기실 개수) = 5 places의 각 행은 하나의 대기실 구조를 나타냅니다. places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다. places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다. 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식 1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다. 입출력 예 places result [[“POOOP”, “OXXOX”, “OPXPX”, “OOXOX”, “POXXP”], [“POOPX”, “OXPXP”, “PXXXO”, “OXXXO”, “OOOPP”], [“PXOPX”, “OXOXP”, “OXPOX”, “OXXOP”, “PXPOX”], [“OOOXX”, “XOOOX”, “OOOXX”, “OXOOX”, “OOOOO”], [“PXPXP”, “XPXPX”, “PXPXP”, “XPXPX”, “PXPXP”]] [1, 0, 1, 1, 1] 그래프 탐색을 시도했다가, 코드가 지저분해지는 것을 보고 ‘질문하기’에 들어가서 아래 링크 분의 코드를 보고 이해하고 스스로 짜보았다프로그래머스풀이방식바로 answer에 map을 사용해서 정답 포멧으로 변환하기 때문에 코드가 깔끔하다.Key Point 문제의 핵심은 P의 상하좌우 중 P가 하나라도 있으면 거리두기가 안 지켜지고 있는 것이고, O의 상하좌우 중 P가 2개 이상 있으면 거리두기가 안 지켜지고 있다는 것이다. some 함수는 or 같은 개념으로 조건을 배열의 한 원소라도 조건을 통과하면 true를 return하고, every는 and 같은 개념으로 모든 원소가 조건을 통과해야 true를 반환한다. some은 세개의 인자를 받는다 .첫번째는 현재 인덱스의 값, 두번째는 인덱스, 세번째는 some을 호출한 배열이다. 이 문제에서는 한번이라도 거리두기가 안 지켜지면 그 대기실 전체가 안 지켜지고 있는 것으로 간주하기 때문에 some 을 사용하고, 그 내부에 some을 하나 더 둔다. 이 some의 목적은, P의 상하좌우에 P가 하나 이상 있든지, O의 상하좌우에 P가 2개 이상 있든지, 한 사례라도 발견되면 거리두기 실패이기 때문에 이를 검증한다. String을 배열처럼 적용할 수 있게 split으로 나눠준다. peopleAround이라는 변수를 두고, some의 인자를 활용해서 상하좌우에 뭐가 있는지 파악하고, filter 와 length로 p의 개수를 파악한다. 내부 some은 여기서 하나라도 조건에 해당하는지 파악하고, 만약 조건에 걸린다면 true, 아니라면 false를 바깥 some에 전달한다. 바깥 some은 전달받은 값이 true라면 0, 아니라면 1을 반환한다.function solution(places) { var answer = []; answer = places.map((place) =&gt; { //전체 대기실 return place.some((room, rowIdx) =&gt; room.split(\"\").some((curr, colIdx, roomArr) =&gt; { if (curr === \"X\") return false; let peopleAround = [ roomArr[colIdx + 1] || \"\", roomArr[colIdx - 1] || \"\", (place[rowIdx + 1] || \"\")[colIdx], (place[rowIdx - 1] || \"\")[colIdx], ].filter((curr) =&gt; curr == \"P\").length; return ( (curr == \"P\" &amp;&amp; peopleAround &gt; 0) || (curr == \"O\" &amp;&amp; peopleAround &gt; 1) ); }) ) ? 0 : 1; }); return answer;}" }, { "title": "프로그래머스 - 위장 Javascript", "url": "/posts/%EC%9C%84%EC%9E%A5/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 해시, 조합, javascript", "date": "2022-05-06 00:00:00 +0900", "snippet": "위장문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다.입출력 예 clothes return [[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.1. yellow_hat 2. blue_sunglasses 3. green_turban 4. yellow_hat + blue_sunglasses 5. green_turban + blue_sunglasses예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.1. crow_mask 2. blue_sunglasses 3. smoky_makeup풀이방식조합이지만, 2 가지 고려사항 이 있다. 한 카테고리 (ex.목걸이) 에서 아예 안 입을수도 있음 상의에서 한 벌, 하의에서 한 벌 입고, 악세서리는 있더라도 한 개도 착용하지 않을 수 있음 전체 코디 기준 최소 한 벌은 입어야 함 (즉, 1번처럼 한 카테고리에서는 한 벌도 안 입을수는 있지만, 전체 코디에서는 최소 한 벌은 입어야 함. 아예 한 벌도 안 걸치는 경우는 없음.)따라서, 1번에 의거하여, 한 카테고리에서는 아예 안 입는 경우도 감안해서, 카테고리의 개수를 카운팅할 때 이를 반영해준다 (+1)그리고 2번에 의거하여, 전체 경우의 수를 구했다면 여기에서 아무것도 안 걸치는 경우의 수 1개를 빼준다.function solution(clothes) { let answer = 1; let count = {}; for (let i of clothes) { count[i[1]] = (count[i[1]] || 1) + 1; } for (let category in count) { answer *= count[category]; } return answer - 1;}" }, { "title": "프로그래머스 - 구명보트 Javascript", "url": "/posts/%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 그리디, javacript", "date": "2022-05-06 00:00:00 +0900", "snippet": "구명보트문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 느낀 점알고리즘 짜는게 어려웠다기보다 자바스크립트 문법적으로 헤맨 부분이 있다.우선, start와 end로 indexing하는게 아니라 slice를 사용하려고 했는데, 배열에 숫자들이 있어도 slice를 해서 더하려고 하면 string이 된다…?이유가 무엇인지는 구글링해도 못찾았지만, 그래서 ‘+’를 앞에 붙여서 형변환 해주었는데, 이 사실을 알기 전까지는 알고리즘을 잘 못 짠 건지 착각해서 한참 시간을 뺐겼다.그리고 slice 방법을 쓰더라도 어차피 효율성테스트에서 TC 하나가 시간초과가 난다.function solution(people, limit) { var answer = 0; people.sort((a, b) =&gt; a - b); let start = 0; let end = people.length - 1; while (start &lt;= end) { answer += 1; if (people[start] + people[end] &lt;= limit) { start += 1; end -= 1; } else { end -= 1; } } return answer;}" }, { "title": "Javascript 문자열 아스키 코드 변환", "url": "/posts/ascii%EB%B3%80%ED%99%98/", "categories": "Javascript", "tags": "javascript, 문자열, ASCII", "date": "2022-05-05 00:00:00 +0900", "snippet": "ASCII → 문자열String.fromCharCodeString.fromCharCode(97);// 'a'문자열 → ASCIIcharCodeAt\"a\".charCodeAt();// 97ASCII 코드표 번호 코드 번호 1 코드 1 번호 2 코드 2   33 ! 64 @ 95 _   34 ” 65 A 96 `   35 # 66 B 97 a   36 $ 67 C 98 b   37 % 68 D 99 c   38 &amp; 69 E 100 d   39 ’ 70 F 101 e   40 ( 71 G 102 f   41 ) 72 H 103 g   42 * 73 I 104 h   43 + 74 J 105 i   44 , 75 K 106 j   45 - 76 L 107 k   46 . 77 M 108 l   47 / 78 N 109 m   48 0 79 O 110 n   49 1 80 P 111 o   50 2 81 Q 112 p   51 3 82 R 113 q   52 4 83 S 114 r   53 5 84 T 115 s   54 6 85 U 116 t   55 7 86 V 117 u   56 8 87 W 118 v   57 9 88 X 119 w   58 : 89 Y 120 x   59 ; 90 Z 121 y   60 &lt; 91 [ 122 z   61 = 92 \\ 123 {   62 &gt; 93 ] 124     63 ? 94 ^ 125 }   " }, { "title": "프로그래머스 - 튜플 Javascript", "url": "/posts/%ED%8A%9C%ED%94%8C/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 배열, javascript", "date": "2022-05-05 00:00:00 +0900", "snippet": "튜플문제 설명셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, …, an)튜플은 다음과 같은 성질을 가지고 있습니다.j 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다.원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{’, ‘\\}’를 이용해 표현할 수 있습니다. {{a1\\}, {a1, a2\\}, {a1, a2, a3}, {a1, a2, a3, a4}, … {a1, a2, a3, a4, …, an}}예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}} {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.[제한사항] s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 ‘{’, ‘}’, ‘,’ 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.[입출력 예] s result ”{{2},{2,1},{2,1,3},{2,1,3,4}}” [2, 1, 3, 4] ”{{1,2,3},{2,1},{1,2,4,3},{2}}” [2, 1, 3, 4] ”{{20,111},{111}}” [111, 20] ”{{123}}” [123] ”{{4,2,3},{3},{2,3,4,1},{2,3}}” [3, 2, 4, 1] 풀이방식eval을 사용해서 풀이가 확 쉬워지기는 했는데, 검색해보니 웬만하면 해커 관련 보안 이슈 때문에 eval 사용을 지양하라고 한다. (eval 이 아닌 다른 방식을 사용해도, 그 외 나머지 풀이는 비슷할 것 같다.)일단 이 풀이방식에 대해서 설명하자면 정규표현식과 replace,sort를 통해 문자열을 전처리한다. eval을 써서 2차원 배열로 변형해줄거라서, 정규표현식으로 {와 }를 걸러내서 [와 ]로 replace한다. 정답은 입력 튜플의 length가 작은 순서대로 나열해서 만들어야 하기 때문에, length 기준으로 sorting해준다. 이제 문자열 s는 배열 arr가 된 상태인데 이 arr을 대상으로 반복문을 돌리면서, 이미 들어가있는 원소와 들어갈 원소의 차집합을 push해서 집어넣을 것이다. 파이썬과 달리 자바스크립트에서는 set을 활용한 + - 연산이 안되기 때문에, filter를 이용해서 현재 answer (정답 배열)에 없는 원소 (includes로 검증)만 걸러서 차집함을 만들어서 push해준다. filter로 현재 answer과function solution(s) { let answer = []; s = s.replace(/[{]/g, \"[\").replace(/[\\}]/g, \"]\"); let arr = eval(s).sort((a, b) =&gt; a.length - b.length); for (let set of arr) { let difference = set.filter((x) =&gt; !answer.includes(x)); answer.push(...difference); } console.log(answer); return answer;}" }, { "title": "프로그래머스 - [1차] 뉴스 클러스터링 Javascript", "url": "/posts/%EB%89%B4%EC%8A%A4%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 배열, javascript", "date": "2022-05-05 00:00:00 +0900", "snippet": "문제 설명뉴스 클러스터링여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다. 카카오 첫 공채..’블라인드’ 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. “코딩 실력만 본다” 카카오 “코딩 능력만으로 2018 신입 개발자 뽑는다”기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다.자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다.자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 “1”을 3개 가지고 있고, 다중집합 B는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 “1”을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다.이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(\"FRANCE\", \"FRENCH\") = 2/8 = 0.25가 된다.입력 형식 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다.출력 형식입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.예제 입출력 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 느낀 점되게 재밌게 풀었다.자료형은 array, set, map, string, 내장 함수는 map, filter, repeat, split, slice, fill, search 등… 정말 많이 쓴 것 같은데, 안 익숙했는데 마침 좋은 연습이 된 것 같다.하지만 제출하고 보니, 다른 사람 코드를 보니 더 간단하고 짧게 푼 코드도 몇 있었다.직관적으로 접근했다보니, 내 편의에 맞춰느라, 내장 함수가 불필요할때마저도 사용한 것 같다는 생각도 든다.물론 가독성은 나쁘지 않겠다만, 아래 코드는 충분히 리펙토링의 여지가 많을 것 같다. /[A-Za-z]{2}/ 로 필터링하면 되는 것을 /[\\W\\d_]/g)==-1 로 함 (정규표현식에 익숙해지는중…) 문자열의 다음 인덱스 값에 접근할 때 substr을 사용하면 반복문보다 더 깔끔함 각 배열이 갖고 있는 원소의 개수를 count할 때 map을 사용했는데, filter로 사용하는법이 더 쉬울 수 있겠다. 아마 이 부분에서 코드가 짧아질 수 있을 것 같다. function solution(str1, str2) { var answer = 0; let set_1 = convertToSet(str1); let set_2 = convertToSet(str2); let [map_1, map_2] = [countSetElement(set_1), countSetElement(set_2)]; //합집합 let union = []; let union_keys = new Set([...map_1.keys(), ...map_2.keys()]); for (let k of union_keys) { let max_cnt = Math.max(map_1.get(k) || 0, map_2.get(k) || 0); union.push(...k.repeat(max_cnt).split(k).slice(0, -1).fill(k)); } //교집합 let intersection = []; let inter_keys = [...union_keys].filter((x) =&gt; map_1.has(x) &amp;&amp; map_2.has(x)); for (let k of inter_keys) { let min_cnt = Math.min(map_1.get(k) || 0, map_2.get(k) || 0); intersection.push(...k.repeat(min_cnt).split(k).slice(0, -1).fill(k)); } //공집합 if (intersection.length == 0 &amp;&amp; union.length == 0) return 65536; answer = Math.floor((intersection.length / union.length) * 65536); return answer;}function convertToSet(str) { str = str.toLowerCase(); return str .split(\"\") .map((x, idx) =&gt; x.concat(str[idx + 1])) .slice(0, -1) .filter((set) =&gt; set.search(/[\\W\\d_]/g) == -1);}function countSetElement(arr) { let cnt_map = new Map(); for (let i of arr) { cnt_map.set(i, cnt_map.get(i) + 1 || 1); } return cnt_map;}" }, { "title": "프로그래머스 - 튜플 Javascript", "url": "/posts/%EA%B2%8C%EC%9E%84%EB%A7%B5%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 배열, javascript", "date": "2022-05-05 00:00:00 +0900", "snippet": "게임 맵 최단거리문제 설명ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다. 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다. 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.제한사항 maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다. 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.function solution(maps) { var answer = 0; let n = maps.length - 1; //0 let m = maps[0].length - 1; //1 // 도달하지 못하는 경우를 미리 걸러주려고 했는데, n과 m중 하나가 1인 경우 때문에 오류가 났던 것 같다. // if (maps[n-1][m] ==0 &amp;&amp;maps[n][m-1] ==0) return -1 let visited = [...Array(n + 1)].map(() =&gt; new Array(m + 1).fill(0)); let queue = []; queue.push([0, 0]); visited[0][0] += 1; let dx = [1, -1, 0, 0]; let dy = [0, 0, 1, -1]; while (queue.length != 0) { let [x, y] = queue.shift(); if (x == n &amp;&amp; y == m) { break; } for (let i = 0; i &lt; 4; i++) { let nx = x + dx[i]; let ny = y + dy[i]; if (nx &gt; -1 &amp;&amp; ny &gt; -1 &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m) { if (visited[nx][ny] == 0 &amp;&amp; maps[nx][ny] == 1) { queue.push([nx, ny]); visited[nx][ny] = visited[x][y] + 1; } } } } return visited[n][m] == 0 ? -1 : visited[n][m];}매우 간단하고 전형적인 bfs이다.처음으로 파이썬이 아닌 자바스크립트로 풀어보는 것이라 좀 헤맸다." }, { "title": "프로그래머스 - 행렬 테두리 회전하기 Javascript", "url": "/posts/%ED%96%89%EB%A0%AC%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 행렬, 배열, javascript", "date": "2022-05-04 00:00:00 +0900", "snippet": "행렬 테두리 회전하기문제 설명rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다.다음은 6 x 6 크기 행렬의 예시입니다.이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요.행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.제한사항 rows는 2 이상 100 이하인 자연수입니다. columns는 2 이상 100 이하인 자연수입니다. 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다. 즉, 아무 회전도 하지 않았을 때, i 행 j 열에 있는 숫자는 ((i-1) x columns + j)입니다. queries의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다. queries의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다. x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다. 1 ≤ x1 &lt; x2 ≤ rows, 1 ≤ y1 &lt; y2 ≤ columns입니다. 모든 회전은 순서대로 이루어집니다. 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다. function solution(rows, columns, queries) { var answer = []; //2차원 배열 생성 let arr = Array.from(new Array(rows + 1), () =&gt; new Array(columns + 1)); let idx = 0; //배열에 값 집어 넣기 for (let i = 1; i &lt;= rows; i++) { for (let j = 1; j &lt;= columns; j++) { arr[i][j] = ++idx; } } //stack for (let q of queries) { //[2,2,5,4] x1,y1,x2,y2 let [x1, y1, x2, y2] = q; let stack = []; //맨 위, 행 고정 for (let i = y1; i &lt; y2; i++) { stack.push(arr[x1][i]); } //오른쪽,열 고정 for (let i = x1; i &lt; x2; i++) { stack.push(arr[i][y2]); } //맨 밑, 행 고정 for (let i = y2; i &gt; y1; i--) { stack.push(arr[x2][i]); } //왼쪽, 열 고정 for (let i = x2; i &gt; x1; i--) { stack.push(arr[i][y1]); } //최소값 answer.push(Math.min(...stack)); let first = stack.pop(); stack.unshift(first); //stack에서 꺼내서 배열 값 바꾸기 //맨 위, 행 고정 for (let i = y1; i &lt; y2; i++) { arr[x1][i] = stack.shift(); } //오른쪽,열 고정 for (let i = x1; i &lt; x2; i++) { arr[i][y2] = stack.shift(); } //맨 밑, 행 고정 for (let i = y2; i &gt; y1; i--) { arr[x2][i] = stack.shift(); } //왼쪽, 열 고정 for (let i = x2; i &gt; x1; i--) { arr[i][y1] = stack.shift(); } } return answer;}" }, { "title": "프로그래머스 - 짝지어 제거하기 Javascript", "url": "/posts/%EC%A7%9D%EC%A7%80%EC%96%B4%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 문자열, 배열, javascript", "date": "2022-05-04 00:00:00 +0900", "snippet": "짝지어 제거하기문제 설명짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.예를 들어, 문자열 S = baabaa 라면b aa baa → bb aa → aa →의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.제한사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다.입출력 예 s result baabaa 1 cdcd 0 입출력 예 설명입출력 예 #1위의 예시와 같습니다.입출력 예 #2문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.효율성 테스트 시간초과function solution(s) { let idx = 0; let arr = s.split(\"\"); while (true) { if (arr.length &lt; 2) break; if (idx == arr.length - 1) break; if (arr[idx] == arr[idx + 1]) { arr.splice(idx, 2); idx = 0; } else idx += 1; } return arr.length === 0 ? 1 : 0;}효율성 테스트 통과 코드function solution(s) { let arr = []; for (let i of s) { if (arr.length == 0 || arr[arr.length - 1] != i) { arr.push(i); continue; } //같다면 else { arr.pop(); } } return arr.length == 0 ? 1 : 0;}풀이방식 (효율성 테스트 통과 코드)‘질문하기’에서 어떤 분이 올리신 글을 보고 알게 된 방법인데, 문자열을 반복문을 돌리면서, 배열의 마지막 값과 비교해서 같다면 배열에서 pop하고, 아니라면 배열에 push하고, 마지막에 배열이 비어있으면 1, 아니면 0을 반환하면 된다.문제의 워딩에 갇히지 말고, 창의적인 ideation을 하는게 실력인 것 같다." }, { "title": "프로그래머스 - 이상한 문자 만들기 Javascript", "url": "/posts/%EC%9D%B4%EC%83%81%ED%95%9C%EB%AC%B8%EC%9E%90%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 문자열, 아스키코드, javascript", "date": "2022-05-03 00:00:00 +0900", "snippet": "이상한 문자 만들기문제 설명문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.제한 사항 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다. 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.입출력 예 s return “try hello world” “TrY HeLlO WoRlD” 입출력 예 설명“try hello world”는 세 단어 “try”, “hello”, “world”로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 “TrY”, “HeLlO”, “WoRlD”입니다. 따라서 “TrY HeLlO WoRlD” 를 리턴합니다.풀이방식문제에 따르면 각 단어는 하나 이상의 공백문자로 구분되어 있다.즉, try hello world 가 아니라”\"try hello world ”와 같이, world 뒤의 ‘ ‘는 단어를 구분하는 역할이 아니라 단어의 일부로 보아야 한다. 따라서, 처음에 filter 등으로 단어에 포함된 공백마저 지우고 시작하면 안된다.일차적으로 split으로 공백 기준으로 단어들을 구분해서 배열로 만든다.\"try hello world ” → [’try’, ’hello’, ’world’, ’ ’]그리고, 단어가 아니라 철자 기준으로 반복문을 돌아야 하기 때문에, map을 이용해서 각 단어들을 다시 split해준다.‘try’ → [’t’, ’r’, ’y’] ...이후 map을 통해, 삼항연산자로 인덱스를 확인해서 대문자 혹은 소문자로 변행해주고 join으로 붙여준다.공백은 toUpperCase를 하든, toLowerCase를 하든 똑같이 공백이 반환되기 때문에 그냥 똑같이 적용해주면 된다[\"TrY\",\"HeLlO\",\"WoRlD\", “”]여기서 바깥 map에 join을 한번 더해주면 의도한대로 \"TrY HeLlO WoRlD “ 결과가 나온다..function solution(s) { let arr = s .split(\" \") .map((i) =&gt; i .split(\"\") .map((j, idx) =&gt; (idx % 2 === 0 ? j.toUpperCase() : j.toLowerCase())) .join(\"\") ) .join(\" \"); return arr;}" }, { "title": "프로그래머스 - 시저 암호 Javascript", "url": "/posts/%EC%8B%9C%EC%A0%80%EC%95%94%ED%98%B8/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 문자열, 아스키코드, javascript", "date": "2022-05-03 00:00:00 +0900", "snippet": "시저 암호문제 설명어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.제한 조건 공백은 아무리 밀어도 공백입니다. s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다. s의 길이는 8000이하입니다. n은 1 이상, 25이하인 자연수입니다.입출력 예 s n result “AB” 1 “BC” “z” 1 “a” “a B z” 4 “e F d” 풀이방식charCoadAt으로 ascii코드로 바꿔주고, n만큼 이동 (더해주고), 다시 fromCharCode로 알파벳으로변형해주면 된다.다만, 문제에 따르면 z를 넘어서면 다시 a가 된다. 즉 알파벳으로만 순환되는 구조이다.따라서, z를 지나면 다시 a가 되는 구조이도록, 손을 봐주어야 한다.z의 ascii 코드는 122이고, Z는 90이기 때문에 소문자이냐 대문자이냐에 따라서만 이 값을 지정해주고, 이 값을 넘어서면 26을 빼서 다시 알파벳 처음부터 순환하도록 바꿔주면 된다.function solution(s, n) { let answer = \"\"; for (let i = 0; i &lt; s.length; i++) { if (s[i] == \" \") { answer = answer.concat(\" \"); continue; } let ascii = s[i].charCodeAt() + n; let ascii_z = s[i] == s[i].toLowerCase() ? 122 : 90; let final = ascii &gt; ascii_z ? ascii - 26 : ascii; answer = answer.concat(String.fromCharCode(final)); } return answer;}" }, { "title": "프로그래머스 - 소수 찾기 Javascript", "url": "/posts/%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 수학, javascript", "date": "2022-05-03 00:00:00 +0900", "snippet": "소수 찾기문제 설명1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.(1은 소수가 아닙니다.)제한 조건 n은 2이상 1000000이하의 자연수입니다.입출력 예 n result 10 4 5 3 입출력 예 설명입출력 예 #11부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환입출력 예 #21부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환풀이방식소수인지를 반별할 때 Math.sqrt (제곱근) 까지만 해도 되는 점에 유의하자.만약 num-1까지 반복문을 실행한다면 시간초과가 날 수 있다.function solution(n) { let answer = 0; for (let i = 2; i &lt;= n; i++) { answer += isPrime(i); } return answer;}function isPrime(num) { for (let i = 2; i &lt;= Math.sqrt(num); i++) { if (num % i === 0) { return 0; } } return 1;}" }, { "title": "프로그래머스 문자열 다루기 기본 Javascript", "url": "/posts/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%8B%A4%EB%A3%A8%EA%B8%B0%EA%B8%B0%EB%B3%B8/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 문자열, javascript", "date": "2022-05-03 00:00:00 +0900", "snippet": "문제 설명문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.제한 사항 s는 길이 1 이상, 길이 8 이하인 문자열입니다.입출력 예 s return “a234” false “1234” true 풀이방식정규표현식 매칭패턴에서 \\d는 [0-9], 숫자를 의미하고 \\D는 반대로 숫자가 아닌것들을 의미한다.문자열이 정수인지 판별할 때, isNaN으로만 정확하게 판별할 수 없는 이유는 ‘123 ‘처럼 공백이 있어도 NaN이 아니라고 인식하기 때문이다.isNaN(\"123 \");// false그래서 이러한 공백을 포함한 다른 기호, 음의 정수라서 -가 끼어있다던가 하는 여러 예외상황을 해결하기 위해서 정규표현식을 사용했다.search에서 찾으려는 값을 찾으면 해당 index를 반환하고, 아니라면 -1를 반환하는데, 반환값이 -1보다 크다는 것은 숫자 아닌것들 (특수기호 등)을 못찾았다는 의미임으로 s가 숫자로만 이뤄졌다는것을 보장할 수 있다.function solution(s) { if (s.length !== 4 || (s.length !== 6 &amp;&amp; s.search(/\\D/) &gt; -1)) return false; return true;}" }, { "title": "Javascript Array.sort() 주의사항", "url": "/posts/array_sorting/", "categories": "Javascript", "tags": "javascript, 배열, 정렬", "date": "2022-05-02 00:00:00 +0900", "snippet": "Array.prototype.sort()sort()는 인자로 compareFunction을 받게 되어 있는데, 주어지지 않을시에는 기본적으로 문자열의 유니코드 코드 포인트를 따라서 정렬한다.즉, 파이썬의 sort()처럼 수를 비교해서 오름차순, 내림차순으로 정렬되는 것이 아니라, 일차적으로 문자열로 변환하고나서 UTF-16 코드 포인트를 비교한 순서대로 정렬이 됨const array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4]출처: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sortcompareFunction (출처: Mozilla)즉, 이를 활용해서 함수를 만들어서 넣어주면 되는데, a와 b를 매개변수로 주면 compareFunction은 내부적으로 배열의 모든 원소들을 서로 비교한다.내림차순의 경우,만약 a가 b보다 작은 경우, 즉 a-b가 0보다 작은 경우, a가 먼저오게 된다.0을 반환한 경우, 즉 a-b의 값이0인 경우, 둘이 같다는 의미이므로 다른 요소에 대하여 정렬한다.a가 b보다 큰 경우, 즉 a-b가 0보다 큰 경우, b를 a보다 낮은 인덱스로 정렬한다.오름차순의 경우, a-b를 b-a로만 변경해주면 된다.오름차순 &amp; 내림차순 방법// 원본 배열이 수정됨const numbers = [1, 30, 4, 21, 100000];// 오름차순 정렬numbers.sort((a, b) =&gt; a - b);console.log(numbers); // [1, 4, 21, 30, 100000]// 내림차순 정렬numbers.sort((a, b) =&gt; b - a);console.log(numbers); // [100000, 30, 21, 4, 1]" }, { "title": "Javascript Array.from()", "url": "/posts/array_from/", "categories": "Javascript", "tags": "javascript, 배열", "date": "2022-05-02 00:00:00 +0900", "snippet": "Array.from파이썬으로 하다가 자바스크립트로 알고리즘을 짜려면 마냥 복잡할줄만 알았다.근데 막상 익숙해지다 보니 각 언어의 편한 부분이 서로 다른 것 같다.Mozilla.org의 정의에 따르면 Array.from() 메서드는 유사 배열 객체(array-like object)나 반복 가능한 객체(iterable object)를 얕게 복사해 새로운 Array 객체를 만든다.string도 반복 가능하기 때문에 인자로 넣는다면, 각 character를 배열에 넣을 수 있다.Array.from('foo')//['f','o','o'][...'foo']//['f','o','o']a = 'foo'a.split('')//['f','o','o']또 특이한점은, mapFn이라는 선택함수를 추가로 매개변수로 넣으면 배열에 들어갈 각 요소에 맴핑 함수를 호출할 수 있다. (mapFn이라는 이름처럼 map과 같은 기능을 한다.)Array.from([1, 2, 3], (x) =&gt; x + 1);//[2,3,4]2차원 함수를 만들때도, 번거롭게 for문을 곂쳐서 만들지 않고, Array.from을 이용하면 쉽게 만들 수 있다.Array.from(new Array(2), () =&gt; new Array(2).fill(0));//[[0,0],[0,0]]" }, { "title": "프로그래머스 체육복 Javascript", "url": "/posts/%EC%B2%B4%EC%9C%A1%EB%B3%B5/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 그리디, javascript", "date": "2022-05-02 00:00:00 +0900", "snippet": "체육복문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.풀이방식• 자신도 도난 당한 학생은 여벌 체육복 있어도, 다른 다른 학생에게 빌려줄 수 없다 (본인도 입어야 하기 때문에) 는 점이 일부 테스트케이스에서 실패가 뜨게 했던 요인인 것 같은데, 처음에는 이 학생이 남한테 빌려주더라도 어차피 본인이 체육복이 없어서 count가 안되기 때문에 냅둬도 알아서 상쇄되는 것이 아닌가 싶었다.근데도 테스트케이스 5,12에서 틀리길래 질문 탐색에서 반례를 찾아서 실행해보니, 정확히 기억은 안나는데 아래 두 TC 중 하나에서 실패가 떴다.5 [1,2,4] [2,4,5] 45 [1,2,4] [2,3,4,5] 4아마 앞 뒤 학생에만 빌릴 수 있다는 제한사항이랑 맞물리면서, 만약 본인도 잃어버렸는데 앞번호나 뒷번호한테 빌려주다보면, 체육복을 못 입게 되는 학생이 더 생겨버리는 케이스가 존재하는 것 같다.그래서 filter 부분으로 lost와 reserve에서 각각 공통 숫자를 제거해주고 반복문을 돌리니 다 통과했다.function solution(n, lost_b, reserve_b) { lost_b.sort(); reserve_b.sort(); lost = lost_b.filter((x) =&gt; !reserve_b.includes(x)); reserve = reserve_b.filter((x) =&gt; !lost_b.includes(x)); var answer = n - lost.length; for (let i = 0; i &lt; lost.length; i++) { let front = lost[i] - 1; let back = lost[i] + 1; for (let j = 0; j &lt; reserve.length; j++) { if (reserve[j] == front || reserve[j] == back) { answer += 1; reserve[j] = -1; break; } } } return answer;}" }, { "title": "프로그래머스 실패율 Javascript", "url": "/posts/%EC%8B%A4%ED%8C%A8%EC%9C%A8/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, javascript", "date": "2022-05-02 00:00:00 +0900", "snippet": "실패율문제 설명슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.입출력 예 N stages result 5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명입출력 예 #11번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/82번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5]입출력 예 #2모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3]풀이방식자바스크립트의 filter, sort, map를 사용하면 직관적으로 풀 수 있는 문제이다.다만, 굳이 filter을 안사용해줘도 되는 부분까지 사용하면 TC중 몇개가 시간초과가 날 수도 있다.22번 TC에서 시간초과가 나서 cleared를 구할 때는 이미 구한 entered에서 uncleared를 빼주었다.function solution(N, stages) { var answer = []; stages.sort((a, b) =&gt; a - b); let mappedArr = []; // 1 2 2 2 3 3 4 6 for (let i = 1; i &lt; N + 1; i++) { //state에 도달 let qualified = stages.filter((s) =&gt; s &gt;= i); let entered = qualified.length; //현재 그 state랑 값이 똑같으면 머물러있다는 의미 let uncleared = qualified.filter((s) =&gt; s == i).length; let cleared = entered - uncleared; let failRate = uncleared / entered; mappedArr.push([i, failRate]); } mappedArr.sort((a, b) =&gt; b[1] - a[1]); //value기준 내림차순 mappedArr = mappedArr.map((x) =&gt; { return x[0]; }); return mappedArr;}" }, { "title": "substr, substring, slice, charAt 기능 및 차이", "url": "/posts/string_process/", "categories": "Javascript", "tags": "javascript, 문자열", "date": "2022-05-01 00:00:00 +0900", "snippet": "substr(시작 인덱스 , 시작 인덱스로부터 자를 길이) ex) substr(0,2)라면 0번째와 1번째 인덱스를 잘라내서 substring가 차이가 없어보인다. 하지만 substr(2,4)라면 2번째 인덱스부터 3번째 인덱스를 잘라내는 것이 아니라, 2번째부터 길이 4를 더해서 즉 5번째까지를 잘라내게 된다.substring(시작 인덱스, 끝 인덱스) 시작 지점과 끝 지점을 인자로 주어서 그 구간을 잘라낸다. 인자로 준 끝 지점의 -1까지만 잘라낸다는 사실을 유의해야 한다. -1를 인자로 주면 0으로 치환되기 때문에, 뒤에서부터 자르는 것이 불가능하다.slice(시작 인덱스, 끝 인덱스) substring과의 차이점 음수를 인자로 주어서 뒤에서부터 접근하는 것이 가능함. 인자를 하나만 줄 때, 양수 (+)로 주면 문자열의 첫 지점부터 양수로 준 지점까지를 잘라내고, 음수 (-)로 주면 뒤에서부터 해당 지점을 시작으로 문자열의 끝 지점까지를 잘라낸다. ex slice(-3)이라고 하면 뒤에서부터 3번째 지점을 시작으로 처음 지점 (0번째 인덱스)까지 잘라냄 chatAt(가져올 인덱스) 문자열에서 인자로 준 해당 인덱스를 가져온다. 자바스크립트 문자열은 배열처럼 인덱싱이 가능하지만, 범위를 벗어난 인덱스를 주면 undefined를 return 하는 반면, chatAt의 경우 범위를 벗어나면 empty string을 return한다. -1로 뒤에서부터 접근할 수 없다." }, { "title": "Javascript 반복문 종류 및 차이 (일반 For문, For in, For of, forEach)", "url": "/posts/for_loop/", "categories": "Javascript", "tags": "javascript, 문자열", "date": "2022-05-01 00:00:00 +0900", "snippet": "일반 For 문Traditional한 for문이고, 밑에서 살펴볼 다른 for문들처럼 특정 자료형(들)을 대상으로 사용되지 않고, 사용자가 변수로 직접 구간을 지정해서 해당 index로 반복문을 순회한다.가장 빠르지만 가독성이 낮다는 특징이 있다.문법for(초기문(***initialization***); 조건문(***condition***); 증감문(***increment***)){실행할 내용 내용 (***statement***)}예시for (let i = 0; i &lt; 3; i++) { console.log(i);}/*결과:123*/forEach (Array.prototype.forEach())배열 대상으로 사용 가능하다.break와 continue를 사용할 수 없지만, 예외를 던지는 throw를 통해 종료할 수 있고, return으로 해당 조건을 건너뛸 수 있다.map, reduce와 달리 undefined를 반환한다.문법arr.forEach(callback(currentvalue[, index[, array]])[, thisArg])예시const arr = [1, 2, 3];// 일반 함수arr.forEach(function (item, index, arr2) { console.log(item, index, arr2[index + 1]);});//첫번쨰 인수는 배열의 각각의 item //두번쨰 인수는 배열의 index //세번째 인수는 배열 그자체// 화살표 함수arr.forEach((element) =&gt; { console.log(element);});/*123*/For … inObject의 enumerable properties (열거 가능한 속성) 순회하기 위한 용도로 사용주의할 점은 Array도 Object라서 for … in이 사용한데, 만약 Array에 property가 지정되어 있다면 (보통 그럴 일이 없지만) 배열의 값 뿐만 아니라 properties도 순회하기 때문에 퍼포먼스에 영향을 준다.또한 Array의 index는 정수인 반면, for …in은 정수가 아닐 수 있는, 다양한 종료의 열거 가능한 속성들을 순회하기 위한 용도로 사용하기 때문에 비록 Array를 대상으로 사용하더라도 index의 순서를 보장할 수 없다.그래서 일반적으로 배열에 for loop을 사용할때는 일반 for문, forEach, for … of 중 하나를 사용하는 것이 권장된다.문법for (variable in object) { ... }예시const person = { 이름: \"길동\", 성: \"홍\", 나이: 20 };for (const property in person) { console.log(`${property}:${person[property]}`);}/*결과: 이름: 길동성: 홍나이: 20*/For … of (ES6)ES6에서 새로 추가된 반복 구문[Symbol.iterator] 속성을 가진 collections (Array Map, Set, String,TypedArray,arguments)를 대상으로 사용 가능문법for (variable ofiterable) {statement}예시const arr = [1, 2, 3];for (const i of arr) { console.log(i);}/*결과: 357*/For in, For of 차이For in은 Object의 열거 가능한 모든 속성을 순회하는 반면, For of는 [Symbol.iterator] 속성을 가진 Collections 대상 (Array, Map, Set 등)으로만 순회출처: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for…ofObject.prototype.objCustom = function () {};Array.prototype.arrCustom = function () {};let iterable = [3, 5, 7];iterable.foo = \"hello\";for (let i in iterable) { console.log(i); // logs 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\"}for (let i of iterable) { console.log(i); // logs 3, 5, 7}" }, { "title": "정규표현식", "url": "/posts/expression/", "categories": "Javascript", "tags": "javascript, 문자열, 정규표현식", "date": "2022-05-01 00:00:00 +0900", "snippet": "(계속 작성중)정규식옵션아래과 같이 사용ex_str = ex_str.replace(/[매칭패턴]/정규식옵션,'변환 결과') g (global) : 첫번째 문자만이 아닌 패턴에 해당하는 모든 문자들을 검색하여 대체한다. i (ignoreCase) : 대소문자 구분하지 않음. m (multillineM) : 여러 줄 검색 s : “dotAll”; 줄 바꿈과 일치 하는 .을 허용합니다. u : 유니 코드; 패턴을 일련의 유니 코드 코드 포인트로 취급 y : sticky; 대상 문자열에서이 정규식의 lastIndex 속성으로 표시된 인덱스에서만 일치하며 이후 인덱스에서는 일치하지 않습니다.^[] 안의 ^ 는 제외의 의미ex_str = \"abc._a!bc12\";// 문자를 제외한 것들은 ''로 치환ex_str = ex_str.replace(/[^a-z]/g, \"\");// 결과: abcabc괄호 밖에 쓰일때는, 시작 문자를 의미ex_str = \"abc\";// 시작 문자 a를 ''로 치환ex_str = ex_str.replace(/^a/g, \"\");// 결과: bc$끝 문자를 의미ex_str = \"abc\";ex_str = ex_str.replace(/c$/, \"\");// 결과: ab[ ]대괄호 안에 넣으면 개별적으로 치환, 밖에 넣으면 한 묶음으로 처리마침표 (.)정규표현식에서 점(.)은 모든 문자열을 나타냄 (줄바꿈 제외)ex_str = \"...\";// 각 점을 느낌표로 바꾸려고 할 때ex_str = ex_str.replace(/./g, \"!\");// 결과: !!!그래서 이와 같은 용도가 아니라, 마침표라는 문자를 선택하려 할 때는 점 앞에 역슬래시를 붙여야 함만약 두 점을 선택하려면 각 점 앞에 역슬래시를 붙임ex_str = \"abc..abc..\";// abcabc로 변환하려는 상황ex_str = ex_str.replace(/\\.\\./g, \"\");// 결과: abcabc+한개 혹은 여러개위 예시에서 한개 이상의 .을 지우려고 할 때, 아래와 같이 작성해도 똑같은 결과ex_str = ex_str.replace(/\\.+/g, \"\");// 결과: abcabc공백을 치환하려 할 때ex_str = \"\";ex_str = ex_str.replace(/^$/, \"a\");// 결과: a" }, { "title": "알고리즘 풀 때 Javascript 문법 꿀팁", "url": "/posts/algorithm_tip/", "categories": "Javascript", "tags": "javascript, algorithm", "date": "2022-05-01 00:00:00 +0900", "snippet": "(계속 작성중)파이썬으로만 알고리즘 풀다가, 자바스크립트로 풀어야 할 일이 생겼다.알아두면 좋을 자바스크립 문법 활용법을 정리해보려고 한다.Spread 파라미터상황: report라는 배열을 Set으로 형 변환해서 다시 배열로 만들어줄때[...new Set(report)];|| (or 문법)상황: 없으면 추가, 있으면 기존 값 +1을 하려고 할 때 (undefined인 경우를 핸들링함과 동시에 각 상황에 대한 값을 부여)let mapList = new Map();for (const item of itemList) { counts.set(item[1], counts.get(item[1]) + 1 || 1);}Filter (feat. 0을 False로 활용)filter는 map과 달리 조건을 통과하는 요소들로 새로운 배열을 만들고, 기존 숫자 앞에 !를 붙이면 0이 되기 때문에 다음과 같이 작성하면 0의 길이를 구할 수 있음const arr = [0, 0, 1, 2];arr.filter((v) =&gt; !v).length;" }, { "title": "프로그래머스 완주하지 못한 선수 Javascript", "url": "/posts/%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80%EB%AA%BB%ED%95%9C%EC%84%A0%EC%88%98/", "categories": "Algorithm", "tags": "프로그래머스, 알고리즘, 배열, 정렬, javascript", "date": "2022-05-01 00:00:00 +0900", "snippet": "완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. participant completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” Sort를 이용한 풀이방식이 방식을 사용하면, 반복문 한번을 통해서 participant, completion을 둘 다 비교가 가능하고, 이 과정에서 값이 일치하지 않으면 바로 그 값을 정답으로 return해주면 되기 때문에 간편하다. (for of는 일반 for보다 비효율적일 수 있다고 한다.)function solution(participant, completion) { participant.sort(); completion.sort(); for (let [idx, v] of participant.entries()) { if (v != completion[idx]) { return v; } }}" }, { "title": "Jekyll Theme Chirpy로 바꾸던 중 발생했던 에러", "url": "/posts/jekyll_error/", "categories": "Jekyll", "tags": "jekyll, error", "date": "2022-04-29 00:00:00 +0900", "snippet": "Jekyll 테마를 한 대여섯번 바꿨었는데, 이런 오류가 난 적은 처음이다.일단 테마 변경할때마다 기존 블로그 디렉토리에서 포스트만 긁어와서 넣어주고, config.yml만 적당히 수정해주면 됐었는데, 이번에는 push하고 블로그를 들어가보려고 하면 아래 사진의 문구만 떴다.Commit에 들어가보면 뭔가 오류가 나면, 아래처럼 commit 옆에 ❌  가 생기고, 최상단 commit처럼 문제가 없다면 오른쪽에 ✅  가 뜬다.어떤 오류인지 log를 확인해보려고 한다면 x를 클릭해서, 오류가 난 부분에 Details를 클릭해보면 된다.음… 우선 아래 log가 처음 발생했던 오류인데, 이 오류는 원인을 못찾았는데, 최종적으로는 어떻게 해결이 됐다.구글링을 하다가 비슷한 에러를 경험했던 블로거를 찾았다.[Jekyll] Chirpy 테마 적용하는 방법 및 에러여기서는 bash tools/init.sh를 먼저 해주라고 한다. (근데 테마 제작자 github 주소 가보니 ReadMe 설명에 별 내용이 없었는데, 어디서 다들 이 내용을 찾은지는 모르겠다.)아무튼 그래서 bundle도 처음에 했었지만 다시 해주고, bash tools/init.sh를 해주고 나니 gitignore 내용도 좀 바뀌고, Gemfile.lock도 다시 생겼다.Gemfile.lock이 리포에 올라가게 되면 오류가 생긴다고 해서, gitignore에 추가해주었다.그러고 나니 위에 발생했던 오류는 사라지고 새로운 오류가 났는데, 이건 .md 파일 (내 블로그 포스트들)에서 난 오류였다. U+ACC4 이런 용어가 있는거보니 유추할수있는바로는 어떤 정규표현식 문법에 어긋난 용어가 들어가서 그런 것 같았다.의아한점은 이전 지킬 테마에서는 다 문제 없이 작동했었다는 점이다.이것과 관련해서 서칭을 해보니 아래 블로그를 찾았는데, 이분은 꺽쇠 부분에 \\를 넣어주었다. [git action 자동 배포 에러 해결기 (ERROR: Invalid first code point of tag name U+C804.) Seob’log](https://seobie.github.io/blog/git-action-struggles) ‘&lt; &gt;’ 이게 문법적으로 충돌이 생겨서 backslash로 취소효과를 주는 것 같다.log에서 오류가 발생한 파일을 찾아서 단어 탐색으로 꺽쇠를 찾아주고 ‘&lt; &gt;’ 부분에 나도 backslash를 추가해주니 오류가 나지 않고 정상 빌드되었다.그리고 마지막으로 github repository → Setting → Pages → Source에 가서 기본 브랜치를 gh-pages로 변경해주어야 한다. (정상 빌드되었다면 gh-pages가 자동으로 생겼을 것이다.)여기까지 해주면 링크를 들어가면 블로그가 정상적으로업데이트되어있다." }, { "title": "Jekyll Chirpy Theme에서 Code Block Style 변경", "url": "/posts/codeblock_change/", "categories": "Jekyll", "tags": "jekyll", "date": "2022-04-29 00:00:00 +0900", "snippet": "Chirpy Theme은 Light 테마와 Dark 테마로 이루어져 있음화면 좌측 사이드바 하단의 첫번째 버튼을 클릭해서 변경 가능Light 테마Dark 테마Light 테마의 경우는 다른거는 다 보기 편한데, Code Block도 하얘서 눈에 잘 안 들어왔고, Dark 테마의 경우 반대로 코드는 눈에 잘 들어오지만 다른 부분이 너무 어두침침한 느낌이 있었다.전체적인 테마는 Light Theme을 사용하되, 코드 블록만 Dark Theme을 사용하고자 한다면 sass/addon/syntax.scss의 아래 빨간 부분을 light에서 dark로 변경해주면 된다.추가적으로, 아예 customizing된 style을 적용하고자 할 경우에는 colors 디렉토리에 아예 새로운 scss 파일을 추가해주고, 이를 import해와서 light이랑 dark 대신에 사용하면 된다.예를 들어, Atom의 One Dark Theme을 사용하고자 하는 경우, 이 분의 가이드에 따라서 syntax.css를 만들고, 이를 colors 디렉토리에 scss 파일 확장자로 추가해서 import해서 사용하면 된다.Jekyll의 Code Block 테마 예쁘게 만들기변경 전 (Light Theme with Light Style Code Block)변경 후 (Light Theme with Dark Style Code Block)" }, { "title": "BOJ 2110번 공유기 설치 파이썬", "url": "/posts/2110%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 이진탐색", "date": "2022-04-28 00:00:00 +0900", "snippet": "문제도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.입력첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.출력첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.비록 혼자 힘으로 풀지는 못했지만, 그래도 배운 점이 있다.우선 이진탐색의 경우, 어떤 구간에 대하여 이진탐색을 할 것인가 가 중요한데 이는 곧 문제에서 출력하도록 요구하는 것일 확률이 높다.이 문제에서는 가장 인접한 두 공유기 사이의 거리를 요구하고 있기 때문에 거리를 이진탐색의 범위로 잡으면 된다.그렇다면 이진탐색이 될 수 있는 실질적인 (수치적인) 구간을 어떻게 정할것인지를 생각해보자이진탐색에는 첫 start와 end가 있고, 이 둘의 중간으로 mid가 정해진다.첫 최소 거리 (start)의 경우, 문제에서 알 수 있듯, 최소 공유기 개수는 2개이고 집의 좌표는 0 ≤ xi ≤ 1,000,000,000이기 때문에 1로 잡는다.첫 최대 거리 (end)의 경우, 공유기 간의 거리가, 시작집과 끝 집 간 좌표 거리보다 클 일은 없으므로 이 값으로 지정해주면 된다.mid는 방금 정한 start와 end의 중간값이다.이제 loop을 돌면서, 앞집부터 끝집까지 mid 거리를 유지하면서 공유기를 설치해본다.만약, 설치할 수 있는 개수가 c (설치해야 하는 개수)보다 같거나 크다면, 아직 이 값이 문제에서 요구하는 최댓값인지는 모르지만 정답 후보이기 때문에 저장해두고, 욕심을 내서 mid를 더 크게 잡아본다. (최댓값을 찾기 위해))만약 설치할 수 있는 개수가 c보다 작다면 mid를 너무 빡빡하게 잡았기 때문에, 이 거리로 문제에서 요구하는 공유기를 설치 못한것이다. 즉, mid (공유기 간의 거리)를 더 작게 해서 다시 시도해봐야 한다.end가 start보다 같거나 커지면서 이진탐색이 끝나게 되고, 정답 후보가 나올때마다 갱신해 온 answer가 최종 답이 된다.#가장 인접한 공유기 간의 거리가 최댓값이 되게 하라는 것은, 공유기 한 쌍은 엄청 가깝고, 다른 한 쌍은 엄청 먼 경우같이 편향적인 경우를 지양하고#모든 공유기간의 거리가 최대한 멀도록 optimized된 결과를 도출하라는 것이다.# n은 집의 개수이고# c는 공유기의 개수이다n, c = map(int, input().split())# address는 집의 좌표를 담은 배열이다.address = []for i in range(n): address.append(int(input()))# 오름차순으로 변경해준다.address.sort()def bs(address, start, end): #이진탐색이 끝나는 조건 while start &lt;= end: mid = (start + end) // 2 current = address[0] #설치할 수 있는 공유기 개수 count = 1 #좌표를 돌면서, 만약 for i in range(1, len(address)): #current+mid는 현재 거리에서 mid 만큼 떨어진 곳, 그 집에 공유기를 설치할 수 있는지 보는것이다. #만약 집 좌표가 그 값보다 같거나 크다면 설치할 수 있다는 것임으로, count (설치 가능한 공유기 개수)를 추가해주고, current(현재 위치)를 갱신한다. if address[i] &gt;= current + mid: count += 1 current = address[i] #설치할 수 있는 공유기 개수가 c보다 크면, 간격이 여유가 있다는 뜻임으로, 최대값을 찾기 위해서 거리를 더 넓혀준다. if count &gt;= c: global answer start = mid + 1 #일단 현재값이 답 후보이기 때문에 answer에 저장해준다. answer = mid #만약 그 거리만큼 공유기 설치를 할 수 없다면 거리를 줄인다 else: end = mid - 1#시작 최소거리는 1이고, 시작 최대거리는 첫 집과 마지막집 간의 거리이다.start = 1end = address[-1] - address[0]answer = 0bs(address, start, end)print(answer)" }, { "title": "BOJ 10451번 순열 사이클 파이썬", "url": "/posts/10451%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS", "date": "2022-04-28 00:00:00 +0900", "snippet": "문제입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분되어 있다.출력각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.배열 index는 0부터 시작하지만 입력으로 들어오는 값은 1부터이다.따라서 편의를 위해서 graph랑 visited의 index는 사용 안하는데, 이런 자잘한 부분을 놓치면 index out of range가 발생할 수 있다.여태 풀어본 dfs 문제에서는 부모 노드가 여러 자식노드를 갖고 있는 형태였는데, 이 문제에서는 최대 한 개 노드까지 밖에 가질 수 없어서 더 간단하다.import syssys.setrecursionlimit(100000)t = int(input())def dfs(x): global visited visited[x] = True #아직 방문하지 않았을 때만 방문하고, 방문하면 방문처리 if not visited[graph[x]]: dfs(graph[x])for i in range(t): #초기화 n = int(input()) graph = list(map(int,input().split())) graph.insert(0,0) visited = [False] * (n+1) cnt = 0 for k in range(1,n+1): if not visited[k]: dfs(k) cnt+=1 print(cnt)" }, { "title": "Python 가상환경 관련 (feat. Jupyter)", "url": "/posts/python_venv/", "categories": "Python", "tags": "파이썬, 가상환경, jupyter", "date": "2022-04-27 00:00:00 +0900", "snippet": "가상환경 생성//python3 -m venv (가상환경이름)python3 -m venv newEnv가상환경 활성화source bin/activate가상환경 활성화 하고 ipykernel 설치pip3 install ipykernelipykernel 설치 시 아래 오류가 뜨면ERROR: Could not build wheels for pyzmq which use PEP 517 and cannot be installed directly해결책pip install --upgrade pip setuptools wheelpip install opencv-pythonJupyter Notebook에 설치된 가상환경 추가 (가상환경 활성화 이후)python3 -m ipykernel install --user --name 가상환경이름 --display-name \"보여질 이름\"이 명령어를 치면 Installed되었다고 뜨고, Jupyter 서버를 재실행하면 kernel에 추가되어 있음Jupyter Notebook에 가상환경 제거jupyter kernelspec uninstall 가상환경이름가상환경 설정한 디렉토리를 이동했을 시파이썬에서 가상 환경을 생성할 때 이미 해당 경로가 가상환경 폴더 안에 입력되기 때문에, 생성 뒤 폴더를 다른 곳으로 이동시키면 가상환경 경로가 저절로 갱신되지 않음그래서 경로를 옮긴 상태에서 가상환경을 활성화하더라도, 패키지를 설치하면 Global하게 설치됨.이를 해결하려면 , 가상환경 폴더의 Scripts 폴더 아래에 있는 activate.bat, Activate.ps1, activate 세개의 파일을 수정해야 함파일들 안에 VIRTUAL\\_ENV라는 부분이 있는데,  해당 부분을 옮긴 경로로 수정하면 정상적으로 구동이 가능하다." }, { "title": "Django 쉘 (Shell)", "url": "/posts/django_shell/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-27 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.쉘 (Shell)이란?코드 한 줄 입력받고 바로 실행결과 출력해주는 프로그램python (python3)를 입력하면 나오는 파이썬 쉘은 장고 프로젝트 설정이 로딩되어 있지 않음장고 프로젝트 설정이 로딩된 파이썬 쉘python3 manage.py shell#-i (--interface): 인터프리터 인터페이스 커스텀 지정#-c (--command): 실행할 파이썬 코드를 문자열로 지정쉘 열리는 우선순위 (ipython, bpython 등이 설치되어 있다면):ipython쉘 , bpython쉘, python쉘Jupyter는 ipython을 사용함아래처럼 쉘 내에서 환경변수를 추가해주어야 장고 모델 등을 import할 수 있음실제 장고의 환경변수를 변경하는 것은 아니고, 쉘 내에서만 변경하는 것import osos.environ['DJANGO_SETTINGS_MODULE'] = 'askcompany.settings'os.environ['DJANGO_ALLOW_ASYNC_UNSAFE'] = 'true'import djangodjango.setup()Django 3부터는 비동기가 지원이되어서, 주피터에서 장고를 사용할 때 SynchronousOnlyOperation에러가 뜸따라서 아래 코드를 추가해주어야 에러가 안 남os.environ['DJANGO_ALLOW_ASYNC_UNSAFE'] = 'true'" }, { "title": "Django 모델을 통한 조회 (기초)", "url": "/posts/django_query/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-27 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.Model Manager데이터베이스 질의 인터페이스를 제공디폴트 Manager로서 ModelCls.objects가 제공아래처럼 사용ModelCls.objects.all()ModelCls.objects.all().order_by('-id')[:10]ModelCls.objects.create(title=\"New Title\")QuerySetSQL을 생성해주는 인터페이스순회가능한 객체Model Manager를 통해, 해당 Model에 대한 QuerySet을 획은 Post.object.all() … → “SELECT * FROM Post” Post.objects.create(…) “INSERT INTO …”QuerySet의 Lazy한 특성이 있음무슨 의미인가 하면, 아무리 아래처럼 쿼리 셋에 조건을 추가해도 아직 실제로 쿼리를 날리지는 않는다.qs = Post.objects.all().order_by('-id')[:2}실제로 쿼리를 해서 데이터를 가져오는 시점은 qs를 호출할 때이다. (실제로 데이터가 필요할 때)Query는 Chaining 가능Post.objects.all(…).filter.exclude(…).filter(…) → QuerySet 마치 mongoDB의 aggregation pipelineenter를 쳐서 line을 구분하려면 아래처럼 backslash를 넣어주어야 함Query Set 모델객체 획득queryset[숫자인덱스] 모델객체 혹은 없으면 예외발생 (IndexError)queryset.get(...) 모델객체 혹은 없으면 예외발생 (DoesNotExist, MultipleObjectsReturned)queryset.first() 모델객체 혹은 Nonequeryset.last() 모델객체 혹은 None예시조건 추가" }, { "title": "Django가 Media를 처리하는 방법", "url": "/posts/django_media/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-27 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.Static 파일개발 리소스로서의 정적인 파일 (js,css,image등)앱/프로젝트 단위로 저장/서빙Media 파일FiledField/ImageField 를 통해 저장한 모들 파일 → Model을 통해서 관리하는 방법 FileField: FIled Storage API 사용 (장고는 Filed System Storage만 지원. django-storages를 통해 확장 지원) ImageField(FileField 상속) Pillow를 통해 이미지 (width,height) 획득 Pillow 미설치시에 makemigrations 실패 (M1에서는 설치해도 오류남, 별도 조치 필요할듯) 위 필드를 상속받은 커스텀 필드를 만들 수도 있음 PDXField, ExcelField등 DB 필드에는 저장경로를 저장하며, 파일은 파일 스토리지에 저장 → File Storage API실제로 문자열을 저장하는 필드(중요)프로젝트 단위로 저장/서빙model에 ImageField를 추가하고 makemigrationsMac M1을 사용하는중인데 Pillow를 설치하고, ImageField를 사용하려고 하면 다음과 같은 오류가 뜬다.가상환경을 새로 만들어보고, python interpreter를 3.7, 3.9등으로 바꿔보고, Pillow도 다양한 버전을 설치해봤는데도 똑같은 오류가 뜬다.검색해보니 이런 오류가 뜨는 사람들이 꽤 있는 것 같은데 나중에 알아봐야 할 것 같다.instagram.Post.photo: (fields.E210) Cannot use ImageField because Pillow is not installed. HINT: Get Pillow at https://pypi.org/project/Pillow/ or run command \"python -m pip install Pillow\".Media 파일 처리 순서 HttpRequest.FILES를 통해 파일이 전달 뷰 로직이나 폼 로직을 통해 유효성 검증 FiledFIeld/ImageFIled 필드에 경로를 저장 (문자열) settings.MEDIA_ROOT 경로에 파일을 저장장고 디렉토리 settings.py 에 Media 저장 경로 추가MEDIA_URL: 미디어의 URLMEDIA_ROOT: 미디어가 실제 저장되는 경로해당 파일 최상단에 보면 BASE_DIR을 확인 가능**file: 파이썬 파일 import 될 떄의 경로를 담고 있음****file.parent.parent: 해당 파일의 부모의 부모 경로이니 프로젝트 디렉토리를 의미**admin페이지에서 이미지를 올리고, url을 클릭해서 들어가도 이미지가 안 뜨고 page not loaded가 뜸urlpatterns에서 static 경로를 추가해주어야 함장고는 실제 production 상태에서는 장고내에서 static이나 media file serving을 하는것을 권장하지는 않음 (그래서 Debug=False 일때는 아래 경로가 빈 리스트를 반환함 )사용할 만한 필드 옵션blank: 업로드 옵션 처리 여부 디폴트 falseupload_to문자열로 지정하면 ‘중간 디렉토리 경로’함수로 지정하면 ‘중간 디렉토리 경로’ 및 ‘파일명’ 미디어가 저장될 경로를 override 아래 빨간줄처럼 작성하면 media root 아래 instagram/post 경로에 저장됨 근데 위와 같이 해도 결국 서비스를 관리하다보면 폴더에 미디어가 몇천개씩 쌓이게 된다. 경로 뒤에 /instagram/posts/%Y%m%d%H%M%S 이런식으로 시간별로 저장되게 할 수도 있다. instagram/posts/%Y/%m/%d instagram/posts/%Y%m%d instagram/posts/%Y%m%d/%H%M%S 이렇게 변경한다고해서 이미 저장된 파일들이 위와 같은 형식으로 저장되는 것이 아니고, 새로 파일을 저장할 때 반영이 됨#from 프로젝트폴더 import settings가 아니라 django.conf에서#import를 해야 global_settings와 settings를 합쳐줌from django.conf import settingsFile Upload Handler파일크기 ≤ 2.5MB 메모리에 담겨 전달 MemoryFileUploadHandler파일크기 &gt; 2.5MB 디스크에 담겨 전달 TemporaryFIleUploadHandler관련 설정settings.File_UPLOAD_MAX_MEMORY_SIZE 2.5MB" }, { "title": "트리 정의 및 종류", "url": "/posts/tree/", "categories": "Algorithm", "tags": "알고리즘, 트리", "date": "2022-04-26 00:00:00 +0900", "snippet": "트리이진트리 (Binary Tree)란?자식 노드 (Child Node)가 최대 2개까지 붙는 트리자식 개수 n에 따라서 n진 트리라고 부름.이진 트리 형식이 가장 유명한 이유는 구조가 가장 간단하고, 간단한 구조에 비해 활용도도 뛰어나기 때문.이진 검색 트리 (Binary Search Tree)란?부모 노드의 왼쪽 모든 노드들은 부모 노드보다 작고, 오른쪽 모든 노드들은 부모 노드보다 큰 트리Full Binary Tree란?자식 노드를 하나만 갖고 있는 노드가 아예 없는 경우Complete Binary Tree란?마지막 레벨을 제외한 모든 subtree의 레벨이 같고, 마지막 레벨은 자식 노드들이 왼쪽부터 채워져있는 경우Perfect Binary Tree란?모든 노드가 다 채워져있는 트리좀 더 정확하게 말하면, 레벨의 개수를 n이라고 가정할 때 2^n-1개의 노드를 가지는 트리" }, { "title": "BOJ 11501번 주식 파이썬", "url": "/posts/11501%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-26 00:00:00 +0900", "snippet": "문제홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다. 주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다.홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.입력입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.출력각 테스트케이스 별로 최대 이익을 나타내는 정수 하나를 출력한다. 답은 부호있는 64bit 정수형으로 표현 가능하다.시간초과 코드t = int(input())for i in range(t): d = int(input()) s = list(map(int,input().split())) asset = [] profit = 0 maxv = max(s) for j in range(d): if s[j] != maxv: asset.append(s[j]) else: for k in asset: profit += maxv-k asset = [] if j+1 &lt; d: maxv = max(s[j+1:]) print(profit)91%에서 시간초과가 난다.아무리 그리디 문제이지만 너무 직관적으로 로직을 만들었는지, 시간 계산을 잘못한 것 같다.현재 온 지점부터 끝 지점까지 max를 구하고, 만약 현 시점의 값이 그 max보다 작다면 asset 배열에 넣어두었다가, 최대값을 만나면 asset 배열을 순회하면서 다 팔아버리는 방식이다.하지만 이렇게 되면 배열을 내부에 하나 더 넣어야 하고, max도 매번 비효율적인 방식으로 갱신하므로 시간초과가 났던게 당연하다.정답코드import sysinput = sys.stdin.readlinet = int(input())for i in range(t): n = int(input()) s = list(map(int,input().split())) asset = [] profit = 0 maxv = s[-1] for j in range(n-2,-1,-1): if s[j] &gt; maxv: maxv = s[j] else: profit += maxv-s[j] print(profit)배열을 거꾸로 순회하기 때문에, 현재 날과 다음날을 비교하는 코드를 굳이 넣지 않아도 되고, 뒤에서부터 최대치를 갱신해나가기 때문에 최대값에 파는 것을 보장할 수 있다." }, { "title": "BOJ 11052번 카드 구매하기 파이썬", "url": "/posts/11052%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-04-26 00:00:00 +0900", "snippet": "문제요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다. 전설카드 레드카드 오렌지카드 퍼플카드 블루카드 청록카드 그린카드 그레이카드카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.입력첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)출력첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.불필요하게 길게 짠 코드n = int(input())s = [0] + list(map(int,input().split()))dp = [0]dp.append(s[1])def sol(dp): if n &gt; 1: dp.append(max(dp[1] * 2, s[2])) if n &lt; 2: print(dp[n]) return for i in range(3,n+1): maxv = s[i] for j in range(1,i): if i % j == 0: maxv = max(maxv,dp[j] * i//j) else: maxv = max(maxv,dp[j] + dp[i-j]) dp.append(maxv) print(dp[n])sol(dp)최적화한 코드n = int(input())s = [0] + list(map(int,input().split()))dp = [0]+ [0 for _ in range(n+1)]def sol(dp): for i in range(1,n+1): for j in range(1,i+1): dp[i] = max(dp[i],dp[i-j] + s[j]) print(dp[n])sol(dp)우선 n이 2 미만일때를 미리 구해놓을수는 있지만, 굳이 그러지 않아도 값이 정상적으로 계산이 된다.그리고 나눠떨어질때와 떨어지지 않을때를 if else로 구분해줘야 한다고 생각했는데, dp 뿐 아니라 초기에 카드 가격을 받았던 s 배열을 사용한다면 한줄로 해결할 수 있다.dp 문제를 많이 풀면서, 방법론은 반복학습으로 익숙해지지만 아직 그 문제에서 dp가 무엇을 의미하는가에 대한 고민이 부족한 것 같다. 이 부분에 대한 연습이 필요할 것 같다." }, { "title": "BOJ 19539번 사과나무 파이썬", "url": "/posts/19539%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-21 00:00:00 +0900", "snippet": "BOJ 19539번 사과나무 파이썬문제이하는 최근 사과나무 씨앗을 구매하여 농장 뒷뜰에 일렬로 1$1$번부터 N$N$번까지 심었다. 이 나무들의 초기 높이는 모두 0$0$이다.사과나무를 무럭무럭 키우기 위해 이하는 물뿌리개 2$2$개를 준비했다. 한 물뿌리개는 나무 하나를 1$1$만큼 성장시키고, 다른 물뿌리개는 나무 하나를 2$2$만큼 성장시킨다. 이 물뿌리개들은 동시에 사용해야 하며, 물뿌리개를 나무가 없는 토양에 사용할 수는 없다. 두 물뿌리개를 한 나무에 사용하여 3$3$만큼 키울 수도 있다.물뿌리개 관리 시스템을 전부 프로그래밍한 이하는 이제 사과나무를 키워보려고 했다. 그 순간, 갊자가 놀러와서 각 사과나무의 높이가 이런 배치가 되었으면 좋겠다고 말했다. 이제 이하는 약간 걱정이 되기 시작했는데, 갊자가 알려준 사과나무의 배치를 이 프로그램 상으로 만들어내지 못할 수도 있기 때문이다.이하는 이제 프로그램을 다시 수정하느라 바쁘기 때문에, 두 물뿌리개를 이용해 갊자가 알려준 사과나무의 배치를 만들 수 있는지의 여부를 판단하는 과정은 여러분의 몫이 되었다.입력첫 번째 줄에는 자연수 N$N$이 주어진다. (1 ≤ N ≤ 100,000) 이는 이하가 뒷뜰에 심은 사과나무의 개수를 뜻한다.두 번째 줄에는 N개의 정수 h1,h2, …, hn이 공백으로 구분되어 주어진다. (0≤hi≤10,000) hi는 갊자가 바라는 i번째 나무의 높이이다.출력첫 번째 줄에 모든 나무가 갊자가 바라는 높이가 되도록 물뿌리개를 통해 만들 수 있으면 “YES”를, 아니면 “NO”를 따옴표를 제외하고 출력한다.import sysinput = sys.stdin.readlinen = int(input())s = list(map(int,input().split()))total = sum(s)if total % 3 != 0 : print('NO')else: cnt = 0 days = total // 3 for i in range(n): cnt+=s[i] // 2 if cnt&gt;=days: print('YES') else: print('NO')풀이방식일단은 YES가 나오기 위한 첫번째 조건은, 전체 길이 합이 3으로 나눠떨어지는 것이다.1만큼 자라는 분무기도 있고, 2만큼 자라는 분무기가 있지만, 문제에 따르면 물을 ‘한 나무에 3만큼 몰아서’ 주던, 아니면 ‘한 나무에 1 다른 나무에 2’, 이렇게 나눠서 주던 매번 3만큼 주는 사실은 변하지 않기 때문이다.그래서 3으로 나눠떨어지지 않으면 빼박 NO이다.하지만 길이 총합이 3으로 나눠떨어진다고 해서, 무조건 YES가 아니라 한 조건이 더 갖추어져야 한다.어떤 경우에던, (1 분무기와 2 분무기를 동시에 사용하거나, 동시에 한 나무에만 3만큼 몰아서 주거나), 한번 물을 줄 때 어떤 나무 ‘하나’ 이상은 꼭 2 혹은 3 이상의 분무기로 물을 받아야 한다.따라서 예를 들어 1만큼 자라야 하는 나무가 3개 있어서 총합이 3으로 나눠떨어지더라도, 이 세 나무 중 어떤 나무도 2 혹은 3 이상의 분무기를 받을 수 없기 때문에 NO이다.그래서 정리하자면, 일단은 길이의 총합이 3으로 나눠떨어지는지 보고 (조건 1 ), 만약 그렇다면, 배열을 돌면서 2 이상인 값의 개수가, 길이 총합을 3으로 나눈 값보다 같거나 큰지 보면 된다. (조건 2)" }, { "title": "BOJ 15656번 N과 M (7) 파이썬", "url": "/posts/15656%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-04-21 00:00:00 +0900", "snippet": "문제N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다.입력첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.n, m = map(int,input().split())s = list(map(int,input().split()))s.sort()#같은 수를 여러번 골라도 된다. == 순서가 상관없다.temp = []def solve(): global temp if len(temp) == m: print(*temp) return for i in range(n): temp.append(s[i]) solve() temp.pop()solve()풀이방식중복 숫자도 허용되기 때문에 재귀로 들어간 함수에서 처음부터 반복문을 돈다." }, { "title": "BOJ 15656번 N과 M (7) 파이썬", "url": "/posts/15655%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-04-21 00:00:00 +0900", "snippet": "문제N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. N개의 자연수 중에서 M개를 고른 수열 같은 수를 여러 번 골라도 된다.입력첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.n, m = map(int,input().split())s = list(map(int,input().split()))s.sort()visited = [0]*(n)temp = []def solve(idx): global temp #만약 길이가 충족되면 print해줌 if len(temp) == m: print(*temp) for i in range(idx,n): if s[i] not in temp: temp.append(s[i]) solve(i+1) temp.pop()solve(0)풀이방식고른 수열은 오름차순이어야 하기 때문에 sort를 먼저 해준다.반복문을 돌면서(마찬가지로 오른차순이기 때문에 range의 시작점은 자기 자신부터 n까지), 만약 temp 배열에 없다면 추가해주고 다시 그 숫자에 대해서 재귀적으로 함수를 실행한다.길이가 충족되면 print 해주고 그 solve함수는 return되고, 다른 경우의 수까지 보기 위해서 직전에 집어넣었던 수는 pop() 해주게 된다." }, { "title": "BOJ 14889번 스타트와 링크 파이썬", "url": "/posts/14889%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 브루트포스", "date": "2022-04-21 00:00:00 +0900", "snippet": "문제오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.N=4이고, S가 아래와 같은 경우를 살펴보자.축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.입력첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.출력첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.풀이 방식되게 느리게 채점돼서 시간초과나겠거니 하고 있었는데 맞았다.combinations를 사용해서 직관적인 브루트포스 방식으로 풀었다.우선 N을 2로 나눈 값이 스타트팀과 링크팀의 인원수이기 때문에, 가능한 조합을 N/2로 combinations를 구한다.조합을 list로 변환하고 나면 첫번째 index 조합과 마지막 index 조합은 서로 스타트팀과 링크팀 관계이다.그래서 반복문을 조합 길이를 2로 나눈 값만큼 돌리고, 한번 돌릴 때 스타트팀과 링크팀 시너지값을 다 계산해주면 된다.주의할 점은 시너지 배열 인덱스를 0부터 받았기 때문에, 인덱싱할 때 -1해서 접근해주어야 한다.스타트팀과 링크팀의 각각 시너지값을 구하고 min값으로 최소값인지 비교해서 갱신해주면 된다.from itertools import combinationsimport mathimport sysinput = sys.stdin.readlinen = int(input())s = [list(map(int,input().split())) for i in range(n)]teams = list(combinations(range(1,n+1),n//2))# print(teams)difference = math.inffor i in range(len(teams)//2): # print(teams[i]) start_team = 0 link_team = 0 start_couples = list(combinations(teams[i],2)) link_couples = list(combinations(teams[-1-i],2)) #스타트팀 시너지 더하기 for j in range(len(start_couples)): start_team += s[start_couples[j][0]-1][start_couples[j][1]-1] start_team += s[start_couples[j][1]-1][start_couples[j][0]-1] #링크팀 시너지 더하기 for j in range(len(link_couples)): link_team += s[link_couples[j][0]-1][link_couples[j][1]-1] link_team += s[link_couples[j][1]-1][link_couples[j][0]-1] difference = min(difference,abs(start_team-link_team))print(difference)" }, { "title": "Elastic Beanstalk 여러 환경 관리", "url": "/posts/eb-multienv/", "categories": "AWS", "tags": "aws, elastic beanstalk", "date": "2022-04-19 00:00:00 +0900", "snippet": "사용하는 패키지도 같고 구현하려는 것도 거의 흡사한데, 약간 변형해서 별도의 어플리케이션으로 별도할 일이 있었다.그래서 git으로 branch로 나눠서 따로 개발을 하고, 이제 배포도 따로 하려고 알아보니 elastic beanstalk는 어플리케이션당 별도의 eb instance를 사용하기 때문에 동시에 서비스하려면 각각의 eb 어플리케이션과 환경을 만들어야 한다고 한다.아무래도 사용하는 패키지나 기타 등등 다 같기 때문에 지금처럼 branch만 달리해서 개발하는게 좋을 것 같은데, 그러면 동일한 디렉토리에서 어떻게 eb 환경을 구분해야 할지 몰랐다.Elastic Beanstalk에서 Multiple Environment를 구성하는 방법이 나와있는데 여기 나와있는 명령어를 입력하면 아무 반응이 없다…eb init --modules componentA componentBEB CLI를 사용하여 여러 Elastic Beanstalk 환경을 하나의 그룹으로 관리결국 기존의 .elasticbeanstalk의 이름을 벡업하기 위해서 이름을 변경해두고, 새로 eb init을 하고 eb create을 했다.또 의아한 점 하나는, AWS 웹 사이트에서 어플리케이션을 만들어뒀었다면, eb init할 때 그 어플리케이션을 동기화할거냐고 물어보는데, 웹 사이트에서 만들어뒀던 환경을 동기화 할 방법이 있는지는 모르겠다. (eb create를 하면 아예 새로 환경을 만들어버린다.)첫 elastic beanstalk 어플리케이션과 환경을 만들때는 웹 사이트에서 eb create을 만들었어서 이를 생략하고 바로 eb deploy를 했는데, 이번엔 새로운 환경에 배포하려면 어떻게 해야할지 따로 옵션이 안주어져서 난감했다..일단 계획은 다음과 같았다. 기존 .elasticbeanstalk 이름 변경 (벡업) eb init (codecommit 사용한다고 선택) AWS 웹사이트에서 codecommit Repo 생성 codecommit HTTPS username이랑 password 다시 입력하라고 할거임 git branch로 관리하던 코드 이 repo에 push (2번에서 사용한다고 한 branch로 push해야 함) eb create (환경이 생성되고 codecommit에 있는 코드가 배포됨, codecommit을 사용한다고 설정했는데 만약 리포에 push되어있는 코드가 없으면 다음과 같은 에러가 남)ERROR: InvalidParameterValueError - \"Error making request to CodeCommit: Could not retrieve 04b69a00b82806e34b00024c8a3a43282c45a869 (Service: AWSCodeCommit; Status Code: 400; Error Code: CommitIdDoesNotExistException; Request ID: 92bc4c60-a052-47bb-9230-bb5e40a6ddcd; Proxy: null)\"이렇게 했다가 어떤 과정에서 에러가 났었는데, 생성했던 리포랑 환경 삭제하고 다시 하니까 왜인지 정상적으로 배포되었다… 뭐가 문제인지는 모르지만 어딘가에서 꼬였던 것 같다.그래서 기존 환경을 사용하려면 이름 변경했던 .elasticbeanstalk 폴더 이름을 다시 원래대로 바꾸고, 새로운 환경 .elasticbeanstalk 폴더는 다른 이름으로 변경해주어야 한다.더 편할 방법이 있을 것 같기는 한데… 일단 이게 최선인 것 같다." }, { "title": "Django 모델 (ORM)", "url": "/posts/django_orm-copy/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-18 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 장고 ORM데이터베이스와 SQLSQL: 데이터베이스에 쿼리하기 위한 언어직접 SQL을 만들어내기도 하지만, ORM (Object-relational mapping)을 통해 SQL을 생성/실행하기도 한다.ORM을 쓰더라도, 작성한 ORM코드를 통해 어떤 SQL이 실행되고 있는지 파악을 해야 최적화 가능 django-debug-toolbar 적극 활용장고 ORM인 모델은 RDB만을 지원다양한 파이썬 ORMRleational Databases django databases, sqlalchemy, orator, peewee, ponyORM 등NoSQL Databases django-mongodb-engine, hot-redis, MongoEngine, PynamoDB 등장고의 강점은 Model과 Form물론 장고에서도 다양한 ORM 라이브러리를 사용 가능. 적절하게 섞어쓸 수 있음SQL을 직접 실행할 수도 있지만, 간으하면 ORM tkdyd 직접 SQL문자열을 조합하지 말고, 인자로 처리 → SQL Injection 방지 SQL Injection이란 악의적인 사용자가 특정 SQL 쿼리 문을 전송하여 서버 DB를 공격하는 해킹 기법 Django Model데이터베이스 테이블과 파이썬 클래스를 1:1로 매핑모델 클래스명은 단수형으로 지정 ex: Posts (x), Post (O) 클래스이기에 필히 첫 글자가 대문자인 PascalCase 네이밍매핑되는 모델 클래스는 DB 테이블 필드내역이 일치해야 함모델을 만들기 전에 서비스에 맞게 데이터베이스 설계가 필수 즉 관계형 데이터베이스 학습도 필요 (DB의 영역은 또 다름 )앱 폴더에 있는 models.py 파일에 아래처럼 작성하게 됨모델 활용 순서 장고 모델을 만들고, 데이터 베이스 형상 관리 모델 클래스 작성 모델 클래스로부터 마이그레이션 파일 생성 → makemigrations 명령 마이그레이션 파일을 데이터베이스에 적용 → migrate 명령 모델 활용 기존 외부 DB를 현재 데이터베이스로 가져와서 형상 관리 데이터베이스로부터 모델 클래스 소스 생성 → Inspectdb 명령 모델 활용 모델명과 DB 테이블명DB 테이블명: 디폴트 “앱이름_모델명”ex.blog앱 Post 모델: blog_post Comment 모델: blog_commentshot 앱 Item 모델: shot_item review 모델: shop_review적용순서Item 모델 정의마이그레이션 파일 생성python3 manage.py makemigrations 앱이름마이그레이션 파일 적용python3 manage.py migrate데이터베이스 확인#sqllite가 생성되어 있다면python3 manage.py dbshell위 순서대로 모델 만들어서 적용해보기앱 등록인스타그램 이라는 이름의 앱 생성python3 manage.py startapp instagramsettings.py에 앱 이름 추가INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog', 'instagram',]urls.py 직접 추가안에 다음과 같이 입력urlpatterns = []프로젝트 디렉토리 urls.py에 다음 한 줄 추가모델 생성instagram 디렉토리 models.py에 다음과 같이 모델 생성from django.db import models# Create your models here.class Post(models.Model): message = models.Textfield() created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now=True)마이그레이션 파일 적용python3 manage.py makemigrations instagram오타가 있거나 하면 다음과 같은 에러가 남AttributeError: module 'django.db.models' has no attribute 'Textfield'혹은 settings.py에 앱을 추가안해주었거나, 추가해주고 저장을 안해주었다면 다음과 같은 에러No installed app with label 'instagram'.성공하면 다음과 같이 뜸Migrations for 'instagram': instagram/migrations/0001_initial.py - Create model Post마이그레이션 파일 적용다음 명령어 입력python3 manage.py migrate instagram아래와 같이 뜨면 models.py에 작성한대로 Post라는 테이블이 생성이 된 것Operations to perform: Apply all migrations: instagramRunning migrations: Applying instagram.0001_initial... OK데이터베이스에 들어간 코드 확인python3 manage.py sqlmigrate instagram 0001_initial아래와 같은 명령어가 입력된 것을 알 수 있음 (id는 따로 지정안해주었지만 primary key로 자동 생성되어씅ㅁ)BEGIN;---- Create model Post--CREATE TABLE \"instagram_post\" (\"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT, \"message\" text NOT NULL, \"created_at\" datetime NOT NULL, \"updated_at\" datetime NOT NULL);COMMIT;" }, { "title": "Django 모델 필드", "url": "/posts/django_mf/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-18 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 장고 모델 필드기본 지원되는 모델필드 타입 (1)Primary Key: AutoField (ID처럼 자동생성되어서 increment되는 field), BigAutoField문자열: CharField, TextField, SlugField날짜/시간: DateField, TimeField, DateTimeField,DurationField참/거짓: BooleanField, NullBooleanField숫자: IntegerField,SmallIntegerfield, PositiveIntegerField, PositiveSmallIntegerField, BigIntegerField, DecimalField, FloatField파일: BinaryField, FileFiled, ImageField, FilePathField기본 지원되는 모델필드 타입 (2)이메일: EmailFieldURL: URLFieldUUID: UUIDField아이피: GenericIPAddressFieldRelationship Types ForeignKey ManyToManyField OneToOneField그리고 다양한 커스텀 필드들django-model-utils: https://django-model-utils.readthedocs.io/en/latest/모델필드들은 db 필드타입을 반영DB에서 지원하는 필드들을 반영Varchar 필드타입 → CharField, SlugField, URLField, EmailField파이썬 데이터타입과 데이터베이스 데이터타입을 매핑AutoField → intBinaryField → bytesBooleanField → boolCharField/SlugField/URLField/EmailField → strCharField/SlugField/URLField/EmailField의 경우처럼 다 str인 경우더라도, 디폴트로 적용된 유효성 검사 등의 차이가 생긴다.예를 들어서 CharField 같은 경우에는 지정한 길이로 str을 받기만 한다면, URLField는 str이면서 + URL 형식이어야지만 저장이 된다. 마찬가지로 EmailField도 이메일 형식이어야지만 저장이 된다.같은 모델필드라 할지라도 DB에 따라서 다른 타입이 될 수 도 있다.자주 쓰는 필드 공통 옵션blank, null, db_index, default, unique, choices, validators, verbose_name, help_textblack 같은 경우에는 Default가 False이다.그래서 message = models.TextField() 이런식으로 생성하고, message 값이 없이 저장한다면 모델과 연동된 django form 사용시 유효성 검사에서 실패한다. (Form을 사용하지 않고 Model만 사용해서 저장하면 유효성 검사가 수행되지 않음)하지만 그렇다고 해서, 무조건적으로 blank랑 null 같은 옵션을 True 설정하지 말 것 (django의 이점을 활용하지 못함)Model 예시# Django 모델 필드강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 장고 모델 필드기본 지원되는 모델필드 타입 (1)Primary Key: AutoField (ID처럼 자동생성되어서 increment되는 field), BigAutoField문자열: CharField, TextField, SlugField날짜/시간: DateField, TimeField, DateTimeField,DurationField참/거짓: BooleanField, NullBooleanField숫자: IntegerField,SmallIntegerfield, PositiveIntegerField, PositiveSmallIntegerField, BigIntegerField, DecimalField, FloatField파일: BinaryField, FileFiled, ImageField, FilePathField기본 지원되는 모델필드 타입 (2)이메일: EmailFieldURL: URLFieldUUID: UUIDField아이피: GenericIPAddressFieldRelationship Types ForeignKey ManyToManyField OneToOneField그리고 다양한 커스텀 필드들django-model-utils: https://django-model-utils.readthedocs.io/en/latest/모델필드들은 db 필드타입을 반영DB에서 지원하는 필드들을 반영Varchar 필드타입 → CharField, SlugField, URLField, EmailField파이썬 데이터타입과 데이터베이스 데이터타입을 매핑AutoField → intBinaryField → bytesBooleanField → boolCharField/SlugField/URLField/EmailField → strCharField/SlugField/URLField/EmailField의 경우처럼 다 str인 경우더라도, 디폴트로 적용된 유효성 검사 등의 차이가 생긴다.예를 들어서 CharField 같은 경우에는 지정한 길이로 str을 받기만 한다면, URLField는 str이면서 + URL 형식이어야지만 저장이 된다. 마찬가지로 EmailField도 이메일 형식이어야지만 저장이 된다.같은 모델필드라 할지라도 DB에 따라서 다른 타입이 될 수 도 있다.자주 쓰는 필드 공통 옵션blank, null, db_index, default, unique, choices, validators, verbose_name, help_textblack 같은 경우에는 Default가 False이다.그래서 message = models.TextField() 이런식으로 생성하고, message 값이 없이 저장한다면 모델과 연동된 django form 사용시 유효성 검사에서 실패한다. (Form을 사용하지 않고 Model만 사용해서 저장하면 유효성 검사가 수행되지 않음)하지만 그렇다고 해서, 무조건적으로 blank랑 null 같은 옵션을 True 설정하지 말 것 (django의 이점을 활용하지 못함)Model 예시설계한 데이터베이스 구조에 따라, 최대한 필드타입을 타이트하게 지정해주는 것이 입력값 오류를 막을 수 있음. blank null 지정 최소화 validators들이 다양하게 타이트하게 지정됨 필요하다면 validators들을 추가로 타이트하게 지정 프론트엔드에서의 유효성 검사는 사용자 편의를 위해서 수행하며, 백엔드에서의 유효성 검사는 필수 클라이언트에서 넘어오는 값은 누가 만들수도 있고 해서 백프로 신뢰하면 안됨. 그래서 백앤드 유효성 검사 필수 직접 유효성 로직을 만들지 말고 이미 잘 구성된 features들을 가져다 쓸 것. 장고의 Form/Model을 통해 지원되며, django-rest-framework의 Serializer를 통해서도 지원됨ORm은 SQL 쿼리를 만들어주는 역할일 뿐 성능 높은 애플리케이션을 위해서는 사용하려는 DB에 대한 깊은 이해가 필요" }, { "title": "Django 앱 생성방법", "url": "/posts/django_create_app/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-18 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 장고앱과 블로그 코딩쇼매번 템플릿 생성할 필요 없다.한번 앱으로 만들면 (프로젝트에서 따로 앱으로 격리해서 생성하는 형태) 만들어두면 다른 프로젝트에서도 재사용 가능앱 생성 방법manage.py가 있는 파일 경로에서 다음 명령어 입력python3 manage.py startapp 앱이름 (ex.blog)이는 장고 앱이 갖추어야 할 최소한의 파일들을 생성해준 것이다.urls.py 파일도 포함시키고자 한다면, 직접 이 이름으로 파일을 하나 만들어주면 된다.장고 앱의 목적: 재사용성 만약 재사용성을 목적으로 둔 것이 아니라면, 하나의 장고 앱에서 현재 프로젝트 거의 모든 기능을 구현해도 상관없다. 앱은 하나의 작은 서비스로 봐도 무방하다. 하나의 앱 이름은 현재 프로젝트 상에서 유일해야 함 단순히 서비스가 방대해진다고해서 분리하는것이 아니고, 재사용성에 초점을 두고 앱으로 분리하는 것 새롭게 생성한 장고앱이나 외부 라이브러리 형태의 장공배은 필히 settings.INSTALLED_APPS에 등록을 시켜주어야만 장고앱으로서 취급된다. 장고 프로젝트 폴더의 settings.py에 들어가서 INSTALLED_APPS에 추가해주면 됨 앱의 URLConfs를 제외한 많은 부분 (model,static)은 자동으로 설정됨" }, { "title": "Django admin을 통한 데이터 관리", "url": "/posts/django_admin/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-18 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 장고 admin을 통한 데이터 관리django admindjango.contrib.admin 앱을 통해서 제공됨 디폴트 경로: /admin/ 혹은 django-admin-honeypot앱을 통해 가짜 admin 페이지 노출 동일한 기능 제공. 단 이 방법 사용시 admin을 다른 경로로 변경해두고, /admin/을 honeypot가 mapping 하게 됨. 이 앱에서는 로그인 할 사람의 IP을 기록해두게 됨. 모델 클래스 등록을 통해서 조회/추가/수정/삭제 웹 ui를 제공함 서비스 초기에 데이터베이스 관리도구로 유용 관리도구 만들 시간 줄이고 End-User 서비스에 집중 할 수 있음내부적으로 django form 적극적으로 사용model을 만들어도 admin상에서 사용하기 위해서는 따로 등록하는 과정이 필요함!!!Admin에 Model Class 등록 방법model 등록은 한번만 됨이미 등록된 model에 한해서는 unregister해야만 새롭게 등록 가능등록법 #1admin.site.register(Item) #기본 ModelAdmin으로 동작아래와 같이 앱 디렉토리의 admin.py파일에 입력해주고 저장한다.그러면 아래와 같이 /instagram (등록한 앱 URL)로 가면 Model이 뜸등록법 #2class ItemAdmin(admin.ModelAdmin):\tpassadmin.site.register(Item,ItemAdmin) #지정한 ModelAdmin으로 동작등록법 #3@admin.register(Item)class ItemAdmin(admin.ModelAdmin):\tpass/str 표현JAVA의 toString처럼 파이썬에서도 어떤 객체에 대해서 문자열로 표현해야 하는 경우가 있음# Create your models here.class Post(models.Model): message = models.TextField() created_at = models.DateTimeField(auto_now_add=True) updated_at = models.DateTimeField(auto_now=True)\t\t#아래처럼 작성 def __str__(self): return f\"Post object ({self.id})\" #이 부분은 custom 가능그럼 Post를 만들 경우 다음과 같이 이름이 지정도미list display 표현보여줄 컬럼을 지정할 수 있음아래와 같이 list_display를 primary key로 지정한다면@admin.register(Post)class PostAdmin(admin.ModelAdmin): list_display = ['pk'] #pk는 primary key에 대한 별칭아래와 같이 뜸 (primary key인 id가 1이기 때문에 1)좀 더 explicit하게 표시할 컬럼들을 명시해주었을때의 결과@admin.register(Post)class PostAdmin(admin.ModelAdmin): list_display = ['id','message','created_at','updated_at'] #pk는 primary key에 대한 별칭list_display_linkslist_display 지정된 이름 중에, detail 링크를 걸 속성 리스트@admin.register(Post)class PostAdmin(admin.ModelAdmin): list_display = ['id','message','created_at','updated_at'] #pk는 primary key에 대한 별칭 list_display_links=['messages']Member Function 추가 (models.py에서)#instagram/admin.py@admin.register(Post)class PostAdmin(admin.ModelAdmin): list_display = ['id','message','message_length','created_at','updated_at'] #pk는 primary key에 대한 별칭 list_display_links=['messages']멤버 function 컬럼 이름 변경Member Function 추가 (admin.py에서)Search_fields 속성 정의admin내 검색 UI를 통해, DB를 통한 where 쿼리 대상 필드 리스트list_filter 속성 정의지정 필드값으로 필터링 옵션 제공" }, { "title": "BOJ 9237번 이장님 초대 파이썬", "url": "/posts/9237%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-18 00:00:00 +0900", "snippet": "문제농부 상근이는 마당에 심기 위한 나무 묘목 n개를 구입했다. 묘목 하나를 심는데 걸리는 시간은 1일이고, 상근이는 각 묘목이 다 자라는데 며칠이 걸리는지 정확하게 알고 있다.상근이는 마을 이장님을 초대해 자신이 심은 나무를 자랑하려고 한다. 이장님을 실망시키면 안되기 때문에, 모든 나무가 완전히 자란 이후에 이장님을 초대하려고 한다. 즉, 마지막 나무가 다 자란 다음날 이장님을 초대할 것이다.상근이는 나무를 심는 순서를 신중하게 골라 이장님을 최대한 빨리 초대하려고 한다. 이장님을 며칠에 초대할 수 있을까?입력입력은 두 줄로 이루어져 있다. 첫째 줄에는 묘목의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄에는 각 나무가 다 자라는데 며칠이 걸리는지를 나타낸 ti가 주어진다. (1 ≤ ti ≤ 1,000,000)출력첫째 줄에 며칠에 이장님을 초대할 수 있는지 출력한다. 답이 여러 가지인 경우에는 가장 작은 값을 출력한다. 묘목을 구입한 날이 1일이다.N = int(input())S = list(map(int,input().split()))S.sort(reverse=True)result = 0for i in range(N): result = max(result,S[i]+i)print(result+2)풀이 방식 배열을 역순으로 나열 (심는데 걸리는 시간은 똑같이 1일인데, 자르는 시간은 묘목마다 다르기 때문에, 가장 빨리 모두 다 심으려면 가장 늦게 걸리는 묘목부터 심어야 한다.) (한 묘목이 자라는 데 걸리는 시간 + 그 묘목을 심은 날)이 가장 큰 값이 곧 모든 묘목이 다 자라난 시간이다. 첫번째 예제의 경우 역순으로 심게 되면 4를 첫번째 날 심고 (4+0), 3을 두번째 날 심고 (3+1), 다른 3을 셋째날 심고 (3+2), 마지막으로 2를 (2+4)째날 심는다. 4번째날 심은 2 묘목이 6일째까지 자라고 이 6이 4,4,5보다 크기 때문에 정답이다. 묘목을 구입한 날이 1일이고, 이장님을 모든 묘목이 자란 다음날 초대하기 때문에 정답에 2를 더해준다." }, { "title": "BOJ 11719번 그대로 출력하기 2", "url": "/posts/11719%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 문자열", "date": "2022-04-18 00:00:00 +0900", "snippet": "문제입력 받은 대로 출력하는 프로그램을 작성하시오.입력입력이 주어진다. 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다. 각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 있다.출력입력받은 그대로 출력한다.while True: try: word = input() print(word) except EOFError: break매우 쉬운 문제지만 EOFError를 모르면 어떻게 종료할지 난감할 수 있기 때문에 기억하려고 작성출처: https://www.geeksforgeeks.org/handling-eoferror-exception-in-python/EOFError는 input()등 으로 입력을 받다가 End Of File condition, 즉 ‘데이터 소스로부터 더 이상 데이터를 못 읽는 상태’ 도달할 때 발생하는 에러이다." }, { "title": "BOJ 1051번 숫자 정사각형 파이썬", "url": "/posts/1051%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디, 브루트포스", "date": "2022-04-18 00:00:00 +0900", "snippet": "문제N×M크기의 직사각형이 있다. 각 칸에는 한 자리 숫자가 적혀 있다. 이 직사각형에서 꼭짓점에 쓰여 있는 수가 모두 같은 가장 큰 정사각형을 찾는 프로그램을 작성하시오. 이때, 정사각형은 행 또는 열에 평행해야 한다.입력첫째 줄에 N과 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 수가 주어진다.출력첫째 줄에 정답 정사각형의 크기를 출력한다.N,M = map(int,input().split())rect = [list(map(int,input())) for _ in range(N)]max_dist = 0max_result = 0for i in range(N): for j in range(M): V = rect[i][j] max_dist = 0 for k in range(min(N, M)): # 정사각형 범위를 벗어나면 break dist = abs(j - k) # 가장 멀리 떨어져있는 점을 구하기 위해서 max_dist 갱신 if V == rect[i][k]: max_dist = max(max_dist, dist) # 가장 큰 정사각형의 넓이를 구하기 위해서 max_result 갱신 if i+max_dist&lt;N and V == rect[i+max_dist][j] and V == rect[i+max_dist][k]: size = (max_dist+1)**2 max_result = max(max_result,size)print(max_result)N,M이 주어지는 범위가 작기 때문에 (N,M≤50) 브루트포스로 풀 수 있다.문제에서는 최대 크기의 정사각형을 요구하기 때문에 max로 갱신하면서 가장 큰 경우의 수를 골라야 한다.가로변에서 반복문을 돌다가 같은 숫자를 찾았다면, 양 수간의 거리를 인덱스 삼아서 바로 나머지 꼭지점에 접근할 수 있다.만약 그 거리의 꼭지점에 있는 숫자도 값이 같다면, 넓이를 구해서 최댓값과 비교해서 갱신해준다.주의할 점은 숫자 하나도 하나의 정사각형으로 취급하기 때문에 거리를 구하고 +1를 해주어야 한다." }, { "title": "Django 프로젝트 설치 및 기본 셋업", "url": "/posts/django_setup/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-17 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 4강 장고 프로젝트 생성장고 프로젝트 생성django-admin startproject 프로젝트명python -m django startproject 프로젝트명장고 프로젝트 내부 구조 (프로젝트 이름): 프로젝트로 생성된 디렉토리 (이름 변경 상관 x) manage.py: 명령행을 통해 각종 장고 명령을 수행 (프로젝트 이름): 프로젝트로 생성된 디렉토리 (이 이름을 참조하고 있는 코드가 몇 개 있어서 함부로 수정 x) init.py: 모든 파이썬 패키지에 있음. 패키지를 import할 때의 import 대상 settings.py: 현재 프로젝트에서 장고 기본설정(django/conf/global_settings.py)을 덮어쓰고 새롭게 지정할 설정들 urls.py: 최상위 URL 설정 wsgi.py: 실서비스에서의 웹서비스 진입점 프로젝트 초기화 작업 및 개발서버 구동cd 프로젝트명python3 manage.py migratepython3 mange.py createsuperuserpython3 manage.py runserverpython3 manage.py migrate 모델의 변경 내역을 DB 스키마에 적용시키는 장고의 방법 (아직 완벽하게 이해되지는 않았다. 현재는 git commit처럼 모델 스키마에 변경사항을 반영하는 것 정도로 이해하고 있다.) 실행을 하면 아래와 같은 출력결과가 뜨고 (Unknown command가 안떴다면 정상적으로 실행된 것), 디렉토리 안에 db.sqlite3가 생긴다.python3 manage.py createsuperuser 현재 프로젝트를 진행하는 개발 환경, 즉 장고내에서 모든 권한을 가지는 슈퍼 사용자를 만드는 것이다. 쉽게 말하면 관리자로, 장고 내의 admin 페이지에 들어가려면 꼭 만들어야 한다. 이름, 이메일 (선택), 비밀번호를 순서대로 입력해주면 되는데, 비밀번호를 8 글자 이내로 설정하면 아래와 같이 경고문구가 뜨고 너무 쉬운 비밀번호인데 그대로 만들것인지 묻는다. 지금은 연습이기 때문에 굳이 복잡한 비밀번호를 만들면 매 입력때마다 번거로울것같아서 그냥 그대로 만들었다. python3 manage.py runserver서버를 구동하는 명령어http://127.0.0.1:8000/ 즉 로컬 서버 8000포트에 서버가 구동된 것이다.맥에서는 option 버튼을 누른 상태에서 해당 링크를 클릭하면 아래와 같이 브라우저가 열린다.그리고 해당 주소 뒤에 /admin을 붙여서 들어가면 관리자 페이지로 진입한다.아까 만든 username과 password를 입력하고 들어가서, add 누르면 새로운 유저를 만들수도 있다.마치 AWS에서 IAM User를 만들고 권한을 부여하는 것처럼, 관한을 분산시켜서 사용할 수 도 있는 듯 하다." }, { "title": "Django 주요 구성 요소", "url": "/posts/django_elements/", "categories": "Django", "tags": "django, 인프런 강의", "date": "2022-04-17 00:00:00 +0900", "snippet": "인프런 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트 강의를 보고 정리한 내용입니다.Django 주요 구성 요소강의 내용 정리강의명 : 파이썬/장고 웹서비스 개발 완벽 가이드 with 리액트강의: 6강 장고 주요 구성 요소장고 주요 기능들 (1) Function Based Views: 함수로 HTTP 요청 처리 Models: 데이터베이스와의 인터페이스 (ORM) Templates: 복잡한 문자열 조합을 보다 용이하게 할 수 있도록 도와줌. 주로 HTML 문자열 조합 목적으로 사용하지만, 푸쉬 메시지나 이메일 내용을 만들 때에도 쓰면 편리함. Admin 기초: 심플한 데이터베이스 레코드 관리 UI 관리자 페이지를 따로 만들지 않아도 자동적으로 생성됨. (데이터베이스 목적) Logging: 다양한 경로로 메세지 로깅 Static files: 개발 목적으로서의 정적인 파일 관리 Messages framework: 유저에게 1회성 메세지 노출 목적 장고 주요 기능들 (2) Class Based Views: 클래스로 함수 기반 뷰 만들기 Forms: 입력폼 생성, 입력값 유효성 검사 및 DB로의 저장 테스팅 국제화 &amp; 지역화 Caching Redis 등 Geographic DB의 Geo 기능 활용 (PostgreSQL 중심) 요즘은 mySQL Geo 기능도 좋아짐. 이메일 기능 Syndication Feeds (Rss/Atom) Sitemaps장고 기본 앱앱이란 장고가 규정해놓은 하나의 파이썬 패키지라고 보면 됨admin, admindocs, auth, contenttypes, flatpages, gis, humanize, messages, postgres, redirects, sessions, sitemaps, sites, staticfiles, sydication웹 애플리케이션 기본 구조웹 브라우저↔  다양한 언어나 프레임워크로 만드는 웹 서버 (여기선 django)↔  DB 서버 (MySQL, PostgreSQL 등)↔  캐시 서버 (Memcached, Redis)다양한 언어나 프레임워크로 만드는 웹 서버 (여기선 django) 단계의 내부를 살펴보자면클라이언트로부터 요청이 들어오면 아래와 같은 과정을 수행할 수 있음 URLConf 미리 URL별로 호출할 함수를 리스트에 등록 뷰 (View) URL에 맞춰 호출된 함수 모델 파이썬 코드로 데이터베이스와 통신 템플릿 엔진 복잡한 문자열을 손쉽게 조합하기 위한 문자열 렌더링 엔진 Flask나 github 블로그 관리할 때 {\\% 어쩌구 저쩌구 \\%} 이런 문법을 많이 봤었는데, 이런 문법으로 쉽게 템플릿 (그러니까 문자열들)을 관리해주는 엔진인 것 같다. " }, { "title": "BOJ 2193번 이친수 파이썬", "url": "/posts/2193%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-04-17 00:00:00 +0900", "snippet": "문제0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다. 이친수는 0으로 시작하지 않는다. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다.출력첫째 줄에 N자리 이친수의 개수를 출력한다.DP 특징이 초반 답을 이후에 응용해서 사용한다그래서 패턴을 찾으려면, 초반에 3-4개 정도의 답을 구해봐야 한다조건을 살펴보자 이친수는 0으로 시작하지 않는다. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다. 우선 1번째 조건에 따르면 0으로 시작하지 않기 때문에 시작은 무조건 1이다.그리고 2번째 조건에 따르면 1이 두 번 연속으로 나타나지 않기에, N=1일때는 1, 그 외의 답은 무조건 10으로 시작한다.답을 1부터 5까지 구해보면 다음과 같다. N=1: 1 N=2: 10 N=3: 100, 101 N=4: 1000, 1001, 1010 N=5: 10000,10001,10010,10100,10101N=4일 때는 10 뒤에 값에, N=2 (N-2) 일때의 1 뒤에 숫자들, N=3일때의 1 뒤에 숫자들을 갖고 왔다. N=2: -10 N=3: 1-00, 1-01 N=4: 10-00, 10-01, 10-10N=5일 때는 10 뒤에 값에, N=3 (N-2) 일때의 숫자들, N=4 (N-1)일때의 1 뒤에 숫자들을 갖고 왔다. N=3: -100, -101 N=4: 1-000, 1-001, 1-010 N=5: 10-000,10-001,10-010,10-100,10-101그래서 이 규칙에 따르면 n의 이친수 개수는 n - 2의 이친수 개수 + n - 1의 이친수 개수임을 알 수 있다." }, { "title": "BOJ 1826번 연료 채우기 파이썬", "url": "/posts/1826%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디, 우선순위 큐", "date": "2022-04-17 00:00:00 +0900", "snippet": "문제성경이는 트럭을 정글 속에서 운전하다가 트럭의 연료탱크에 갑자기 구멍이 나서 1km를 가는데 1L의 연료가 새 나가게 되었다. 이것을 고치기 위해서는 가장 가까운 마을에 가야 한다. 그런데 그냥 가다가는 중간에 연료가 다 빠질 수가 있다. 다행스럽게도 정글 곳곳에 연료를 채울 수 있는 주유소가 N개 있다. 그런데 정글 속에서 중간에 차를 멈추는 행위는 매우 위험한 행위이므로 주유소에서 멈추는 횟수를 최소화 하려 한다.그리고 다행이도 성경이의 트럭은 매우 좋아서 연료 탱크에는 연료의 제한이 없이 많이 충분히 많이 넣을 수 있다고 한다. 각각의 주유소의 위치와, 각 주유소에서 얻을 수 있는 연료의 양이 주어져 있을 때, 주유소에서 멈추는 횟수를 구하는 프로그램을 작성하시오.정글은 일직선이고, 성경이의 트럭과 주유소도 모두 일직선 위에 있다. 주유소는 모두 성경이의 트럭을 기준으로 오른쪽에 있다.입력첫째 줄에 주유소의 개수 N(1 ≤ N ≤ 10,000)가 주어지고 두 번째 줄부터 N+1번째 줄 까지 주유소의 정보가 주어진다. 주유소의 정보는 두개의 정수 a,b로 이루어 져 있는데 a(1 ≤ a ≤ 1,000,000)는 성경이의 시작 위치에서 주유소 까지의 거리, 그리고 b(1 ≤ b ≤ 100)는 그 주유소에서 채울 수 있는 연료의 양을 의미한다. 그리고 N+2번째 줄에는 두 정수 L과 P가 주어지는데 L(1 ≤ L ≤ 1,000,000)은 성경이의 위치에서 마을까지의 거리, (1 ≤ P ≤ 1,000,000)는 트럭에 원래 있던 연료의 양을 의미한다.출력첫째 줄에 주유소에서 멈추는 횟수를 출력한다. 만약 마을에 도착하지 못할경우 -1을 출력한다.import heapqn = int(input())gs = []#최소힙for _ in range(n): dist,f = map(int,input().split()) heapq.heappush(gs,[dist,f])#최대힙target,fuel = map(int,input().split())filled = []cnt = 0#종료조건: 종점과 fuel이 같아지거나 fuel이 더 커졌을 때while target&gt;fuel:\t\t#현재 fuel로 갈 수 있는 거리의 gas들을 최소힙에서 빼내서 전부 move라는 최대힙에 넣음 while gs and gs[0][0]&lt;=fuel: dist, f = heapq.heappop(gs)\t\t\t\t# -1을 곱해주어서 최대힙으로 사용\t\t\t\t# 최대힙에 넣는 이유는 문제에서 주유소에서 멈추는 횟수를 최소화하라고 하기 때문에, 가능한한\t\t\t\t#\t기름을 많이 채울 수 있는 주유소에서 채우기 위함 heapq.heappush(filled,-1*f) #주유소에서 기름을 다 채웠거나, 아니면 주유소는 남았는데 현재 fuel로 해당 주유소들에 도달할 수\t\t#없을 경우에는 종점까지 못 가므로 -1을 print하고 종료 if not filled: cnt = -1 break #최대힙에서 빼낸 기름을 현재 fuel에 더해주고, 주유소에 멈췄으므로 count f = heapq.heappop(filled) fuel += -1*f cnt+=1print(cnt)접근방식은 맞게 떠올렸는데도 쉽게 구현하지 못했다.우선순위 큐가 머릿속에 떠오르니 않아서, 이를 사용하지 않고 풀려니 구현이 복잡해졌었다.구글링 해서 다른 사람들이 푼 해설을 보고, 이해해서 다시 내 코드로 구현해봤다.개념을 이해하고 쉬운 문제 사용해보는 것을 넘어서, 다양한 케이스에 적용하는법을 경험해보고 익숙해져야할것같다." }, { "title": "BOJ 14916번 거스름돈 파이썬", "url": "/posts/14916%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-04-17 00:00:00 +0900", "snippet": "문제춘향이는 편의점 카운터에서 일한다.손님이 2원짜리와 5원짜리로만 거스름돈을 달라고 한다. 2원짜리 동전과 5원짜리 동전은 무한정 많이 가지고 있다. 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈이 n인 경우, 최소 동전의 개수가 몇 개인지 알려주는 프로그램을 작성하시오.예를 들어, 거스름돈이 15원이면 5원짜리 3개를, 거스름돈이 14원이면 5원짜리 2개와 2원짜리 2개로 총 4개를, 거스름돈이 13원이면 5원짜리 1개와 2원짜리 4개로 총 5개를 주어야 동전의 개수가 최소가 된다.입력첫째 줄에 거스름돈 액수 n(1 ≤ n ≤ 100,000)이 주어진다.출력거스름돈 동전의 최소 개수를 출력한다. 만약 거슬러 줄 수 없으면 -1을 출력한다.n이 9인 경우까지 답을 뽑아보고, n이 홀수면 n-1의 값 -1이고, 짝수면 n-1의 값 +2 인줄 알았는데 아니었다.n이 10을 넘어서면부터 n-1의 답 +2가 답이 아니게 되기 때문이다. (5원을 2개주면 되기 때문에)그래서 10을 넘어서 계속 계산해보다가, 생각해보니 2원이랑 5원으로만 계산해줄 수 있으니, n&gt;10이라면 n-2값 의 답 +1이 답이고, n≥10일때는 n-5의 값 +1 이 답이라는 결론에 도달했다. 1: -12: 13: -14: 25: 16: 37: 28: 49: 310 이후부터가 분기점 10:211:412:313:514:415:3n = int(input())dp = [0,-1,1,-1, 2 ,1]if n &lt; 6: print(dp[n])else: for i in range(6,n+1): if i &lt; 10: dp.append(dp[i-2]+1) else: dp.append(dp[i-5]+1) print(dp[n])" }, { "title": "BOJ 2720번 세탁소 사장 동혁 파이썬", "url": "/posts/2720%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-16 00:00:00 +0900", "snippet": "간단한 브론즈 문제인데 부동소수점 타입 계산할 때 생기는 오차 때문에 꽤 시간을 소용했다.문제미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.동혁이는 리암에게 실망했다.리암은 거스름돈을 주는 것을 자꾸 실수한다.심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다!어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500)출력각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.리암이 줘야할 동전 (쿼터, 다임, 니켈, 페니)은 float인것에 비해, 주어지는 거스름돈 C는 정수이고, 달러가 아닌 센트로 주어진다.문제에서 나와있듯이 1달러는 100센트이기 때문에, 거스름돈 C를 입력받고 이 값에 100으로 나눠서 계산하려고 했다.근데 나와야 할 예제출력에서 마지막 4가 계속 3으로 찍혔다. 4 2 0 4 3 1 0 0 0 7 1 1 4 3그래서 중간 중간에 print를 해보니 큰 돈부터 거슬러주다가 0.4가 남아야할 때 0.3999999.. 같은 값이 들어가 있었다.알고보니 float의 부동소수점 오차 문제였다.컴퓨터는 2진 분수로 표현하기 때문에 사람이 이해하기 쉬운 10진수를 표현할 때, 비록 정확하지는 않더라도 근사값을 얻어서 보여준다. 이는 해당 숫자에 매우 가깝지만 정확히 동일하지는 않다.예를 들어 10진수인 0.1을 표현할 때 실제로는 0.1000000000000000055511151231257827021181583404541015625이지만 이렇게 곧이곧대로 표현하기보다는 파이썬은 10진수 근삿값을 표시한다.따라서 0.4가 나와야했을 때 0.399999 뭐 대충 이런 값이 뜬 것이다.해결 방법으로는 애초에 쿼터, 다임, 니켈, 페니를 100을 곱한 값으로 갖고 있던지 (어차피 입력값인 거스름돈도 센트로 입력되기 때문에) 아니면 Decimal을 import해서 사용해주는 방법이 있다.후자 방법을 사용할 때 주의할 점은 Decimal() 안에 인자를 넣을 때 str 타입을 넣어주어야 한다.동전값을 처음부터 float이 아닌 int로 받는 방법T = int(input())cng =[25,10,5,1]for _ in range(T): C = int(input()) for i in range(len(cng)): num = C // cng[i] print(num, end=' ') C -= num * cng[i] print()동전값을 float으로 받되 Decimal을 이용해서 부동소수점을 정확하게 표기해주는 방법from decimal import DecimalT = int(input())C = [0.25,0.10,0.05,0.01]for _ in range(T): total = int(input()) total /=100 for i in range(len(C)): coin = Decimal(str(C[i])) change = Decimal(str(total)) // coin print(change, end=' ') total = Decimal(str(total)) - change * coin print()위에꺼가 Decimal을 사용한것, 밑에꺼가 int로 계산한 것" }, { "title": "BOJ 17521번 Byte Coin 파이썬", "url": "/posts/17521%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-16 00:00:00 +0900", "snippet": "문제국제자본부동산회사(ICPC)는 바이트 코인(Byte Coin)에 자금을 투자하고 있다. 바이트 코인은 김박사가 만든 가상 화폐이다. 실제로는 바이트 코인 가격을 예상할 수 없지만 이 문제에서는 바이트 코인 가격 등락을 미리 정확히 예측할 수 있다고 가정하자.우리는 1일부터 n일까지 n일 동안 그림 1과 같이 바이트 코인의 등락을 미리 알 수 있으며 우리에게는 초기 현금 W가 주어져 있다. 그림 1의 빨간색 네모는 해당 일자의 바이트 코인 가격을 나타낸다. 매일 바이트 코인을 매수하거나 매도할 수 있다고 하자. 다만 바이트 코인 하나를 나누어 매도하거나 매수할 수는 없다. 우리는 n일 날 보유하고 있는 모든 코인을 매도할 때 가지고 있는 현금을 최대화하고 싶다.그림 1. 10 일간 바이트 코인 가격 등락 그래프예를 들어, 그림 1과 같은 바이트 코인 등락 그래프를 첫날 미리 알 수 있다고 하고 우리에게 주어진 초기 현금이 24라고 하자. 수익을 최대한 높이려면 다음과 같이 바이트 코인을 매수, 매도할 수 있다. 첫 날 현금 20을 써서 4개의 코인을 산다. 둘째 날 모든 코인을 매도해서 현금 28을 얻고 모두 32의 현금을 갖게 된다. 5일째 되는 날 현금 32를 써서 16개의 코인을 매수한다. 7일째 되는 날 모든 코인을 매도해서 모두 128의 현금을 갖게 된다. 9일째 되는 날 현금 126을 써서 42개의 코인을 사고 10일 날 모든 코인을 매도한다. 그러면 10일 날 현금이 170이 되고 이것이 최대이다.요일 수 n, 초기 현금 W, 1일부터 n일까지 각 요일의 바이트 코인 가격이 주어질 때, n일 날 보유하고 있는 모든 코인을 매도할 때 보유하게 될 최종 현금의 최댓값을 출력하는 프로그램을 작성하시오.입력입력은 표준입력을 사용한다. 첫 번째 줄에 요일 수를 나타내는 양의 정수 n과 초기 현금 W(1 ≤ n ≤ 15, 1 ≤ W ≤ 100,000)가 주어진다. 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는 정수 si가 주어진다(1 ≤ si ≤ 50).출력출력은 표준출력을 사용한다. n일 날 보유하고 있는 모든 코인을 매도할 때 가지고 있는 현금의 최댓값을 한 행에 출력한다. 비록 초기 현금 W는 그렇게 크지 않지만 최종 현금은 매우 커질 수 있음에 주의하자.N,W = map(int,input().split())S = [int(input()) for _ in range(N)]maxv= max(S)buy_price = maxvcoin = 0for i in range(N-1): #다음꺼가 더 클 때 지금 가격에 구매 if S[i+1]&gt;S[i]: buy_price = min(buy_price,S[i]) coin = W // buy_price minus = buy_price * coin #다음께 작으면 판매 elif S[i+1]&lt;S[i] and coin != 0: #판매 #돈 차감 W += S[i]*coin-minus buy_price = maxv coin=0if coin!=0: W += S[-1]*coin-minusprint(W)다음날 가격이 더 비싸면 사고, 싸면 판다.근데 ‘내일이 오늘보다 더 싸면 오늘 가격에 구매’라는 로직을 세우면 최저가가 아닌 날에도 구매를 하게 되어서 min으로 비교해서 더 낮은 값을 넣어주었다.접근 방식은 머리에 있는데, 아직 코드로 표현하는 능력이 미숙해서 많은 시간을 소요했다.그리고 변수명은 뭉뜽그려 생각하고, 바로 코딩에 들어가니까 중간에 생각이 막히게 된다.더 세세하게 계획을 세우고 코딩을 시작할 필요성이 있을 것 같다." }, { "title": "TIL_Git branch", "url": "/posts/TIL4/", "categories": "TIL", "tags": "til, git, branch", "date": "2022-04-14 00:00:00 +0900", "snippet": "TIL: Git branchgit commit -a처음 만든 파일이나 디렉토리에 한해서는 git add를 먼저 해주어야 git commit -a를 사용할 수 있다.Branch Branch간 이동할 때 commit은 저장 개념이다. (혹은 stash) 특정 Branch (ex.master)에서 만들었던 파일을 다른 Branch에서 이름을 바꾸고서 다시 원래 Branch로 돌아온다면 이름을 바꾸기 전 파일과 바꾼 후의 파일 총 2개가 있게 된다." }, { "title": "BOJ 14659번 한조서열정리하고옴ㅋㅋ 파이썬", "url": "/posts/14659%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-13 00:00:00 +0900", "snippet": "문제“반갑다. 내 이름은 반고흐#31555! 조선 최고의 활잡이지. 오늘도 난 금강산 위에서 적들을 노리고 있지. 내 앞에 있는 적들이라면 누구도 놓치지 않아! 좋아, 이제 곧 월식이 시작되는군. 월식이 시작되면 용이 적들을 집어삼킬 것이다. 잘 봐두어라! 마장동 활잡이 반고흐#31555님의 실력을-!”반고흐#31555는 자기 뒤쪽 봉우리에 덩기#3958이 있음을 전혀 모르고 있었다. 덩기#3958도 반고흐#31555와 마찬가지로 월식이 시작되면 용을 불러내어 눈앞에 있는 다른 활잡이들을 모두 처치할 생각이다. 사실, 반고흐#31555와 덩기#3958 뿐만 아니라 금강 산맥의 N개 봉우리에 있는 모든 활잡이들이 같은 생각을 가지고 있다.반고흐#31555가 있는 금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다. 다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다. 또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다. 봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며, 중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다.“달에 마구니가 끼었구나.”드디어 월식이 시작됐다! 과연 이들 활잡이 중 최고의 활잡이는 누구일까? 최고의 활잡이가 최대 몇 명의 적을 처치할 수 있는지 알아보자.입력첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000) 둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000) 각각 봉우리의 높이는 중복 없이 유일하다.출력최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다.N = int(input())S = list(map(int,input().split()))result = 0start= 0while True: if start &gt;= N-1: break end = start+1 cnt = 0 while end &lt;= N-1: if S[start] &gt; S[end]: cnt+=1 end+=1 continue else: start = end break result = max(result,cnt) if end &gt;= N-1: start=endprint(result)풀이방식무턱대고 중첩 반복문 (O(N^2))로 전부 비교하려 한다면 시간초과가 나게 된다.어떤 부분이 다시 볼 필요가 없는 부분인지 파악해야 한다.예제 (6,4,10,2,5,7,11)를 살펴보자면, 처음에 6에서 반복문을 시작해서 6보다 큰 10을 만나고 반복문이 끝났다면, 그 다음은 4가 아닌 10에서 시작해야 한다.4는 이미 6 (이전 인덱스)과 10 (다음 인덱스)보다 모두 작다는 사실을 이미 알게 되었기 때문이다.따라서, start랑 end를 인덱스로 두고 만약 end가 start보다 작다면 cnt를 1 추가하고, end도 한 칸씩 뒤로 밀어준다.그러다가 더 큰 end를 만나면, 반복문에서 빠져나와서, start를 한 칸 뒤로 밀어주는게 아니라, end 위치를 start에 넣어주고 다시 반복한다." }, { "title": "EC2 인스턴스 유형 (각 유형 이름 의미)", "url": "/posts/ec2_types/", "categories": "AWS", "tags": "aws, elastic beanstalk", "date": "2022-04-11 00:00:00 +0900", "snippet": "현재 개발용으로 프리티어를 사용하고 있는데, 스펙을 업 시키기전에 유튜브에서 서칭해보던 중 유튜버‘AWS강의실’님의 영상들을 보게 되었는데 굉장히 이해하기 쉽게 잘 설명해주신다. 매우 추천.사진 출처: ‘AWS 강의실’https://www.youtube.com/watch?v=JM25Hls75b8&amp;ab_channel=AWS%EA%B0%95%EC%9D%98%EC%8B%A4인스턴스 유형현재 프리티어로 t2.micro를 사용하고 있는데, 어떤 기준으로 이러한 이름이 갖고 있는지 이해가 가지 않았었다. 유일하게 추측할 수 있었던 부분은 프리티어이니만큼 뒤에 ‘micro’라는 단어가 낮은 성능을 나타내는 것이라고만 생각했다.실제로 t2.micro는 RAM을 1GM 밖에 제공하지 않아서, 로컬에서 웹 어플리케이션을 돌리다가 배포한 후 돌리려해보면 굉장히 버벅거리거나 먹통이 되거나 했다.영상을 보고 알게 된 사실은, 맨 앞 철자는 어떤 성능에 특화된 유형인지를 나타내고, 그 다음 숫자는 세대, 그 다음은 architecture, 마지막은 사이즈 (클 수록 좋은 성능)를 나타낸다는 것." }, { "title": "BOJ 2012 등수 매기기 파이썬", "url": "/posts/2012%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-10 00:00:00 +0900", "snippet": "문제2007년 KOI에 N명의 학생들이 참가하였다. 경시일 전날인 예비소집일에, 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다.KOI 담당조교로 참가한 김진영 조교는 실수로 모든 학생의 프로그램을 날려 버렸다. 1등부터 N등까지 동석차 없이 등수를 매겨야 하는 김 조교는, 어쩔 수 없이 각 사람이 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다. 자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 ( A - B )로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다. 각 사람의 예상 등수가 주어졌을 때, 김 조교를 도와 이러한 불만도의 합을 최소로 하는 프로그램을 작성하시오.입력첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 500,000) 둘째 줄부터 N개의 줄에 걸쳐 각 사람의 예상 등수가 순서대로 주어진다. 예상 등수는 500,000 이하의 자연수이다.출력첫째 줄에 불만도의 합을 최소로 할 때, 그 불만도를 출력한다.import sysinput = sys.stdin.readlineN = int(input())prediction = [int(input()) for _ in range(N)]prediction.sort()result = 0for i in range(1,N+1): result += abs(prediction[i-1]-i)print(result)자신의 등수가 높다고 예상한 학생 순서대로 높은 점수를 주면 된다." }, { "title": "BOJ 21758번 꿀 따기 파이썬", "url": "/posts/21758%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-09 00:00:00 +0900", "snippet": "문제아래와 같이 좌우로 N개의 장소가 있다.장소들 중 서로 다른 두 곳을 골라서 벌을 한 마리씩 둔다. 또, 다른 한 장소를 골라서 벌통을 둔다. 아래 그림에서 연한 회색의 장소는 벌이 있는 장소이고 진한 회색의 장소는 벌통이 있는 장소이다.두 마리 벌은 벌통으로 똑바로 날아가면서 지나가는 모든 칸에서 꿀을 딴다. 각 장소에 적힌 숫자는 벌이 지나가면서 꿀을 딸 수 있는 양이다. 두 마리가 모두 지나간 장소에서는 두 마리 모두 표시된 양 만큼의 꿀을 딴다. (벌통이 있는 장소에서도 같다.) 벌이 시작한 장소에서는 어떤 벌도 꿀을 딸 수 없다.위의 그림과 같이 배치된 경우 두 마리의 벌 모두 4+1+4+9+9=27$4 + 1 + 4 + 9 + 9 = 27$의 꿀을 따서, 전체 꿀의 양은 54가 된다.위의 그림과 같이 배치된 경우 왼쪽 장소에서 출발한 벌은 9+4+4+9+9=35$9 + 4 + 4 + 9 + 9 = 35$의 꿀을 따고 오른쪽 장소에서 출발한 벌은 4+9+9=22$4 + 9 + 9 = 22$의 꿀을 따므로, 전체 꿀의 양은 57$57$이 된다.위의 그림과 같은 경우는 전체 꿀의 양이 31이 된다.장소들의 꿀 양을 입력으로 받아 벌들이 딸 수 있는 가능한 최대의 꿀의 양을 계산하는 프로그램을 작성하라.입력첫 번째 줄에 장소의 수 N$N$이 주어진다.다음 줄에 왼쪽부터 각 장소에서 꿀을 딸 수 있는 양이 공백 하나씩을 사이에 두고 주어진다.출력첫 번째 줄에 가능한 최대의 꿀의 양을 출력한다.제한 $3 \\le N \\le 100~000$3≤N≤100 000 각 장소의 꿀의 양은 $1$ 이상 $10~000$ 이하의 정수이다.110 00055점T = int(input())S = list(map(int,input().split()))#벌벌꿀#꿀벌벌#벌꿀벌maxv = 0#벌벌꿀for i in range(1,T): first = sum(S[1:])-S[i] second = sum(S[1+i:]) maxv = max(maxv,first+second)#꿀벌벌for i in range(1,T-1): first = sum(S[:-1])-S[i] second = sum(S[:i]) maxv = max(maxv,first+second)#벌꿀벌for i in range(1,T-1): first = sum(S[1:i+1]) second = sum(S[i:-1]) maxv = max(maxv,first+second)print(maxv)추측으로는 반복문안에서 매번 sum을 구하기 때문에, 중복된 계산으로 시간초과가 나는 것 같다.100점from copy import deepcopyN=int(input())H=list(map(int, input().split()))# 수열을 s에 그대로 카피한다S = deepcopy(H)result=0for i in range(1, N): S[i] += S[i-1]for i in range(1, N-1): # 오른쪽 #마지막값 (전체 누적값)에서 벌 위치 두개를 빼주고, #벌 한마리는 i이후부터 시작함으로 그 이전 값을 빼준것 result = max(result, 2*S[-1]-H[0]-H[i]-S[i])for i in range(1, N-1): # 왼쪽 #이번에는 두배를 하는게 아니라 따로 더해줘야 함 #첫번째 벌: S[-1]-H[-1]-H[i] #두번째 벌: S[i-1] result = max(result, S[-1]-H[-1]-H[i]+S[i-1])for i in range(1, N-1): # 중간 #i는 꿀의 위치이다. #첫번째벌은 꿀까지의 누적합에서 자기 위치를 빼준다. #두번째벌은 전체 누적합에서 꿀까지의 누적합을 빼주고 자기 위치를 뺴준다. result = max(result, S[i]-H[0] + S[-1]-S[i-1]-H[-1])print(result)풀이방식55점 풀이와는 다르게 누적합을 미리 구해두고 시작한다.기본 접근방식은 같은데, 경우의 수를 다음과 같이 3가지로 나눈다.벌 - 🐝벌통 - 🪣꿀은 안 그려지만 그려보면 🐝 🐝 🍯 🍯 🍯 🍯 🪣3 가지 경우의 수 🐝 🐝 🪣 🪣 🐝-🐝 🐝 🪣 🐝 🐝 🐝 🪣이 경우 🐝 한 마리는 첫번째 위치 고정, 🪣 은 마지막 위치 고정이다.다른 🐝 한 마리만 반복문에서 i로 위치를 바꾸어주면서 최댓값을 max로 갱신한다.💡 나머지 두 케이스도 마찬가지이지만, 벌은 벌통 방향으로만 이동하게 되고, 그렇게 되면 그 방향과 반대에 있는, 자신보다 이전 위치의 꿀은 따지 못한다.ex. 벌이 index 2이고 벌통이 index 5에 있으면, 벌은 index 0과 1의 꿀을 따지 못하고 5가 있는곳까지 오른쪽으로만 일방통행한다.그래서 벌통과 최대한 멀리 떨어져있는 곳에서 시작해서, 꿀을 최대한 많이 따는게 이득이다.하지만 나머지 벌 한 마리의 위치가 변수인데, 왜냐면 이 벌의 위치에 따라서그 위치의 꿀은 따지 못하게 된다.따라서 반복문으로 해당 벌의 위치를 변경해가면서 어떤 경우의 수로 최댓값이 나오는지 갱신해야 한다. 🪣 🐝-🐝이 경우 🐝 한 마리는 마지막 위치 고정, 🪣 은 첫번째 위치 고정이다.나머지 🐝 한 마리만 반복문에서 i로 위치를 바꾸어주면서 최댓값을 max로 갱신한다. 🐝 🪣 🐝이 경우 🐝 한 마리는 첫번째 위치 고정, 두번째 🐝은 마지막 위치 고정이다.🪣 만 반복문으로 위치를 바꾸어주면서 최댓값을 갱신한다. (이전 두 케이스와 달리 이번엔 벌이 아닌 꿀의 위치가 이동한다.)각 케이스 (반복문)가 끝날때마다도 최댓값을 갱신해준다.이렇게 되면 최댓값을 가질만한 모든 경우의 수를 다 살펴볼 수 있게 된다." }, { "title": "BOJ 1213번 팰린드롬 만들기", "url": "/posts/1213%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-09 00:00:00 +0900", "snippet": "문제임한수와 임문빈은 서로 사랑하는 사이이다.임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.입력첫째 줄에 임한수의 영어 이름이 있다. 알파벳 대문자로만 된 최대 50글자이다.출력첫째 줄에 문제의 정답을 출력한다. 만약 불가능할 때는 “I’m Sorry Hansoo”를 출력한다. 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.word = input()S = [0]*26# ord:알파벳을 넣으면 숫자# chr:숫자를 넣으면 알파벳for i in word: S[ord(i)-65] += 1odd_cnt = 0result = ''mid = ''for i,v in enumerate(S): if v == 0: continue #짝수 if v % 2 ==0: result += (chr(i+65)*(v//2)) #홀수 else: result += (chr(i+65)*(v//2)) mid = chr(i+65) odd_cnt+=1 #끝나는 조건 if odd_cnt &gt; 1: breakif odd_cnt &gt; 1: print (\"I'm Sorry Hansoo\")else: print(result+mid+result[::-1])풀이 방식 알파벳은 26개가 최대이므로 26 크기의 배열을 만들어두고, word를 반복문으로 돌면서 각 letter가 나타나는 횟수를 기록해준다. 값이 0이면 해당 알파벳이 아예 등장하지 않은것 값이 홀수이면 해당 알파벳이 홀수 횟수만큼 등장한 것 값이 짝수이면 해당 알파벳이 짝수 횟수만큼 등장한 것 만약 홀수인 알파벳이 1개보다 크면 펠린드롬을 만들 수 없기 때문에 바로 “I’m Sorry Hansoo”를 출력해준다. 아니라면, 최종적으로 result + mid+ result.reverse()를 출력해준다.result와 mid를 구하는 방법: result: 개수의 2를 나눈값을 answer에 붙인다. (2를 나눈 값을 붙이는 이유는, 나머지 반은 reverse해서 뒤에 붙일것이기 때문이다.) mid: 홀수인 알파벳이 있다면 중간에 들어갈 값으로 mid에 넣어둔다. " }, { "title": "BOJ 11479번 통나무 건너뛰기 파이썬", "url": "/posts/11497%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-09 00:00:00 +0900", "snippet": "문제남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다. 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 2-9 = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 5-9 = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다. 입력입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 Li가 주어진다. (1 ≤ Li ≤ 100,000)출력각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.T = int(input())for _ in range(T): N = int(input()) S = list(map(int,input().split())) S.sort() maxv=0 for i in range(N-2): maxv = max(maxv,abs(S[i]-S[i+2])) print(maxv)가장 인접한 수끼리 놓아야 차가 작게 나온다.그렇다고 오름차순으로 두면 안되는게 처음이랑 마지막은 이어져있어서. 이 둘을 인접하게 두면 안된다.따라서 최댓값을 중앙에 두고, 그 다음으로 큰 두 수를 최댓값의 양 옆 (두 수중 작은게 왼쪽, 큰게 오른쪽)으로 두는 행위를 반복해서 나온 수열을 대상으로 난이도를 계산해야 한다.계산할 때는, 반복문을 돌면서 인접한 두 수의 차를 구해서 max를 갱신해주면 된다.물론 원리는 위와 같지만, 실제로 수열을 만들어 줄 필요는 없다.어차피 수열을 만들고 나면, 각 숫자가 자신과 가장 인접한 두 수를 양 옆에 두게 되게 때문이다.그리고, 문제에서 나와있듯이 난이도는 최댓값으로 정해지기 때문에, 인접한 두 수중에서도 큰 수와의 차를 구하면 된다.즉, 오름차순이 된 상태에서 자신보다 +2인 인덱스와의 차를 구해서 max를 갱신해나가면 된다.(반복문의 range가 n-2인 이유는 +2인 인덱스와의 차를 구하는 것이기 때문에 저기까지만 해도 구하려는 경우의 수가 다 구해지기 때문이다.)" }, { "title": "BOJ 7795번 먹을 것인가 먹힐 것인가 파이썬", "url": "/posts/7795%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 투포인터", "date": "2022-04-08 00:00:00 +0900", "snippet": "문제심해에는 두 종류의 생명체 A와 B가 존재한다. A는 B를 먹는다. A는 자기보다 크기가 작은 먹이만 먹을 수 있다. 예를 들어, A의 크기가 {8, 1, 7, 3, 1}이고, B의 크기가 {3, 6, 1}인 경우에 A가 B를 먹을 수 있는 쌍의 개수는 7가지가 있다. 8-3, 8-6, 8-1, 7-3, 7-6, 7-1, 3-1.두 생명체 A와 B의 크기가 주어졌을 때, A의 크기가 B보다 큰 쌍이 몇 개나 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 A의 수 N과 B의 수 M이 주어진다. 둘째 줄에는 A의 크기가 모두 주어지며, 셋째 줄에는 B의 크기가 모두 주어진다. 크기는 양의 정수이다. (1 ≤ N, M ≤ 20,000)출력각 테스트 케이스마다, A가 B보다 큰 쌍의 개수를 출력한다.T = int(input())for i in range(T): N,M = map(int,input().split()) A = list(map(int,input().split())) B = list(map(int,input().split())) A.sort() B.sort() start = 0 count = 0 for j in range(N): while True: if start==M or A[j]&lt;=B[start]: count+=start break else: start+=1 print(count)풀이 방식핵심은 sort를 해서 A와 B를 오름차순으로 만드는 것이다.한번 오름차순이 되었다면, A의 특정 원소의 차례가 되었을 때, 처음부터 B랑 비교하는게 아니라, 자신보다 이전 index의 원소가 끝난 지점에서부터 시작하면 된다.왜나면 본인보다 이전 index의 원소보다는 자신이 더 크기 때문이다.실생활로 예를 들면 자신보다 키가 작은 친구가 어느 특정 집단에서 키가 제일 크다고 해보자.그럼 본인이 그 집단에 갔을 때 제일 큰 사람이 되는것은 그 사람들과 일일이 비교해보지 않고도 미리 알 수 있는 것과 같다.자신보다 작은 친구가 그 집단에서 짱을 먹었기 때문이다.이 포인트를 이용해서 풀면 된다." }, { "title": "BOJ 10816번 숫자 카드 2 파이썬", "url": "/posts/10816%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 이진탐색", "date": "2022-04-08 00:00:00 +0900", "snippet": "문제숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.출력첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.from collections import defaultdictN = int(input())A = list(map(int,input().split()))A.sort()A_dict=defaultdict(int)for i in A: A_dict[i]+=1M = int(input())B = list(map(int,input().split()))result = []def bs(target,start,end): if start&gt;end: print(0,end=' ') return mid = (start+end)//2 if target==A[mid]: print(A_dict[target],end=' ') return elif target&gt;A[mid]: return bs(target,mid+1,end) else: return bs(target,start,mid-1)for i in B: bs(i,0,len(B)-1)풀이방식중복된 숫자가 나온다는 점이 어려운 점이다.그렇다면, 직관적으로 떠오르는 방법은, 카드의 숫자를 배열의 index로 삼고, value는 카드의 등장 횟수로 처리하는 건데, 입력값의 범위가 꽤 크기 때문에 ( -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같음) 적용하기 어렵다. 배열은 미리 사이즈를 잡아두어야 하기 때문이다.그래서 떠오른 자료구조가 딕셔너리이다.위의 방법을 사용할 수 있으면서, 배열처럼 미리 크기를 지정해 줄 필요도 없다.이분탐색 자체는 카드 숫자가 담겨져있는 배열에서 돌리지만, target을 찾았다면 딕셔너리에서 값을 가져온다." }, { "title": "BOJ 17615번 볼 모으기 파이썬", "url": "/posts/17615%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 우선순위큐", "date": "2022-04-07 00:00:00 +0900", "snippet": "문제빨간색 볼과 파란색 볼이 &lt;그림 1&gt;에서 보인 것처럼 일직선상에 섞여 놓여 있을 때, 볼을 옮겨서 같은 색 볼끼리 인접하게 놓이도록 하려고 한다. 볼을 옮기는 규칙은 다음과 같다. 바로 옆에 다른 색깔의 볼이 있으면 그 볼을 모두 뛰어 넘어 옮길 수 있다. 즉, 빨간색 볼은 옆에 있는 파란색 볼 무더기를 한 번에 뛰어 넘어 옮길 수 있다. 유사하게, 파란색 볼은 옆에 있는 빨간색 볼 무더기를 한 번에 뛰어 넘어 옮길 수 있다. 옮길 수 있는 볼의 색깔은 한 가지이다. 즉, 빨간색 볼을 처음에 옮겼으면 다음에도 빨간색 볼만 옮길 수 있다. 유사하게, 파란색 볼을 처음에 옮겼으면 다음에도 파란색 볼만 옮길 수 있다.예를 들어, 처음에 볼이 &lt;그림 1&gt;에서 보인 것처럼 있을 때, 빨간 볼을 &lt;그림 2&gt;에서 보인 것처럼 옮긴 후, &lt;그림 3&gt;에서 보인 것처럼 옮긴다면 두 번 만에 같은 색끼리 모을 수 있다.반면에 파란색 볼을 선택하여 에서 보인 것처럼 옮기면(화살표에 있는 수는 옮기는 순서를 나타낸다) 네 번을 옮겨야 같은 색의 볼끼리 모을 수 있다일직선상에 놓여 있는 볼에 관한 정보가 주어질 때, 규칙에 따라 볼을 이동하여 같은 색끼리 모으되 최소 이동횟수를 찾는 프로그램을 작성하시오.입력첫 번째 줄에는 볼의 총 개수 N이 주어진다. (1 ≤ N ≤ 500,000) 다음 줄에는 볼의 색깔을 나타내는 문자 R(빨간색 볼) 또는 B(파란색 볼)가 공백 없이 주어진다. 문자열에는 R 또는 B 중 한 종류만 주어질 수도 있으며, 이 경우 답은 0이 된다.출력최소 이동횟수를 출력한다.N = int(input())S = input()# 빨간색 count 저장red = S.count('R')# 파란색 count 저장blue = N - red# 빨강, 파랑 중 더 개수가 적은 것 저장ans = min(red, blue)cnt = 0#반복문 돌면서, 연속적인 것 countfor i in range(N): if S[i] != S[0]: break cnt += 1# 만약에 연속 count한게 빨간색이었다면, 위의 답 vs &lt;전체 빨강 개수 - 앞에서부터 연속 빨강 개수&gt; 중 적은 것 저장if S[0] == 'R': ans = min(ans, red - cnt)# 만약에 연속 count한게 빨간색이었다면, 위의 답- &lt;전체 파랑 개수 - 앞에서부터 연속 파랑 개수&gt; 중 적은 것 저장else: ans = min(ans, blue - cnt)cnt = 0# 반복문 거꾸로 돌면서 끝에서 얼마나 연속되는지 저장for i in range(N-1, -1, -1): if S[i] != S[N - 1]: break cnt += 1#만약 연속 count했던게 빨강이었다면, 위의 값 vs &lt;전체 빨강 개수 - 뒤에서부터 연속 빨강 개수&gt;if S[N - 1] == 'R': ans = min(ans, red - cnt)#만약 연속 count했던게 파랑이었다면, 위의 값 vs &lt;전체 파랑 개수 - 뒤에서부터 연속 파랑 개수&gt;else: ans = min(ans, blue - cnt)print(ans)# 최소값을 구하기 위해서 계속해서 mid으로 답을 갱신해나간다.우선순위 &lt;둘 중 최소&gt;\\ -&gt; 빨강 개수 vs 파랑 개수 &lt;둘 중 최소&gt;\\ -&gt; 1번 vs “전체 빨강/파랑 개수 - 앞에서부터 세었을 때 연속된 빨강/파랑 개수” &lt;둘 중 최소&gt;\\ -&gt; 2번 vs “전체 빨강/파랑 개수 - 뒤에서부터 세었을 때 연속된 빨강/파랑 개수”전체 빨강/파랑 개수에서 앞/뒤에서 연속된 빨강/파랑 개수를 빼는 이유: 끝에서부터 연속되어 있다면 그 볼 무더기는 움직일 필요가 없는것들이고, 따로 떨어진것들만 무더기쪽으로 움직이면 되어서 이게 곧 횟수를 의미" }, { "title": "BOJ 10989번 수 정렬하기3 파이썬", "url": "/posts/10989%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 정렬", "date": "2022-04-07 00:00:00 +0900", "snippet": "문제N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.입력첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.출력첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.풀이 방식수 정렬하기 2에서는 nlogn의 속도를 가진 Heap 정렬을 사용했었지만, 수 정렬하기 3에서도 똑같이 적용하면 메모리 초과가 난다.수 정렬하기 2는 메모리 제한이 256MB이었던것에 비해, 3에서는 8MB밖에 주어지지 않기 때문.위 사진을 참고해보면, 사이즈가 10,000,000인 배열은 무려 40MB의 메모리나 사용한다는 것을 알 수 있다.이 문제의 핵심은 “이 수는 10,000보다 작거나 같은 자연수이다.”이다.즉, 어차피 입력받는 숫자는 10,000 이하이기 때문에, 10,000 사이즈의 배열을 만들어두고,배열의 ‘값’을 배열 ‘인덱스’(특정 숫자)의 등장횟수로 생각해서 숫자를 입력받을때마다, 해당 인덱스의 값을 +1 해주면 된다.그리고 범위 제한 한정 log(N)의 속도를 가진 매우 빠른 알고리즘인 계수 정렬 (Counting Sort)를 사용해서 문제를 풀어주면 된다.import sysinput = sys.stdin.readlinen = int(input())arr = [0]*10001for _ in range(n): v = int(input()) arr[v]+=1for i,v in enumerate(arr): for j in range(v): print(i)" }, { "title": "BOJ 14501 퇴사 파이썬", "url": "/posts/14501%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-04-06 00:00:00 +0900", "snippet": "문제상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.N = 7인 경우에 다음과 같은 상담 일정표를 보자.1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.입력첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)출력첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.재귀N = int(input())timeTable = [list(map(int, input().split())) for _ in range(N)]def solve(i): if i&gt;=N: return 0 ret = 0 if i+timeTable[i][0]&lt;=N : ret = solve(i+timeTable[i][0])+timeTable[i][1] ret = max(ret,solve(i+1)) return retprint(solve(0))DP (재귀보다 4ms 빠름)#재귀N = int(input())TP = [list(map(int, input().split())) for _ in range(N)]dp = [0 for _ in range(N+1)]for i in range(N-1,-1,-1): if i+TP[i][0]&gt;N: dp[i] = dp[i+1] else: dp[i] = max (dp[i+1],dp[i+TP[i][0]]+TP[i][1])print(dp[0])재귀적인 풀이방식은 접근이 직관적이서 풀 수 있었으나, DP는 이해하는데 엄청 오래 걸렸다.일단 뒤에서부터 접근해야 한다는 점이 이해가 가지 않았지만, 그 이유는 점화식을 세우면서 알게 된다.우선, 특정 상담으로부터 ‘보수를 받을 수 있느냐 없느냐’는 다음의 경우만 고려하면 된다. 상담 소요 시간이 퇴사날을 넘어서는지 않는지 (넘어서지 않아야만 받을 수 있음)하지만, 문제에서는 백준이가 얻을 수 있는 최대 이익을 요구하는 것이기 때문에, 단순히 받을 수 있느냐 없느냐를 넘어서, 언제 받을거고 언제 받지 않을건가를 판단해야 한다.변수 설명TP TP의 [i][0]은 해당 상담의 소요시간이고, [i][1]은 해당 상담의 보수이다.DP DP의 각 원소는 해당 날짜 (index)에서부터 퇴사날까지 받을 수 있는 최대 이익이다. DP 배열의 사이즈를 N이 아닌 N+1 사이즈로 만들어준다. 이유: 뒤에서부터 접근할것이라면, index가 N-1로 시작할 때 list index out of range가 나지 않고 dp[i+1]을 참조할 수 있기 위해서 N+1일은 퇴사일을 넘기 때문에, 이 날부터 퇴사일까지 받을 수 있는 최대 보수는 0이다. (dp[N+1]) 반복문을 돌 때, 매번 두 가지 선택권이 주어진다. 그 날 일을 안하고 건너뛰는 것 이 경우 ,그 날의 보수인 (TP[i][1])를 챙기지 못함 대신, 그 날 일을 안했다고해서 dp[i]에 0을 넣는것이 아니라, 이전까지 일해서 받을 수 있던 최댓값인 dp[i+1] 넣어야 함 (즉, 현상유지를 함) 그 날 일을 하는 것 그 날의 보수 (TP[i][1]) + 그 날로부터 상담 시간 이후로 넘어간 날에서 가질 수 있는 최대 보수를 dp[i+TP[i][0]]을 더해주는 것 따라서, 두 경우의 수 중 최댓값으로 DP 원소를 갱신해나가면 되는데, 이를 점화식을 세워보면 다음과 같다. dp[i] = max(dp[i+1], TP[i][1]+ dp[i+TP[i+0]])마지막 상담 → 첫 상담, 이렇게 거꾸로 접근하는 이유는 아직 정해지지 않은 뒤 index의 DP값을 참조해야 하는데 이는 아직 정해지지 않았기 때문이다.반면, 마지막 상담부터 이를 정해나가면 미리 참조할 수 있게 된다. 상담 소요 시간이 퇴사일을 넘어서서 0이거나 그 날의 보수를 챙기거나 (마지막 상담이기 때문에 그 날로부터 상담 시간 이후는 고려할 필요 없음)사진 출처: https://pacific-ocean.tistory.com/199사실 이렇게 정리를 해놓고도, 100% 맞게 이해한 게 맞는지 의문이 든다…혹시 틀린 점이 있다면, 지적해주시면 감사하곘습니다." }, { "title": "BOJ 1449번 수리공 항승 파이썬", "url": "/posts/1449%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-05 00:00:00 +0900", "snippet": "문제항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.항승이는 길이가 L인 테이프를 무한개 가지고 있다.항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.입력첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.출력첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.N, L = map(int,input().split())S = list(map(int,input().split()))S.sort()count = 1start = S[0]-1end = start+Lfor i in range(1,N): if S[i]&lt;=end: continue else: count+=1 start = S[i]-1 end = start+Lprint(count)접근방식좌우로 0.5cm를 막아야 한다는 말을 계산 편의상 다르게 생각하면, 한 출발지에서 1cm 떨어진곳에서부터 붙이면 된다는 말이다 (-1cm인곳에서 부터 붙이기 위해서, 배열을 오름차순으로 정렬해야 한다.)즉, 1부터 2까지 붙이려고 한다면 0부터 2까지 붙여야 한다고 생각하면 되고, 이때 0부터 2까지의 걸이가 L (테이프의 길이) 보다 같거나 작으면 붙일 수 있고, 아니라면 붙이지 못한다.오름차순으로 정렬된 파이프 위치가 주어졌을 때, 앞에서부터 차례차례 테이프를 붙이면 최소한으로 테이프를 사용할 수 있다고 접근하기 때문에 그리디 알고리즘이다.풀이방식테이프를 처음 붙인 start부터 최대 커버할 수 있는 end가 어디인지 미리 구간을 구해놓는다.반복문을 돌면서 start &lt; i &lt; end라면 테이프를 새로 뜯지 말고 continue하고, 그 구간을 벗어난다면 테이프를 새로 뜯는다. (start와 end를 재계산)" }, { "title": "BOJ 11279번 최대 힙 파이썬", "url": "/posts/11279%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 우선순위큐", "date": "2022-04-05 00:00:00 +0900", "snippet": "11279번 최대 힙 파이썬문제널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오. 배열에 자연수 x를 넣는다. 배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.입력첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.출력입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.import heapqimport sysinput = sys.stdin.readlineN = int(input())arr = []cnt = 0for _ in range(N): v = int(input()) if v == 0: if not arr: print(0) else: print(heapq.heappop(arr)*(-1)) else: heapq.heappush(arr,-(v))우선순위 큐 개념을 익히고 처음 푼 문제이다.Max Heap이기 때문에 heappop을 할 때 -1을 곱해주었다.그리고 지금까지 sys.stdin.readline를 안해줬다고 해서 시간초과 났던 문제는 못풀어봤었는데, 이 문제는 써주어야 시간초과가 나지 않는다." }, { "title": "BOJ 1920번 수 찾기 파이썬", "url": "/posts/1920%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 수학, 이진탐색", "date": "2022-04-04 00:00:00 +0900", "snippet": "문제N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.입력첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.출력M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.import syssys.setrecursionlimit = 10000000N = int(input())n_arr = list(map(int,input().split()))n_arr.sort()M = int(input())m_arr = list(map(int,input().split()))def binary_search(target,start,end): if start&gt;end: return False mid = (start+end)//2 if target==n_arr[mid]: return True elif target&gt;n_arr[mid]: return binary_search(target,mid+1,end) elif target&lt;n_arr[mid]: return binary_search(target,start,mid-1)for i in m_arr: if binary_search(i,0,N-1): print(1) else: print(0)틀렸던 이유:M의 원소가 N에 있는지 확인하는것이기 때문에, binary_search를 시작할 때 end index로 N의 끝 index를 주어야 하는데 M의 끝 index를 주어서 틀렸었다." }, { "title": "BOJ 1654번 랜선 자르기 파이썬", "url": "/posts/1654%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 수학, 이진탐색", "date": "2022-04-04 00:00:00 +0900", "snippet": "문제집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.입력첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.출력첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.이진탐색을 사용하지 않아서 시간초과 나는 코드K, N = map(int,input().split())lines = [int(input()) for _ in range(K)]lines.sort()maxv = 0for i in range(max(lines),0,-1): #자르는 길이: 457부터 1씩 감소됨 # print(i) count = 0 for j in lines: #갖고 있는 랜선 cut_line = j//i #2 count+=cut_line if count &lt; N: continue else: maxv=max(maxv,i)print(maxv)이분탐색을 사용한 코드import syssys.setrecursionlimit(1000001)K, N = map(int,input().split())lines = [int(input()) for _ in range(K)]lines.sort()maxLength = 0def bs(target,start,end): global maxLength count = 0 mid = (start+end)//2 if start&gt;end: return None for i in lines: count+=i//mid if count&gt;=target: maxLength = max(maxLength,mid) return bs(target,mid+1,end) elif count&lt;target: return bs(target,start,mid-1)result = bs(N,1,max(lines))print(maxLength)주의할 점:착각했던 부분: 갖고 있는 K개의 랜선에서 각각 잘라야 한다고 생각했어서, 값이 갖고 있는 랜선의 최소 길이 미만이 될 수 없다고 생각했었는데, 실은 N개를 만들 수 만 있다면 꼭 각각의 랜선에서 자를 필요가 없다. 예를 들어 5cm만큼 자르려고 하는데, 이미 갖고 있던 4cm의 랜선이 있다고 해서 5cm만큼 못 자르는 것이 아니다. 그냥 4cm 랜선은 사용하지 않으면 된다.ZeroDivisionError: 갖고있는 K개의 랜선의 최대 길이가 1일 경우, start를 0으로 주면 mid가 0이 되어서, 0으로 나누려고 할 때 호출되는 에러인 ZeroDivisionError가 발생한다.N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다: 문제에서 나와있듯, N보다 많이 만드는것도 N개를 만드는 것에 포함되기 때문에 투포인트 재귀 조건으로 mid와 값이 같을때가 아니라, 같거나 클 때 (count&gt;=target)로 설정해주었다.느낀 점: 처음에 무식하게 이진탐색을 사용해보지 않고 풀었었다. 이진탐색 개념을 알기 전이었어서 (투포인터랑 혼동했었는데 둘은 또 다른 개념이었다), 유튜브에서 개념을 잡고, 기초 이진탐색 한 문제 풀어본 이후에 다시 풀어보았는데, 막상 이진탐색으로 풀려고 해도 어떤 range안에서 어떤 변수를 target으로 설정해야 할지 헷갈렸다. 그 이전에 푼 이진탐색 문제만큼 문제에서 요구하는 바가 explicit하지 않게 느껴졌다. 하지만 역시 최종적으로 구해야 할 ‘랜선의 최대 길이’에 포커스를 맞추고 생각해보니 당연히 이게 target이 되어야 했다." }, { "title": "TIL_파이썬 관련", "url": "/posts/TIL3/", "categories": "TIL", "tags": "til", "date": "2022-04-03 00:00:00 +0900", "snippet": "Pythonfrom collections import permutationspermutations는 오름차순 순서를 보장해주지 않음pd.concat()이전 dropna로 인해서 순서가 띄엄띄엄 있는 상태에서 pd.concat()의 인자로 ignore_index=True를 넣으면, 최종 df는 index가 0부터 나열된 상태가 됨reset_indexreset_index의 인자로 drop=True를 주면 기존에 있던 index 컬럼은 없애버림ZeroDivisionError: integer division or modulo by zero0으로 나누려고 할 때 나는 에러" }, { "title": "BOJ 1004번 어린 왕자 파이썬", "url": "/posts/1004%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 수학, 구현", "date": "2022-04-03 00:00:00 +0900", "snippet": "문제어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. 행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 (x1, y1)과 도착점 (x2, y2)이 주어진다. 두 번째 줄에는 행성계의 개수 n이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 (cx, cy, r)이 주어진다.출력각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.제한 1000 ≤ x, y, x, y, c, c ≤ 10001122xy 1 ≤ r ≤ 1000 1 ≤ n ≤ 50 좌표와 반지름은 모두 정수T = int(input())for i in range(T): count = 0 # 출발지와 도착지 x1,y1,x2,y2 = map(int,input().split()) # 행성계의 개수 N = int(input()) # 중점 좌표와 반지름 for j in range(N): cx,cy,r = map(int,input().split()) dist_1 = (x1 - cx)**2 + (y1-cy)**2 dist_2 = (x2 - cx)**2 + (y2-cy)**2 r_squared = r**2 if dist_1&lt;r**2 and dist_2&lt;r**2: continue elif r_squared &gt; dist_1 or r_squared &gt; dist_2: count +=1 print(count)완전히 틀렸던 접근방식 BFS출력: 각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.예상 알고리즘: BFS 이유: 여러 경로를 살펴보아야 하고, 그 중에서 최단 거리는 아니어도, 최소의 진입/이탈 횟수를 구하는 것이기 때문 응용: 기존에 최단거리를 구하려고 할 때, 이전 좌표의 value 값을 다음 좌표의 value값을 더해주었었다. 이번에는 거리가 아니라, 진입/이탈 횟수를 count 해야 되기 때문에, 원 안의 좌표들을 구해놓고 해당 좌표에 진입/이탈 시에만 count를 1 더해준다.구현 방안: 중점의 위치와 반지름을 이용해서, 해당 원 안에 포함되는 좌표들을 구한다. BFS로 Loop을 돌면서, 다음 nx,ny가 해당 좌표 안에 포함되게 되면 count를 1 더한다. 마지막에 종점 좌표의 값을 반환해준다. 위의 BFS를 활용한 접근방식이 틀린 이유는 문제에서 ‘거리‘에 대한 요구사항이 없기 때문에 마음만 먹으면 얼마든지 돌아서라도 행성계를 피해서 운전할 수 있다. 따라서, ‘불가피하게’ 행성계를 거칠 수 밖에 없는 케이스만 고려하면 된다.수학, 구현을 활용한 접근 방식불가피한 케이스:BOTH 출발지와 도착지가 동일한 행성계 안에 있을 때: 진입 및 이탈 횟수: 0ONLY the START 출발지만 N개의 행성계 안에 있을 때: 이탈 횟수: NONLY the END 도착지만 N개의 행성계 안에 있을 때 진입 횟수: NBOTH BUT SEPARATE 출발지는 N개의 행성계 안에, 도착지는 M개의 행성계 안에 있을 때 진입 및 이탈 횟수: N+M따라서 행성계의 좌표 정보를 받아서, 출발지와 도착지가 해당 좌표들에 포함되는지, 만약 포함된다면 몇 개에 포함되는지만 확인하면 된다. 위에서 진입 이탈 횟수를 N과 M으로 표기하기는 했지만, 루프를 돌면서 행성계를 하나씩 살펴볼것이기 때문에, 그냥 포함된다면 count를 1 더해주고 아니라면 continue하면 된다.특정 좌표가 행성계 안에 있는지 판단하는 법: x1,y1 혹은 x2,y2로부터 r간의 거리 &lt; r과 cx,cy간의 거리출발지/도착지 좌표가 동일한 행성계 안에 있는지 판단하는 법: x1,y1로부터 r간의 거리 &lt; r과 cx,cy간의 거리 and x2,y2로부터 r간의 거리 &lt; r과 cx,cy간의 거리점과 점 사이의 거리를 구하는 공식 (from (x1,y1) to (y1,y2))(x2 - x1)2 + (y2-y1)2원래 위에 루트를 씌워야 하지만, 비교하는 대상인 반지름(r)에 대신 제곱해서 비교" }, { "title": "BOJ 7562번 나이트의 이동 파이썬", "url": "/posts/7562%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, BFS", "date": "2022-04-02 00:00:00 +0900", "snippet": "문제체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?입력입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, …, l-1} × {0, …, l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.출력각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.\"\"\"알고리즘: BFS최소 이동횟수를 구하는 것이기 때문에 DFS보다는 BFS를 사용이동할때마다, B 배열에 (방문처리 기능도 함) 그 이전 value값을 다음 index value값에 넣기\"\"\"from collections import deque#나이트의 이동방식dx = [2,1,-1,-2,2,1,-1,-2]dy = [1,2,2,1,-1,-2,-2,-1]T = int(input())def BFS(i,j): # 시작점과 종점이 같으면 바로 return if i == x2 and j ==y2: print(0) return queue = deque() queue.append([i,j]) while queue: x,y = queue.popleft() for i in range(8): nx = x+dx[i] ny = y+dy[i] if -1&lt;nx&lt;size and -1&lt;ny&lt;size and B[nx][ny]==0: queue.append([nx,ny]) B[nx][ny] = B[x][y]+1 #끝나는 조건 if nx == x2 and ny == y2: print(B[nx][ny]) returnfor i in range(T): # 데이터 받기 size = int(input()) x1,y1 = map(int,input().split()) x2,y2 = map(int,input().split()) # 보드 만들기 B = [[0 for _ in range(size)] for _ in range(size)] BFS(x1,y1)개인적으로, 그래프 탐색 문제는 요구하는 바가 더 잘 들어나서 수학, 구현 문제보다 알고리즘 아이디어를 떠올리기가 훨씬 수월하다.술술 코드가 짜였으나, 방향 벡터 한 쌍의 값을 실수로 중복되게 설정해서 테스트케이스는 통과하지만, ‘틀렸습니다’가 떴었다.질문검색에서 나랑 똑같은 사람이 있어서 그거 보고 해결했다.하필 테스트케이스는 통과했기 때문에, 만약 실전이었다면 많이 헤맸을 것 같다." }, { "title": "BOJ 2847번 게임을 만든 동준이 파이썬", "url": "/posts/2847%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-01 00:00:00 +0900", "snippet": "문제학교에서 그래픽스 수업을 들은 동준이는 수업시간에 들은 내용을 바탕으로 스마트폰 게임을 만들었다. 게임에는 총 N개의 레벨이 있고, 각 레벨을 클리어할 때 마다 점수가 주어진다. 플레이어의 점수는 레벨을 클리어하면서 얻은 점수의 합으로, 이 점수를 바탕으로 온라인 순위를 매긴다. 동준이는 레벨을 난이도 순으로 배치했다. 하지만, 실수로 쉬운 레벨이 어려운 레벨보다 점수를 많이 받는 경우를 만들었다.이 문제를 해결하기 위해 동준이는 특정 레벨의 점수를 감소시키려고 한다. 이렇게해서 각 레벨을 클리어할 때 주는 점수가 증가하게 만들려고 한다.각 레벨을 클리어할 때 얻는 점수가 주어졌을 때, 몇 번 감소시키면 되는지 구하는 프로그램을 작성하시오. 점수는 항상 양수이어야 하고, 1만큼 감소시키는 것이 1번이다. 항상 답이 존재하는 경우만 주어진다. 정답이 여러 가지인 경우에는 점수를 내리는 것을 최소한으로 하는 방법을 찾아야 한다.입력첫째 줄에 레벨의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 각 레벨을 클리어하면 얻는 점수가 첫 번째 레벨부터 마지막 레벨까지 순서대로 주어진다. 점수는 20,000보다 작은 양의 정수이다.출력첫째 줄에 점수를 몇 번 감소시키면 되는지 출력한다.#sort 역순으로#0부터 해서 다음꺼가 이전꺼보다 크다면 count에 &lt;큰거-작은거+1&gt;만큼 증가시킨다#만약 작다면 다음으로 넘어간다N = int(input())S = [int(input()) for _ in range (N)]S = S[::-1]# 아래와 같이 하면 안됨...# S = sort(reverse=True)count = 0for i in range(N-1): if S[i] &lt;= S[i+1]: subtract = S[i+1]-S[i]+1 S[i+1]-= subtract count += subtract else: continueprint(count)" }, { "title": "BOJ 2164번 카드2 파이썬", "url": "/posts/2164%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-01 00:00:00 +0900", "snippet": "문제N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.입력첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.출력첫째 줄에 남게 되는 카드의 번호를 출력한다.from collections import dequeN = int(input())card = deque([i for i in range(1,N+1)])while len(card)!=1: card.popleft() to_first = card.popleft() card.append(to_first)print(card.popleft())" }, { "title": "BOJ 1783번 병든 나이트 파이썬", "url": "/posts/1783%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-01 00:00:00 +0900", "snippet": "1783번 병든 나이트 파이썬문제병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다. 2칸 위로, 1칸 오른쪽 1칸 위로, 2칸 오른쪽 1칸 아래로, 2칸 오른쪽 2칸 아래로, 1칸 오른쪽병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.입력첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.출력병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.N,M = map(int,input().split())if N==1 or M==1: print(1)elif N==2: print(min(4,(M+1)//2))elif M&lt;=6: print(min(4,M))else: print(M-2)조건 분기가 굉장히 빡셌고, 처음에 감을 못 잡아서 블로그들에서 어떻게 문제에 접근했는지 훑었다.그리고 스스로 조건들을 나눠봤는데, 물론 노가다로 할 수 있지만 다 하고 나니 구현 빡센 문제만큼 힘이 들었다…목표 최대로 많이 방문할 수 있는 최댓값을 구하는 것이동방식: 2칸 위로, 1칸 오른쪽 1칸 위로, 2칸 오른쪽 1칸 아래로, 2칸 오른쪽 2칸 아래로, 1칸 오른쪽이동방식 제약: 1번,4번: N이 3 이상이고 M이 2 이상일 때 사용 가능 2번,3번: N이 2 이상이고 M이 3 이상일 때 사용 가능특징: 1-4번의 특징이 상하좌우에서 ‘좌’만 없다. 모든 이동방식에 오른쪽은 꼭 끼어있다.위의 두 이유 때문에 빙빙 도는 일 없이 무조건 체스판의 종점에 도착하게 된다.제약: 이동횟수가 4번보다 적다면 움직임에 제약이 업음 이동횟수가 4번보다 적지 않다면 꼭 이동방식 4개를 최소 한번씩은 사용을 해야 함 따라서 5칸 이상을 가려면 M이 최소 7은 되야 함 (오른쪽을 다 쓰려면 1+2+2+1=6이고 시작 위치가 1이기 때문) 미리 거를 수 있는 조건:-** N이 1일 떄** - 최소 한 칸은 위로든 아래로든 가야하기 때문에, 최대 방문 가능 횟수는 현 위치인 1칸- N이 2일 떄 - 2,3을 번갈아 사용하면서 오른쪽으로 2칸 씩 갈 수는 있지만, 1,4번을 사용 못하기 때문에 최대 방문 횟수는 4 미만.. 따라서 4랑 (M+1)//2 중 더 작은 값을 출력 - (M+1)//2인 이유: 1은 시작 지점이라서 더해준거고. 2번 3번 중 뭘 택하더라도 오른쪽으로 2칸씩밖에 못 가서 2를 나눠준것- M이 1일 떄 - 최소 한 칸은 오른쪽으로 가야하기 때문에, 최대 방문 가능 횟수는 현 위치인 1칸- M이 6과 같거나 작을 때 - 만약 5번 이상을 가려면 M=7일때만 가능하기 때문에 무조건 4 이하의 값이 나온다. 따라서 4랑 M 중 더 작은 값을 출력- M이 6보다 클 때 - 위에서 조건들이 걸러지면서 N이 3 이상이라는 거는 보장된 상태라서 오른쪽으로 가는 것만 고려하면 된다. - 다만, 최댓값을 구하려고 하되, 4를 넘기기 위해 모든 경우의 수는 사용해야 해서, 2와 3은 한번씩만 실행하고, 나머지는 오른쪽을 1칸만 가도록 한다. - 결국 최대 방문 가능 횟수는 M- 2(이동방식 2번의 오른쪽 2칸+ 이동방식 3번의 오른쪽 2칸)" }, { "title": "BOJ 1543번 문서검색 파이썬", "url": "/posts/1543%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디, 문자열", "date": "2022-04-01 00:00:00 +0900", "snippet": "문제세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다.세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.입력첫째 줄에 문서가 주어진다. 문서의 길이는 최대 2500이다. 둘째 줄에 검색하고 싶은 단어가 주어진다. 이 길이는 최대 50이다. 문서와 단어는 알파벳 소문자와 공백으로 이루어져 있다.출력첫째 줄에 중복되지 않게 최대 몇 번 등장하는지 출력한다.파이썬 내장함수를 사용한 풀이doc = str(input())word = str(input())print(doc.count(word))While문으로 직접 구현한 풀이doc = input()word = input()count = 0idx = 0while idx&lt;len(doc): if word == doc[idx:idx+len(word)]: count+=1 idx += len(word) else: idx+=1print(count)" }, { "title": "BOJ 1080번 행렬 파이썬", "url": "/posts/1080%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-01 00:00:00 +0900", "snippet": "1080번 행렬 파이썬문제0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)입력첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.출력첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.\"\"\"알고리즘루프를 돌면서 A 인덱스 값과 B 인덱스 값을 비교하고 다르면 (A 인덱스 값이 좌측 최상단인) 3x3 부분 행렬을 뒤집는다다 돌고나서 값이 같다면 count, 아니라면 -1을 출력한다.\"\"\"def reverse(x,y): global A for i in range(x,x+3): for j in range(y,y+3): if A[i][j] == 0: A[i][j] = 1 else: A[i][j] = 0N,M = map(int,input().split())A = [list(map(int,list(input()))) for _ in range(N)]B = [list(map(int,list(input()))) for _ in range(N)]count = 0# A의 값과 B의 값이 동일한지 루프를 돌면서 확인하고, 다르다면 3x3 행렬을 뒤집는다.for i in range(N-2): for j in range(M-2): if A[i][j] != B[i][j]: reverse(i,j) count+=1# A랑 B가 동일한지 검사def check(): for i in range(N): for j in range(M): #동일하지 않다면 -1을 출력하고 종료 if A[i][j] != B[i][j]: print(-1) return #동일하다면 count 값을 출력 print(count)check()그리디 알고리즘이란?그리디는 최적의 답을 내는 사용 조건으로 최적 부분 구조와 탐욕적 선택 속성이 있어야 한다.최적 부분 구조: 각 부분 문제의 최적해만 있으면, 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 최적 부분 구조 조건을 성립한다고 함탐욕적 선택 속성: 탐욕적으로만 선택을 해도 최적해를 구할 수 있음. &lt;예를 들어 도착했을 때 최댓값을 구하려고 할 때, 맞닥뜨리는 양갈래길마다 값이 큰 길만 선택&gt; 다른 특징으로는, 한번 선택한 것은 번복하지 않고,항상 최적해를 보장하지 않기 때문에, 정당성 증명 과정을 거쳐야 한다.풀이일단 첫번째로 든 의문점은 “뒤집는 순서가 결과값에 영향을 주지 않을까?” 였다.그리디 알고리즘 통해서 최소값이 얻어진다고 확신을 가질 수 없었기 때문에 섣불리 사용할 수가 없었다.구글링 해봤을 때 나랑 비슷한 고민을 했거나, 아니면 시원한 답변을 가진 블로그 글을 찾기 어렵던 중 가장 도움이 되었던게 아래 블로그이다.백준 1080. 행렬일단 여기 나온 내용을 정리해보자면, 이 문제의 목적은 ‘뒤집기’이고, 문제의 핵심은 이 뒤집기를 ‘최소화’하는 것이다.결국 A를 B랑 동일하게 만들어야 하기에, 다른 부분이 나오면 뒤집기는 한다!하지만 이렇게 확정지은 칸을 다시 뒤집어서 번복하거나, 재차 뒤집는 일은 없어야 한다는 의미이다.그 이유는 뒤집기의 속성을 인지하면 이해할 수 있다.2번 뒤집으면 원래대로 돌아오고, 3번 뒤집으면 1번 뒤집는것과 동일하기에, 2번 이상 뒤집는 것은 ‘뒤집기를 최소화’하려는 목적에 어긋나기 때문이다.그래서 반복문으로 A 행렬을 순서대로 살펴보면서 만약 B 행렬의 칸과 다를 경우에 뒤집는다.문제의 조건이라서 어쩔 수 없이 3x3만큼 뒤집기는하지만, 확정짓게 되는 것은 “한 칸”이다.확정을 지은 이 ‘한 칸’이 번복되면 안된다는 의미이다.만약 3x3 안에 있는 다른 칸들이 어떻게 얻어걸려서 B 행렬의 칸과 같아지더라도, 이는 위의 ‘한 칸’처럼 확정되었다고는 할 수 없다. 얼마든지 다른 칸의 순서에 3x3안에 또 들어가게 되면서 다시 뒤집힐 수도 있다.대신 루프의 자신 차례에서 확정을 받게 되면, 다시 뒤집힐 일은 없다.이 루프를 반복하고 나면 A 행렬은 의도했던대로 B 행렬과 똑같아졌던가, 아니면 그럼에도 똑같지 않을 수 있다.느낀 점:블로그를 서칭하면서 아이디어를 캐치하고 풀기는 풀었지면 영 찝찝함이 남아있기는 하다.그리디인것을 알고서도 감이 안잡혔는데, 만약 알고리즘 분류가 그리디인것을 몰랐다면 과연 풀 수 있었을까 싶다. (엄청나게 많은 시행착오를 겪었을 것 같다)그래도 확실히 이런 문제를 맞닥뜨리면서 그리디 알고리즘의 본질적인 원리를 생각해볼 수 있었다는게 꽤나 큰 순기능이었던 것 같다." }, { "title": "BOJ 1049번 기타줄 파이썬", "url": "/posts/1049%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-04-01 00:00:00 +0900", "snippet": "문제Day Of Mourning의 기타리스트 강토가 사용하는 기타에서 N개의 줄이 끊어졌다. 따라서 새로운 줄을 사거나 교체해야 한다. 강토는 되도록이면 돈을 적게 쓰려고 한다. 6줄 패키지를 살 수도 있고, 1개 또는 그 이상의 줄을 낱개로 살 수도 있다.끊어진 기타줄의 개수 N과 기타줄 브랜드 M개가 주어지고, 각각의 브랜드에서 파는 기타줄 6개가 들어있는 패키지의 가격, 낱개로 살 때의 가격이 주어질 때, 적어도 N개를 사기 위해 필요한 돈의 수를 최소로 하는 프로그램을 작성하시오.입력첫째 줄에 N과 M이 주어진다. N은 100보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에는 각 브랜드의 패키지 가격과 낱개의 가격이 공백으로 구분하여 주어진다. 가격은 0보다 크거나 같고, 1,000보다 작거나 같은 정수이다.출력첫째 줄에 기타줄을 적어도 N개 사기 위해 필요한 돈의 최솟값을 출력한다.N,M = map(int,input().split())package = []single = []for i in range(M): a,b = map(int,input().split()) package.append(a) single.append(b)package_min = min(package)single_min = min(single)#single의 단가가 더 비쌀 때if package_min &lt; single_min*6: # 6으로 나누어 떨어지지 않는 나머지 값을 계산하려 할 때, 패키지 값보다 낱개 값이 더 비싸면 \"패키지 값 선택\" if package_min &lt; (N%6)*single_min: print((N//6)*package_min+package_min) else: print((N//6)*package_min+(N%6)*single_min)#package의 단가가 더 비쌀 때elif package_min &gt;= single_min: print(N*single_min)느낀 점쉬운 문제임에도 불구하고, 아이디어까지는 떠올렸지만 짧은 시간내에 빨리 구현이 되지 않았다.아직 수학적 사고와 구현력이 부족한 것 같다.섣부르게 Naive한 방식으로 계산을 하려 하기보다는 (물론 그리디 문제이지만), 문제에서 뭘 요구하는지, 핵심 아이디어 (단가로 비교하는 것)를 짚어내야 할 것 같다.아무리 그리디 문제여도 어느정도 수학적 사고를 기반으로 한 아이디어를 토대로 로직이 짜여져야 한다." }, { "title": "TIL_알고리즘 문제 1개 풀고, 다음날 회사 미팅 준비", "url": "/posts/TIL2/", "categories": "TIL", "tags": "til, 투포인터", "date": "2022-03-31 00:00:00 +0900", "snippet": "TIL음… 하려던 Typescript 공부는 따로 하지 못했다.알고리즘 문제 풀다가 막혀서 꽤 많은 시간을 소용한 것 같다.알고리즘오늘 푼 알고리즘 문제는 ‘2531번 회전 초밥’이다.예전에 SW 마에스트로 코테 준비하면서 벼락치기로 배웠던 투포인터 개념이 잘 복습되고 있는 것 같다..개념을 코드로 표현하는 방법 자체는 크게 변하지는 않는데, 자잘하게 변형시켜주어야 한다.다양한 문제를 풀어보면서 다양한 케이스에 익숙해져야겠다는 생각이 들었다.회사 업무Dash Callback을 통해 이상치가 나타난 Tag 대상으로 Indicator UI를 초록색에서 빨간색으로 바꿔주었다.내 Mac M1에서는 잘 돌아가지만 아마 Elastic Beanstalk에 배포후에는 버벅일것이다.현재 실험용으로 AWS Free Tier를 사용하고 있기 때문에, 곧 회사에 말하고 이제 지금보다 높은 사양의 스펙으로 바꿔야한다." }, { "title": "BOJ2531번 회전 초밥 파이썬", "url": "/posts/2531%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 투포인터", "date": "2022-03-31 00:00:00 +0900", "snippet": "문제회전 초밥 음식점에는 회전하는 벨트 위에 여러 가지 종류의 초밥이 접시에 담겨 놓여 있고, 손님은 이 중에서 자기가 좋아하는 초밥을 골라서 먹는다. 초밥의 종류를 번호로 표현할 때, 다음 그림은 회전 초밥 음식점의 벨트 상태의 예를 보여주고 있다. 벨트 위에는 같은 종류의 초밥이 둘 이상 있을 수 있다.https://upload.acmicpc.net/f29f0bd9-6114-4543-aa72-797208dc9cdd/-/preview/새로 문을 연 회전 초밥 음식점이 불경기로 영업이 어려워서, 다음과 같이 두 가지 행사를 통해서 매상을 올리고자 한다. 원래 회전 초밥은 손님이 마음대로 초밥을 고르고, 먹은 초밥만큼 식대를 계산하지만, 벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우 할인된 정액 가격으로 제공한다. 각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 무료로 제공한다. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가 새로 만들어 손님에게 제공한다.위 할인 행사에 참여하여 가능한 한 다양한 종류의 초밥을 먹으려고 한다. 위 그림의 예를 가지고 생각해보자. k=4이고, 30번 초밥을 쿠폰으로 받았다고 가정하자. 쿠폰을 고려하지 않으면 4가지 다른 초밥을 먹을 수 있는 경우는 (9, 7, 30, 2), (30, 2, 7, 9), (2, 7, 9, 25) 세 가지 경우가 있는데, 30번 초밥을 추가로 쿠폰으로 먹을 수 있으므로 (2, 7, 9, 25)를 고르면 5가지 종류의 초밥을 먹을 수 있다.회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오.입력첫 번째 줄에는 회전 초밥 벨트에 놓인 접시의 수 N, 초밥의 가짓수 d, 연속해서 먹는 접시의 수 k, 쿠폰 번호 c가 각각 하나의 빈 칸을 사이에 두고 주어진다. 단, 2 ≤ N ≤ 30,000, 2 ≤ d ≤ 3,000, 2 ≤ k ≤ 3,000 (k ≤ N), 1 ≤ c ≤ d이다. 두 번째 줄부터 N개의 줄에는 벨트의 한 위치부터 시작하여 회전 방향을 따라갈 때 초밥의 종류를 나타내는 1 이상 d 이하의 정수가 각 줄마다 하나씩 주어진다.출력주어진 회전 초밥 벨트에서 먹을 수 있는 초밥의 가짓수의 최댓값을 하나의 정수로 출력한다.import sysfrom collections import defaultdictN,D,K,C = map(int,input().split())# input = sys.stdin.readline#초밥 배열S = []#초밥 종류 딕셔너리sushiType= defaultdict(int)#초밥번호 받기for i in range(N): sushi = int(input()) S.append(sushi) # sushiType[sushi] = 0S.extend(S)# 시작 전에 일단 K만큼 더해주기for i in range(K): sushiType[S[i]]+=1maxv = len(sushiType)for i in range(K,len(S)): sushiType[S[i-K]]-=1 if sushiType[S[i-K]]==0: del sushiType[S[i-K]] sushiType[S[i]]+=1 # 보너스 sushiType[C] = 1 maxv = max(maxv,len(sushiType))print(maxv)느낀 점 이전에 풀었던 전형적인 투포인터 문제였다 (중첩반복문으로 하던거를 포인터 두개를 사용해서 루프 하나로 해결) 지금 left, right이란 변수를 따로 만들어서 사용하고 있지는 않은데, 만들어야 디버깅할 때 가독성이 높아질 것 같다. 회전 형식이기 때문에 ‘S.extend(S)’를 해야한다는것을 몰라서 처음에 헤메다가 이 부분만 다른 사람 풀이를 참고했다. 처음에 딕셔너리가 아니라 Set을 사용하려고 했는데, 같은 번호의 초밥이 2번까지 나올 수 있어서, 계산이 까다로워진다.. 해당 딕셔너리의 value가 0이라면 삭제해버리는 로직을 떠올리기 전에, list comprehension으로 dict를 list로 만들고 set으로 감싸서 len을 구하는… 복잡한 방법을 생각했었는데 이렇게 하면 시간 초과가 난다.배운 점 defaultdict를 사욤함으로써 굳이 미리 0으로 초기화 해두지 않아도 되고, Key Error가 나는 것을 방지할 수 있다." }, { "title": "TIL_시작", "url": "/posts/TIL1/", "categories": "TIL", "tags": "til, css, 투포인터", "date": "2022-03-30 00:00:00 +0900", "snippet": "TIL 시작하는 이유우선 TIL (Today I Learned)라는 기록 문화?를 예전부터 알고 있었는데 실천을 하고 있지는 않았다.난 뭔가 머릿속으로 납득이 되기 전까지는 정말 동기부여가 1도 안되는 사람이다.이 태도의 단점은 그냥 무작정 해보고 나중에 그 이유가 납득이 되는 일도 많은데, 그 기회를 놓치게 된다는 것이다.다시 본론으로 돌아와서, 아까부터 TIL을 써야지 써야지 하다가도, 여러 의문들이 꼬리에 꼬리를 물었다.“Today를 기준으로 배운것들을 적으면 나중에 다시 찾아서 보기 힘들지 않을까?”“보여주기식 아닐까? 이런거를 적느라 오히려 에너지를 뺏기지 않을까?”https://www.youtube.com/watch?v=3Ym3MM628bk&amp;t=288s&amp;ab_channel=%EC%9D%B4%EC%83%81%ED%95%9C%EB%A6%AC%EB%B7%B0%EC%9D%98%EC%95%A8%EB%A6%AC%EC%8A%A4AliceinWonderReview위 영상을 다 본 것은 아니고 스킵하면서 보다가, 타임로그 부분을 보고 직감적으로 TIL의 순기능을 알게 됐다.공부한 것을 나중에 다시 찾아보는 이점도 있겠지만, 무엇보다 오늘 무엇을 배웠는지에 대한 객관적인 메타인지가 가능할것이란게 가장 큰 점일 것 같다.‘단순히 공부를 열심히 한 느낌’혹은‘뭔가 많이 배운 느낌’이러한 추상적인 느낌을 배워서 실체적인 문체로 무엇을 배웠는지에 대한것을 적어나가면 본인에 대해서 한층 객관적인 파악을 할 수 있을 것이다.역시 오늘 적으려고 하니 나는 오늘 생각보다 많이 공부하지 않았구나 라고 알게되었다.여기서부터 본격적인 TIL알고리즘: 투포인터‘알고리즘 2559번 수열’ 을 풀었다.투포인터는 연속적으로 나열되어있다는 (ex. 수열) 가정하에 사용할 수 있는 기법이다.투 포인터는 수의 나열이 연속적이라는 특성을 활용한다.여러 응용 방법이 있지만, 공통적인것은 이름인 ‘투 포인터’에서 알 수 있듯, 반복문을 돌릴 때 두 인덱스 위치에서 조건에 따라서 위치를 바꿔주면서 계산을 해주는 것이다.N가지의 연속된 수들에서 연속된 K개의 수의 부분합이 제일 큰 값을 찾으려면 for문 2개를 중첩해서 부분합을 구해주는 방식을 떠올릴 수 있지만 이는 O(NK)의 시간복잡도를 가지고 있고, 이 방식으로 풀려고 하면 시간 초과가 나게 된다.이 접근 방식에서 속도를 갉아먹는 부분은 ‘다음 부분합은 그 이전 부분합에서 했던 계산을 중복해서 한다는 것’이다.이를 타파하기 위해, 투포인터를 활용해서 오직 하나의 for 문안에서, 부분합을 계산하고, 다음 부분합을 계산할 때는 그 이전 index값을 빼주고, 다음 index값은 더해주는 방식을 활용해면 O(N) 방식으로도 문제를 풀 수 있다.CSS오늘은 ‘인프런’에서 잔재미코딩님께서 강의하시는 **풀스택을 위한 탄탄한 프런트엔드 부트캠프 (HTML, CSS, 바닐라 자바스크립트 + ES6) [풀스택 Part2]에서 CSS부분을 복습했다.**근데 확실히 이미 알고 있던 부분이 많아서 보는 내내 집중력이 떨어졌다.그래서 다음부터는 앞 강의들보다는 뒷 강의로 들어가서 어려운 부분을 보고, 거기서 모르는게 나오면 앞으로 돌아가서 찾아보는게 나을것같다는 생각이 들었다.box-sizing이라는 속성과 그 값으로 가질 수 있는 content-box, border-box에 대해서 배웠다.이에 관해서는 따로 게시글을 정리해서 올렸다.회사 일회사 박사님으로부터 제안서에 들어갈 내용 중 개발자 입장에서 적어야 되는 내용이 있다고 적어서 보내달라고 나에게 요청하셨다.그래서 지금 회사에서 개발하고 있는 모델링 어플리케이션을 어떤 언어 (Python)), 프레임워크(Flask, Dash)를 사용하고 배포(Elastic Beanstalk)는 어떻게 하는 식의 내용을 정리해서 보내드렸다.적고나니 오늘 공부한 것들이 참 적은 것 같다.안타깝기도 하고, TIL의 필요성을 더 크게 느끼게 되었으니 잘 됐기도 하다.내일부터 본격적으로 잘해보자." }, { "title": "BOJ 2644번 촌수계산 파이썬", "url": "/posts/2644%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, BFS", "date": "2022-03-29 00:00:00 +0900", "snippet": "2644번 촌수계산문제우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.입력사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.각 사람의 부모는 최대 한 명만 주어진다.출력입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.풀이 접근방식트리 구조로 부모는 최상단에 위치하고, 자식을 노드로 가지고 있다.A와 B의 관계를 본다고 하면 둘 중 한곳을 출발지로 삼고 탐색을 시작한다. A와 B 간의 촌수를 계산하는 것이기 때문.막다른 Node에 도착하게 되면, 그 전 Node로 돌아가서 Visit하지 않은 곳을 탐색하고, 이것을 반복한다.BFS로 탐색하고, 한 노드에서 다른 노드로 갈 때마다 &lt;이전 value + 1&gt;값을 집어넣는다. 여차하면 모든 경우의 수를 살펴보게 될 수도 있는 DFS보다, 한 노드와 다른 한 노드의 거리를 찾기에 최적화된 BFS가 더 사적합하다.A에서 출발해서 만약 B를 찾게 되면  &lt;이전 value + 1&gt;값을 반환한다. 각 사람의 부모는 최대 한명이기 때문에, 만약 B를 찾았다면 다른 경우의 수를 고려할 필요 없이 그게 최단거리이다. 근데 이렇게 안해도 시간초과 안 나는 듯하다" }, { "title": "BOJ 2559번 수열 파이썬", "url": "/posts/2559%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 투포인터", "date": "2022-03-29 00:00:00 +0900", "snippet": "문제매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때,3 -2 -4 -9 0 3 7 13 8 -3모든 연속적인 이틀간의 온도의 합은 아래와 같다.https://upload.acmicpc.net/563b6bfd-12ff-4275-a869-90fdd43b6deb/-/preview/이때, 온도의 합이 가장 큰 값은 21이다.또 다른 예로 위와 같은 온도가 주어졌을 때, 모든 연속적인 5일 간의 온도의 합은 아래와 같으며,이때, 온도의 합이 가장 큰 값은 31이다.매일 측정한 온도가 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.입력첫째 줄에는 두 개의 정수 N과 K가 한 개의 공백을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 온도를 측정한 전체 날짜의 수이다. N은 2 이상 100,000 이하이다. 두 번째 정수 K는 합을 구하기 위한 연속적인 날짜의 수이다. K는 1과 N 사이의 정수이다. 둘째 줄에는 매일 측정한 온도를 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -100 이상 100 이하이다.출력첫째 줄에는 입력되는 온도의 수열에서 연속적인 K일의 온도의 합이 최대가 되는 값을 출력한다.\"\"\"알고리즘기법: 투포인터'연속적인'이란 말이 들어갔음으로 투포인터를 사용할 수 있음N을 for문으로 돌면서 그 안에서 또 K만큼 반복한다고 하면 O(NK)이다.N은 2 이상 100,000이하K는 1과 N 사이의 정수즉 최악의 경우, 거의 O(n^2)만큼의 수행시간을 가질 수 있다.그렇다면 다음 연속합을 구할 때, 연속하다는 특성을 활용해서 K만큼 다시 더해주는 것이 아니라, 이전 연속합에 이전 원소를 빼주고 다음 원소를 더해주는 방식으로 다음 연속합들을 구해나간다.\"\"\"\"\"\"자료구조1. S: 연속 숫자들을 담을 배열2. sumValue: 연속합을 기록할 sumValue 변수 하나3. maxv: max()를 사용하여 sumValue와 비교하여 최대치를 갱신 - 초반에 maxv로 최대치를 따로 기록하지 않고, sumValue를 단독으로 사용하면서, sumValue가 반복문을 돌면서도 값이 변하지 않게 되는 실수를 했었음 (max(sumValue, sumValue+S[i]-S[i-k]))\"\"\"N, K = map(int,input().split())S = list(map(int,input().split()))sumValue = 0for i in range(K): sumValue+=S[i]maxv=sumValuefor i in range(K,N): sumValue+=S[i] sumValue-=S[i-K] maxv = max(maxv, sumValue)print(maxv)" }, { "title": "BOJ 1926번 그림 파이썬", "url": "/posts/1926%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, BFS", "date": "2022-03-29 00:00:00 +0900", "snippet": "문제어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.입력첫째 줄에 도화지의 세로 크기 n(1 ≤ n ≤ 500)과 가로 크기 m(1 ≤ m ≤ 500)이 차례로 주어진다. 두 번째 줄부터 n+1 줄 까지 그림의 정보가 주어진다. (단 그림의 정보는 0과 1이 공백을 두고 주어지며, 0은 색칠이 안된 부분, 1은 색칠이 된 부분을 의미한다)출력첫째 줄에는 그림의 개수, 둘째 줄에는 그 중 가장 넓은 그림의 넓이를 출력하여라. 단, 그림이 하나도 없는 경우에는 가장 넓은 그림의 넓이는 0이다.DFSimport syssys.setrecursionlimit(10000000)input = sys.stdin.readlinen,m = map(int,input().split())graph = []for i in range(n): graph.append(list(map(int,input().split())))# 이 방향벡터 사용해서 for문 돌리면 메모리 초과#dx = [-1,1,0,0]#dy = [0,0,-1,1]areas = []cnt=0def dfs(x,y): global cnt\t\tif x &lt;= -1 or x &gt;= n or y &lt;= -1 or y &gt;= m:\t\t return False if graph[x][y] == 1:\t cnt+=1\t graph[x][y] = 0\t\t\tdfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) # 방향벡터로 for문 돌리면 메모리 초과 # for i in range(4): # nx = x+dx[i] # ny = y+dy[i] # dfs(nx,ny)\t\t\t\treturn True return Falsefor i in range(n): for j in range(m): #1일때만 if graph[i][j]==1: cnt=0 dfs(i,j) areas.append(cnt)if len(areas)==0: print(0,0,sep='\\n')else: print(len(areas)) print(max(areas))BFSfrom collections import deque# n,m = 6,5# graph = [[1,1,0,1,1],# [0,1,1,0,0],# [0,0,0,0,0],# [1,0,1,1,1],# [0,0,1,1,1],# [0,0,1,1,1]]n,m = map(int,input().split())graph = [list(map(int,input().split())) for _ in range(n)]#그림을 세야하고#1의 개수가 가장 많은 것을 출력해야함dx = [-1,1,0,0]dy = [0,0,-1,1]def bfs(x,y,cnt): graph[x][y]=0 queue = deque() queue.append([x,y]) cnt+=1 while queue: a,b=queue.popleft() for i in range(4): nx = a+dx[i] ny = b+dy[i] if -1&lt;nx&lt;n and -1&lt;ny&lt;m and graph[nx][ny] == 1: graph[nx][ny] = 0 queue.append([nx,ny]) cnt+=1 return cntresult = []for i in range(n): for j in range(m): if graph[i][j] == 1: result.append(bfs(i,j,0))if len(result)==0: print(0,0,sep='\\n')else: print(len(result)) print(max(result))처음에 DFS로 풀었는데 제출하니 시간 초과가 나서 BFS로 풀었다.근데 풀고 나서도 DFS로 안풀린게 찝찝해서 계속 붙잡고 해보니, 방향벡터를 사용 안하면 메모리 초과가 안 난다.DFSBFS메모리 사용량을 보면 DFS가 압도적으로 크다.확실히 경우에 따라서 모든 경우의 수를 살펴봐야 할 수도 있기 때문에 DFS는DFS는 재귀방식으로 수행되고, 이에 따라 함수를 호출할때마다 스택이 쌓이기 때문에 메모리를 많이 차지하게 된다.반면 BFS는 queue에 쌓이는 컬랙션이나 class 객체의 크기가 크지 않다면 훨씬 적은 비용이 발생할 수 있다.따라서 BFS가 메모리 측면으로는 유리할 수 있다." }, { "title": "BOJ 1389번 케빈 베이컨의 6단계 법칙 파이썬", "url": "/posts/1389%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, BFS", "date": "2022-03-29 00:00:00 +0900", "snippet": "문제케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.출력첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.from collections import dequen, m = map(int,input().split())distance = [0]*(n+1)graph = [[] for _ in range(n+1)]for i in range(m): x,y = map(int,input().split()) graph[x].append(y) graph[y].append(x)def BFS(start): visited = [start] distance = [0]*(n+1) queue=deque() queue.append(start) while queue: v = queue.popleft() for i in graph[v]: if i not in visited: distance[i] += distance[v]+1 visited.append(i) queue.append(i) return sum(distance)final = []for i in range(1,n+1): # 초기화 # 케빈 합 계산 final.append(BFS(i))print(final.index(min(final))+1)#Visited를 안 쓴다면from collections import dequen, m = map(int,input().split())distance = [0]*(n+1)graph = [[] for _ in range(n+1)] for i in range(m): x,y = map(int,input().split()) graph[x].append(y) graph[y].append(x)def BFS(start): distance = [0]*(n+1) queue=deque() queue.append(start) while queue: v = queue.popleft() for i in graph[v]: if distance[i] == 0 and i != start: distance[i] += distance[v]+1# print (distance) queue.append(i) return sum(distance)final = []for i in range(1,n+1): # 초기화 # 케빈 합 계산 final.append(BFS(i))print(final.index(min(final))+1)풀이 접근 방식:촌수관계 문제처럼, 한 노드에서 다른 한 노드까지 거리를 계산하는 것은 DFS보다 BFS가 더 빠르고 적합하다.케빈 베이컨 법칙의 경우, 가장 결과값이 낮은 사람을 찾는것이므로 모든 인원에 대해서 BFS를 수행해주고, 최소값을 출력해주어야 한다.처음에 visited로 방문처리와 거리계산을 동시에 하려고 했는데, 그러면 BFS문 내에서 for문을 돌 때 조건문을 단순히 if distance[i] == 0로 하는게 아니라 i != start도 조건으로 넣어주어야 한다. 자기 자신을 포함하면 안되기 때문이다." }, { "title": "Apple M1에서 XgBoost 설치하기", "url": "/posts/xgb_installation-copy-2/", "categories": "Python", "tags": "파이썬, xgboost, mac", "date": "2022-03-18 00:00:00 +0900", "snippet": "작년 회사에 입사하면서 노트북을 구매해주겠다고 해서 당시 출시됐던 Apple M1를 구매해서 1년째 잘 사용하고 있습니다.M1에서 자체적인 칩을 사용하면서 뭔가 내부적으로 혁신적인 변화가 일어난것같은데, 그만큼 자잘한 오류들도 많았습니다.윈도우에서 사용하던 파이썬 라이브러리를 똑같이 설치해서 사용하려는데 numpy, xgboost 등 설치 안되는 라이브러리가 많아서 다 stackoverflow에서 편법으로 설치했습니다.다른 프로젝트를 하게 되면서 가상환경을 새로 만들고 설치하려는데 그때 했던 방법으로 안되더라고요. 그 당시에는 아마 아래 두 링크를 참고했던 것 같습니다.Error when importing XGBoost on Apple M1?How to install xgboost in python on MacOS?설치는 되는데 실행하면 아래와 같은 오류가 뜹니다. 이거에 대한 해결방안으로 libomp를 설치하고 올바른 폴더로 심볼릭 링크를 이어주는 등 다 해봤는데 그래도 안됐습니다.xgboost.core.XGBoostError: XGBoost Library (libxgboost.dylib) could not be loaded.Likely causes: * OpenMP runtime is not installed (vcomp140.dll or libgomp-1.dll for Windows, libomp.dylib for Mac OSX, libgomp.so for Linux and other UNIX-like OSes). Mac OSX users: Run `brew install libomp` to install OpenMP runtime. * You are running 32-bit Python on a 64-bit OSError message(s): ['dlopen(/usr/local/lib/python3.7/site-packages/xgboost/lib/libxgboost.dylib, 6): Library not loaded: /usr/local/opt/libomp/lib/libomp.dylib\\n Referenced from: /usr/local/lib/python3.7/site-packages/xgboost/lib/libxgboost.dylib\\n Reason: no suitable image found. Did find:\\n\\t/usr/local/opt/libomp/lib/libomp.dylib: mach-o, but wrong architecture\\n\\t/opt/homebrew/Cellar/libomp/13.0.1/lib/libomp.dylib: mach-o, but wrong architecture']그래서 디깅한 끝에 작동되는 방법을 찾았습니다.이분이 정리한거를 따라하니까 되더라고요.About various problems encountered by MacBook Pro running XGBoost위 링크 들어가서 step by step으로 따라해봐도 되지만, 밑에 내용 정리해드리겠습니다.설치과정Homebrew 설치/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"Gcc-6 설치 (다른 버전도 되는 것 같음)brew install gcc --without-multilillvm, clang-omp 설치 (저는 이 2개는 설치 안해줬는데 작동하더라고요, 안되면 이 둘도 설치해보시기 바랍니다.)brew install llvmbrew install clang-ompXgboost Clone 후 설치git clone --recursive https://github.com/dmlc/xgboostcd xgboost; cp make/config.mk ./config.mk; make -j4cd python-package; sudo python setup.py install사실 어떤 원리로 작동 안되고, 작동 되는건지는 모르겠습니다.전 cmake이랑 gcc도 이번에 삽질하면서 처음 접했습니다.이 부분은 여기 나왔던것들 공부해보려고 합니다." }, { "title": "넷플릭스 \"지금 우리 학교는\"으로 이해하는 Javascript Promise (+동기, 비동기)", "url": "/posts/promise/", "categories": "Javascript", "tags": "javascript, promise, async, callback", "date": "2022-03-18 00:00:00 +0900", "snippet": "다음과 같은 상태에서 읽는 것을 추천합니다. Javascript Promise에 대해 접하기는 했지만, 개념이 안 잡힌 상태 동기, 비동기에 대해서 들어보기는 했지만 헷갈리는 상태 Promise, Promise.all, async, await 등 문법에 대해서 자세하게 다루지는 않습니다.문법에 대한거는 나중에 따로 찾아보시고 일단 감만 캐치하시는것을 추천합니다.(그래도 promise의 기본원리, then, resolve,reject, pending, fullfill등 기본원리에 대한 내용은 곧 추가 예정)무언가에 대해서 비유를 들 수 있다는 것은 적어도 그 개념에 대한 큰 그림, 숲은 🌳 볼 수 있게 되었다는 것이다.물론 이는 “정확하게 이해했는가” 와는 또 다른 영역이다..숲을 보게 되었다고 해서 나무 하나 하나의 모양, 잎의 구체적인 색깔, 나무의 종 까지 알게 된 것은 결코 아니다.하지만 깊게, 정확하게 이해하려면, 일단 제일 먼저 앞에 있는 낮은 허들부터 넘어야 한다.이 허들을 넘고나면, 속력이 붙고, 감이 생겨서 다음 허들, 또 그 다음 허들을 넘는 거는 점점 쉬워진다.우선, Promise라는 단어를 순수하게 떠올려보자.Promise는 약속이다.우리는 일상생활에서 왜 약속이라는 것을 할까?약속을 안했을 때 치뤄야 할 대가가 있기 때문일것이다.가장 연결시키기 쉬운 예는, 지우학에서 친구들이 교실을 나가기 전에 순서를 정해서 나가는 식이다.좀비를 앞장 서서 싸워줄 친구가 최전방에 서주고 (ex. 대수),상대적으로 달리기가 느린 친구 뒤쳐져서 좀비한테 당하지 않도록 또 다른 친구가 맨 뒤에 서주는 식이다 (ex. 수혁). 만약, 힘이 센 대수가 먼저 앞장 서서 밀고 나가주지 않고 뒤쳐진다던가 수혁이가 맨 뒤에서 커버쳐주는게 아니라 여자 아이들을 제치고 가버린다던가하면 아래와 같은 사단이 빈번하게 났을 것이다.약속을 만들어봅시다 (틀린 방법)물론 멤버가 더 많지만 가장 메인 캐릭터인 청산, 수혁, 온조, 남라로 예시를 들어 코드를 옮겨보겠다.남라는 다리가 다쳐서 제일 속도가 느리다는 시나리오를 생각해보자.도망갈 때 가장 느린 남라의 속도에 맞춰주기 위해서, 느린 순으로 ‘남라 → 온조 → 수혁 → 청산’ 순으로 코드를 짜보자”가 가장 첫번째로 떠오른 접근방식일 것이다. (코드는 위에서 아래로 실행되니까)//달리기 빠른 순서const 청산_달리기_속도 = 1000;const 수혁_달리기_속도 = 2000;const 온조_달리기_속도 = 3000;const 남라_달리기_속도 = 4000;//느린 사람 먼저 가는 작전setTimeout(() =&gt; { console.log(\"남라 안전 지역 도착\");}, 남라_달리기_속도);setTimeout(() =&gt; { console.log(\"온조 안전 지역 도착\");}, 온조_달리기_속도);setTimeout(() =&gt; { console.log(\"수혁 안전 지역 도착\");}, 수혁_달리기_속도);setTimeout(() =&gt; { console.log(\"청산 안전 지역 도착\");}, 청산_달리기_속도);// 예상 결과// \"남라 안전 지역 도착\"// \"온조 안전 지역 도착\"// \"수혁 안전 지역 도착\"// \"청산 안전 지역 도착\"첫 4번째 라인까지는 특정 지점까지 달리는데까지 걸리는 시간을 정해준 것이다. 숫자가 작을 수록 빠르다.하지만 이렇게 되면 결과는 어떻게 될까?예상한 것과 반대로, 다들 남라는 뒷전이 되었는지, 달리기가 빠른 순서대로 청산 -&gt; 수혁 → 온조 → 남라 순으로 도착한다.이러한 예상 못한 일이 일어나는 이유는 바로 Javascript의 비동기 방식 때문이다.자바스크립트는 기본적으로 극중 이나연식의 마인드를 탑재하고 이해하자.기본적으로는 위에서 아래로 순차적으로 코드가 실행되지만,시간이 오래 걸리는 코드가 있다면 “일단 본인부터 살고 보자”마인드로그 코드를 건너뛰고 본인 먼저 냅다 실행한다.그래서 달리기 가장 느린 순서대로 위에서부터 코드를 짰음에도, 달리기가 가장 빠른 순서대로 도착한 것이다.자, 그럼 이런 사단이 나지 않게 위해서는 이제 제대로 된 ‘약속’을 만들어야 한다.정리하자면, Promise란 늦게 실행되는 코드를 내팽개쳐두고 먼저 실행되는 것 (비동기 방식) 이 아니라, 순차적으로 실행될 수 있도록 (동기 방식) 그 안에서 통용되는 약속 (Promise)을 정하는 것이다.약속 만들기 (Sequential: 연속적)const 청산_달리기_속도 = 1000;const 수혁_달리기_속도 = 2000;const 온조_달리기_속도 = 3000;const 남라_달리기_속도 = 4000;//도망 계획const 도망계획 = new Promise((성공, 실패) =&gt; { setTimeout(() =&gt; { console.log(\"남라 안전 지역 도착\"); 성공(); }, 남라_달리기_속도);}) .then((res) =&gt; { return new Promise((성공, 실패) =&gt; { // (*) setTimeout(() =&gt; { console.log(\"온조 안전 지역 도착\"); 성공(); }, 온조_달리기_속도); }); }) .then((res) =&gt; { return new Promise((성공, 실패) =&gt; { // (*) setTimeout(() =&gt; { console.log(\"수혁 안전 지역 도착\"); 성공(); }, 수혁_달리기_속도); }); }) .then((res) =&gt; { return new Promise((성공, 실패) =&gt; { // (*) setTimeout(() =&gt; { console.log(\"청산 안전 지역 도착\"); 성공(); }, 청산_달리기_속도); }); });이제 예상한 결과가 나왔다.근데 현재는 코드가 너무 가독성이 떨어진다.Promise를 return해주는 코드를 함수화하고, async, await으로 더 간단하게 만들어보자.async-await은 비동기 동작(Promise)의 상태가 완료될 때까지 기다린 후, 다음 코드를 순차적으로 읽어 나가며 실행하기 때문에 비동기 동작들의 순서를 보장할 수 있다.간략하게 바꾼 코드 ‘도망’을 함수화하고 재사용해서 가독성을 높인 코드//const 도망 = (이름, 달리기_속도) =&gt; { const promiseData = new Promise((성공, 실패) =&gt; { setTimeout(() =&gt; { 성공(이름 + \" 도망 완료\"); }, 달리기_속도); }); return promiseData;};const 도망계획 = new Promise((성공, 실패) =&gt; { 도망(\"남라\", 남라_달리기_속도) .then((res) =&gt; { console.log(res); return 도망(\"온조\", 온조_달리기_속도); }) .then((res) =&gt; { console.log(res); return 도망(\"수혁\", 수혁_달리기_속도); }) .then((res) =&gt; { console.log(res); return 도망(\"청산\", 청산_달리기_속도); }) .then((res) =&gt; { console.log(res); });}); Async, Await을 사용한 코드// async await를 사용해서 가독성을 높인 코드const 도망 = (이름, 달리기_속도) =&gt; { return new Promise((성공, 실패) =&gt; { setTimeout(() =&gt; { console.log(이름 + \" 도망 완료\"); 성공(); }, 달리기_속도); });};async function 도망계획() { await 도망(\"남라\", 남라_달리기_속도); await 도망(\"온조\", 온조_달리기_속도); await 도망(\"수혁\", 수혁_달리기_속도); await 도망(\"청산\", 청산_달리기_속도); console.log(\"모두 대피 완료\");}도망계획();약속 만들기 (Concurrent: 병행적)근데 여기서 한 가지 의문점이 든다.‘달리기가 느린 남라가 가장 먼저 도착’이라는 전제만 충족된다면, 나머지 셋 중 누가 먼저 도착하는지가 그렇게 중요할까?위 코드에는 온조는 남라가 도착해야 출발할 수 있고, 수혁이는 온조가 도착해야 출발할 수 있고,마찬가지로 청산이도 수혁이가 도착해야 출발할 수 있는 ‘의존성’이 작용되고 있다.만약 남라만 제일 먼저 도착하는것이 보장된다면, 굳이 느린순서 (남라→온조→수혁→청산)대로 도망치는것은 뭔가 비효율적이다.그래서 남라를 제외한 나머지 셋 사이의 의존성은 제거해서 이 셋은 순서 상관없이 처리되도록 한다.이때 사용하는게 Promise.all인데, 이는 여러 비동기 동작(프라미스)을 하나로 묶어 하나의 Promise처럼 관리하게 해준다. 다만 이 안에서 순서는 보장되지 않는다.async function 도망계획() { await 도망(\"남라\", 남라_달리기_속도); const 온조도망 = 도망(\"온조\", 온조_달리기_속도); const 수혁도망 = 도망(\"수혁\", 수혁_달리기_속도); const 청산도망 = 도망(\"청산\", 청산_달리기_속도); const 나머지셋도망 = [온조도망, 수혁도망, 청산도망]; Promise.all(나머지셋도망);}도망계획();실제로 굳이 청산, 수혁, 온조간의 의존성을 만들어 줄 필요가 없는 상황에서 이렇게 수행한다면 속도를 단축시킬 수 있다.이는 마치 자바스크립트가 ‘병렬적 (Parallel)’으로 처리되는게 아닌가 하는 의문이 든다.하지만 자바스크립트는 Single Thread이고, 일반적으로 Parallel작업을 수행하지 못한다.그래서‘엄밀히’ 따지면 병렬이 아닌 병행적 (Concurrent)으로 처리되어서, 동시에 처리된 것처럼 ‘보이는’것이다.사진 출처: https://javascript.plainenglish.io/does-promise-all-execute-in-parallel-how-promise-all-works-in-javascript-fffc2e8d455d예시를 들어 설명하자면 ‘Parallel’은 A와 B 작업을 ‘실제로’ 동시에 수행하는 것이다.반면 ‘Concurrent’는 A와 B를 동시가 아닌 순서대로 실행하지만, A 작업을 실행하고 그 작업이 끝나기도 전에 B를 수행하고, 두 결과를 반환하는 것이다.약속의 범위물론, 이 약속의 범위에도 대해서 짚고 넘어갈 필요가 있다.이 약속은 이들 외, 다른 학교 학생들, 양궁팸 등은 전혀 모르는 일이다.이건 오로지 그 자리에 있던 ‘이 친구들’ 사이에서 통용되는 약속이다. (청산, 수혁, 남라 온조)양궁팸인 미진이와 장하리는 해당 약속과 무관하므로 그냥 먼저 가버릴 것이다. (달리기 속도 빠르다고 가정)async function 도망계획() { await 도망(\"남라\", 남라_달리기_속도); const 온조도망 = 도망(\"온조\", 온조_달리기_속도); const 수혁도망 = 도망(\"수혁\", 수혁_달리기_속도); const 청산도망 = 도망(\"청산\", 청산_달리기_속도); const 나머지셋도망 = [온조도망, 수혁도망, 청산도망]; Promise.all(나머지셋도망);}// 양궁팸console.log(\"미진이 도착\");console.log(\"장하리 도착\");똑같이 공부하는 입장이라서, 만약 틀린 점이나 모호한 점이 있다면 댓글로 알려주시길 바랍니다!" }, { "title": "이코테 2021 강의 몰아보기 3. DFS & BFS [음료수 얼려먹기]", "url": "/posts/%EC%9D%B4%EC%BD%94%ED%85%8C-2021-%EA%B0%95%EC%9D%98-%EB%AA%B0%EC%95%84%EB%B3%B4%EA%B8%B0-3.-DFS-&-BFS-%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4%EB%A8%B9%EA%B8%B0/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, BFS", "date": "2022-03-18 00:00:00 +0900", "snippet": "(이코테 2021 강의 몰아보기) 3. DFS &amp; BFS#상하좌우#한번 한거는 1로 바꾼다n, m = map(int,input().split())ice = list()for _ in range(n): ice.append(list(map(int,input())))# ice = [[input()] for _ in range(n)]# 위 코드처럼 하면 안됨. 그러면 [[0,0,0]]이 아니라 [[000]]으로 바뀐다.sum = 0def dfs(x,y): global ice global sum #범위를 벗어났을때 종료 조건 if x &lt;= -1 or x &gt;= n or y&lt;=-1 or y &gt;= m : return False #방문하지 않았다면 if ice[x][y] == 0: ice[x][y] = 1 dfs(x-1,y) dfs(x+1,y) dfs(x,y+1) dfs(x,y-1) return True #방문했을 때 return Falsefor i in range(n): for j in range(m): if dfs(i,j): sum+=1print(sum)느낀 점:처음에 input값을 다음과 같이 받으려고 했는데 그러면 [[0,0,0]]이 아니라 [[000]]으로 받게 된다.‘ice = [[input()] for _ in range(n)]’그리고 무의식적으로 input()이 아니라 int(input())으로 받는 경향이 있는데, 대부분의 경우 int를 사용하기는 하지만 string을 다룰때도 있어서 조심해야 할 것 같다." }, { "title": "BOJ 9663번 N-Queen", "url": "/posts/9663%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)출력첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.#코드 출처: https://seongonion.tistory.com/103n = int(input())ans = 0row = [0] * ndef is_promising(x): for i in range(x): if row[x]== row[i] or abs(row[x]-row[i]) == abs(x-i): return False return Truedef n_queens(x): global ans if x == n: ans+=1 else: for i in range(n): row[x]=i if is_promising(x): n_queens(x+1)n_queens(0)print(ans)느낀 점:내 힘으로는 풀지 못했다… 이해는 되었지만 직접 구현해보라고 하면 다시 헷갈릴 것 같다.지금으로서는 백트래킹이 내 최대 약점인 것 같다.내가 구현하려할때는 Naive하게 접근하다보니 코드가 길어졌는데, 위 코드는 Key Point를 잘 잡고 풀어서 코드가 깔끔하게 떨어진 것 같다.2차 시도#반복문을 통해서 모든 행에 하나씩 둘 때까지 한다 (모든 행인 이유는 똑같은 행에는 queen이 존재할 수 없기 때문)#is promising: 만약에 직선으로 곂치거나, 대각선으로 곂치면 아예 재귀를 돌리지 않고 False를 return하고 다음 열을 탐색한다.#곂치지 않는다면 계속해서 재귀적으로 찾아나간다. True라면 다음 행을 탐색한다.#위에서부터 말을 두고 있기 때문에, 이미 둔 위랑만 비교를 하면 된다.N = int(input())#index를 행, 값을 열로 갖는 배열row = [0] * Ncnt=0def is_promising(x): for i in range(x): if row[i] == row[x] or abs(i-x)==abs(row[i]-row[x]): return False return Truedef solution(x):#x는 행 값 global cnt #행을 도는 반복문 if x == N: cnt+=1 return #(x는 재귀할때마다 +1해서 들어가기 때문에) 열을 탐색 for i in range(N): #이미 row[x]에 값을 넣었기 때문에 x를 is_promising에 넣어줌 row[x] = i if is_promising(x) == True: solution(x+1) #return이 있으면 안됨. 여기서 True였어도 깊이 탐색하다가 False나면 다시 for문 돌아야 해서 return #여기 return은 있어도 되고 없어도 됨solution(0)print(cnt)이번에는 거의 다 틀은 잡았는데, 역시나 return을 써주면 안되는데 써준다던가, parameter를 잘못준다던가 하는 실수가 있었다.선언한 변수와 함수에 대한 개념이 덜 잡혀있어서 그런 것 같다. 계속 시간초과나서 찾아봤더니 pypy3로는 된다." }, { "title": "BOJ 9461번 파도반 수열", "url": "/posts/9461%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)출력각 테스트 케이스마다 P(N)을 출력한다.memo = [0] * 101def nasun(x): if memo[x]!=0: return memo[x] if 0&lt;=x&lt;=3: return 1 if 4&lt;=x&lt;=5: return 2 if 6&lt;=x: memo[x] = nasun(x-5) + nasun(x-1) return memo[x]n = int(input())for _ in range(n): v = int(input()) print(nasun(v))\"\"\"다른 사람 코드t = int(input())li = [1,1,1,2,2]for i in range(5, 100): li.append(li[i-1]+li[i-5])for _ in range(t): n = int(input()) print(li[n-1])출처: https://jiwon-coding.tistory.com/32\"\"\"느낀 점풀 수 있을지 몰랐는데 혼자 힘으로 한번에 맞춰서 감회가 새롭다.처음엔 패턴이 안보였고, 패턴을 찾고 나서도 어떻게 함수로 만들지 고민이었는데 어찌저찌 하게 됐다.재귀에 점점 익숙해지고 있는 것 같지만, 여전히 코드를 비효율적으로 짠 부분이 있는 것 같다.패턴을 찾았을 때 빠르게 공식화하는 법을 익혀야 할 것 같다.." }, { "title": "BOJ 9184번 신나는 함수 실행 파이썬", "url": "/posts/9148%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, DP", "date": "2022-03-18 00:00:00 +0900", "snippet": "9184번: 신나는 함수 실행문제재귀 호출만 생각하면 신이 난다! 아닌가요?다음과 같은 재귀함수 w(a, b, c)가 있다.if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns: 1if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns: w(20, 20, 20)if a &lt; b and b &lt; c, then w(a, b, c) returns: w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)otherwise it returns: w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.입력입력은 세 정수 a, b, c로 이루어져 있으며, 한 줄에 하나씩 주어진다. 입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.출력입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.제한 50 ≤ a, b, c ≤ 50memo = {}def w(a,b,c): if (a,b,c) in memo: return memo[a,b,c] if a &lt;= 0 or b &lt;= 0 or c &lt;= 0: return 1 if a &gt; 20 or b &gt; 20 or c &gt; 20: return w(20, 20, 20) if a &lt; b and b &lt; c: memo[(a,b,c)]=w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) return memo[(a,b,c)] else: memo[(a,b,c)] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return memo[(a,b,c)]while True: a,b,c = map(int,input().split()) if a == -1 and b== -1 and c== -1: break print('w(%d, %d, %d) = %d' %(a,b,c,w(a,b,c)))느낀 점처음에 감이 안 와서 유튜브에 있는 풀이 조금 보고 바로 적용해서 풀어봤다.지금까지 푼 기초적인 동적계획법 문제는 코드를 제공해줬기 때문에 오히려 쉬운 부분이 있는 것 같다.아이디어만 잡으면 memoization만 넣어줘서 풀면 쉽게 풀 수 있을 것 같다." }, { "title": "BOJ 4796번 단어 수학", "url": "/posts/4796%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-03-18 00:00:00 +0900", "snippet": "4796번: 캠핑문제등산가 김강산은 가족들과 함께 캠핑을 떠났다. 하지만, 캠핑장에는 다음과 같은 경고문이 쓰여 있었다.캠핑장은 연속하는 20일 중 10일동안만 사용할 수 있습니다.강산이는 이제 막 28일 휴가를 시작했다. 이번 휴가 기간 동안 강산이는 캠핑장을 며칠동안 사용할 수 있을까?강산이는 조금 더 일반화해서 문제를 풀려고 한다.캠핑장을 연속하는 P일 중, L일동안만 사용할 수 있다. 강산이는 이제 막 V일짜리 휴가를 시작했다. 강산이가 캠핑장을 최대 며칠동안 사용할 수 있을까? (1 &lt; L &lt; P &lt; V)입력입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, L, P, V를 순서대로 포함하고 있다. 모든 입력 정수는 int범위이다. 마지막 줄에는 0이 3개 주어진다.출력각 테스트 케이스에 대해서, 강산이가 캠핑장을 최대 며칠동안 사용할 수 있는지 예제 출력처럼 출력한다.idx = 1while True: res = 0 l,p,v = map(int,input().split()) if l==p==v==0: break # P일 동안 res += v//p*l # P보다 작은 짜투리 기간 # 1) 해당 기간이 L과 같거나 작을 때 if l&gt;=v%p: res+=v%p # 2) 해당 기간이 L보다 클 때 else: res+=l print(f'Case {idx}: {res}') idx += 1코드를 간략하게, 혹은 축소할 수 있는 부분 셋 다 0인지 확인할 때, l==p==v==0 보다 l+p+v==0이 더 깔끔할듯 min(l,v%p)를 해서 이 중 작은 값을 넣으면 if else 구문이 필요없음" }, { "title": "BOJ 4195번 친구 네트워크 파이썬", "url": "/posts/4195%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 유니온 파인드", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제민혁이는 소셜 네트워크 사이트에서 친구를 만드는 것을 좋아하는 친구이다. 우표를 모으는 취미가 있듯이, 민혁이는 소셜 네트워크 사이트에서 친구를 모으는 것이 취미이다.어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.친구 네트워크란 친구 관계만으로 이동할 수 있는 사이를 말한다.입력첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스의 첫째 줄에는 친구 관계의 수 F가 주어지며, 이 값은 100,000을 넘지 않는다. 다음 F개의 줄에는 친구 관계가 생긴 순서대로 주어진다. 친구 관계는 두 사용자의 아이디로 이루어져 있으며, 알파벳 대문자 또는 소문자로만 이루어진 길이 20 이하의 문자열이다.출력친구 관계가 생길 때마다, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.def find(x): if parents[x] == x: return x else: parents[x] = find(parents[x]) return parents[x]def union(a,b): a = find(a) b = find(b) if a!=b: parents[b]=a number[a]+=number[b]n = int(input())for _ in range(n): f = int(input()) parents = {} number = {} for _ in range(f): a,b=map(str,input().split()) if a not in parents: parents[a]=a number[a]=1 if b not in parents: parents[b]=b number[b]=1 union(a,b) print(number[find(a)])느낀 점스스로 다 풀지 못하고, 도움을 빌렸기 때문에 제출하지 않았다. 나중에 다시 풀어볼 예정.유니온파인드 문제가 아직 안 익숙해서 그런가, 이 개념이 아직 희미한 상태에서 문제를 보면 문제 아이디어가 안 떠오른다기보다, 문제 워딩 자체가 모호하고 어색하게 느껴진다. “친구 네트워크란 친구 관계만으로 이동할 수 있는 사이를 말한다.” “친구 관계가 생길 때마다, 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하시오.”등…문과 출신이라서 그런가 워딩 자체에 집중하는 경향이 있다.이런 습관을 배재하고 최대한 어떤 알고리즘을 요구하는건지만 머릿속에 떠올리는 연습을 해야겠다.문제 Key Point유니온파인드는 find로 부모로 재귀하기 때문에 기록해야 되는 수를 부모쪽에 넣어두고, 연결되어 있는 나머지는 부모를 가리키는것이 포인트인 것 같다." }, { "title": "BOJ 2667번 단지번호붙이기 파이썬", "url": "/posts/2667%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, 그래프 탐색", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.#단지번호붙이기n = int(input())graph = []cnt = 0count = []def dfs(x,y): global cnt if x&gt;=n or y&gt;=n or x&lt;=-1 or y&lt;=-1: return False #1일때만 방문등록 if graph[x][y] == 1: graph[x][y] = 0 cnt+=1 dfs(x+1,y) dfs(x-1,y) dfs(x,y+1) dfs(x,y-1) return True return Falsefor _ in range(n): graph.append(list(map(int,input())))for i in range(n): for j in range(n): if dfs(i,j) == True: count.append(cnt) cnt = 0print(len(count))count.sort()for c in count: print(c)" }, { "title": "BOJ 2630번 색종이 만들기", "url": "/posts/2630%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 분할정복", "date": "2022-03-18 00:00:00 +0900", "snippet": "## 문제아래 &lt;그림 1&gt;과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 &lt;그림 2&gt;의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.위와 같은 규칙에 따라 잘랐을 때 &lt;그림 3&gt;은 &lt;그림 1&gt;의 종이를 처음 나눈 후의 상태를, &lt;그림 4&gt;는 두 번째 나눈 후의 상태를, &lt;그림 5&gt;는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.출력첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.#1사분면#2사분면#3사분면#4사분면#시작점을 잡고 구간안에서 비교한다. 처음 구간은 전체이다.#만약 시작점과 다른 숫자가 발견된다면, 그건 4분할을 해야 한다는 의미이다.#4분할을 해준다.#1사분면 [0:4][0:4]#2사분면 [0:4][4:8]#3사분면 [4:8][0:4]#4사분면 [4:8][4:8]def solution(x,y,n): global white,blue start=paper[x][y] #처음 시작할 때는 0부터 8까지 (즉 0부터 7까지를 본다) for i in range(x,x+n): #세로 #처음 시작할 때는 0부터 8까지 (즉 0부터 7까지를 본다) for j in range(y,y+n): #가로 #시작점과 다른 점들을 비교 #만약 시작점과, 그 구간안에서의 다른 점이 다르다면 4분할 if start!=paper[i][j]: solution(x,y,n//2) #1사분면 solution(x,y+n//2,n//2) #2사분면 solution(x+n//2,y,n//2) #3사분면 solution(x+n//2,y+n//2,n//2) #4사분면 return if start == 0 : white+=1 return elif start ==1: blue+=1 returnN= int(input())paper=[list(map(int,input().split())) for _ in range (N)]white,blue = 0,0solution(0,0,N)print(white)print(blue)\"\"\"시작점과 끝점을 합한 값 (x+n, y+n)을 반복문의 종점으로 잡아줌으로써 8을 벗어나지 않도록 한다.x나 y는 0부터 n//2씩 커지더라도, n은 1/2씩 작아지기 때문이다.대신 시작점이 바뀐다.\"\"\"# 8# 1 1 0 0 0 0 1 1# 1 1 0 0 0 0 1 1# 0 0 0 0 1 1 0 0# 0 0 0 0 1 1 0 0# 1 0 0 0 1 1 1 1# 0 1 0 0 1 1 1 1# 0 0 1 1 1 1 1 1# 0 0 1 1 1 1 1 1" }, { "title": "BOJ 2579번 계단 오르기 파이썬", "url": "/posts/2579%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.&lt;그림 1&gt;예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.&lt;그림 2&gt;계단 오르는 데는 다음과 같은 규칙이 있다. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다. 마지막 도착 계단은 반드시 밟아야 한다.따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.입력입력의 첫째 줄에 계단의 개수가 주어진다.둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.출력첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.n = int(input())s = [0]for _ in range(n): s.append(int(input()))def findMax(): global dp dp = [0]*(n+1) dp[1],dp[2],dp[3] = s[1],s[1]+s[2],max(s[3]+s[1],s[3]+s[2]) for i in range(4,n+1): dp[i] = max(dp[i - 3]+ s[i-1]+s[i],dp[i-2]+s[i]) print(dp[n])if n == 1: print(s[1])elif n == 2: print(s[1]+s[2])else: findMax()DP에 대해서 잘 모를때 풀이 찾아보고 풀었다가, 기억이 흐려질쯤 혼자 힘으로 다시 풀어본 문제.핵심 아이디어가 DP라는걸 안 상태에서 큰 틀의 풀이를 전개해나가는 것은 어렵지 않았으나, 자잘한 예외처리를 못해서 3번이나 틀렸다.틀린 부분:n이 1일때의 예외처리n이 2일때의 예외처리실제 DP적인 풀이를 하게 되는 것은 n이 3일때부터 문제에서도 계단을 연속해서 3번 반복해서 밟을 수 없다고 했으므로, 3번까지는 처음에 값을 지정해주고 반복문을 돌렸어야 했는데 이 부분을 간과함" }, { "title": "BOJ 2470번 두 용액", "url": "/posts/2470%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 투포인터", "date": "2022-03-18 00:00:00 +0900", "snippet": "2470번: 두 용액문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.입력첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.출력첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.#가장 작은 값을 찾아서 0이 되려면 얼마나 더해줘야하는지n = int(input())nums = list(map(int,input().split()))nums.sort()extra = 0if nums[0] &lt; 0: extra = abs(min(nums)) for idx in range(n): nums[idx]+=extrastart = 0end = len(nums)-1d = 2000000001res = []for idx in nums: if end == start: break sum = nums[end]+nums[start]-(extra*2) if abs(0-d)&gt;abs(sum): d = sum res = [nums[start]-extra,nums[end]-extra] if(sum&lt;0): start+=1 elif(sum&gt;0): end-=1 else :# 0인 경우 res = [nums[start]-extra,nums[end]-extra] breakfor i in res: print(i,end=' ')배운 것 or 느낀 점:코딩 공부 5일차 골드 문제를 처음으로 거의 혼자 푼거라서 감회가 새롭다.거의 혼자인 이유는 아이디어 구상은 빠르게 끝냈지만 반례를 생각못해서 두번이나 틀렸기 때문이다.질문탐색을 통해서 이 게시물을 보고 바로 뭘 잘못했는지 바로 떠올랐다.처음 비교대상인 d를 생각하는 것까지는 좋았으나 최댓값인 1000000000이 들어오는 경우를 생각안했다. 최댓값 쌍이 들어오는 경우를 감안해서 2000000000, 그리고 더 나아가 여기 +1을 해주어야 했다.그리고, 서로 다른 수의 한쌍이라서 start end가 다른 곳을 가리켜야 되는데 같은 곳을 가리키는 경우를 처리를 안해주었다." }, { "title": "BOJ 20040번 사이클 게임 파이썬", "url": "/posts/20040%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-03-18 00:00:00 +0900", "snippet": "20040번: 사이클 게임문제사이클 게임은 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임으로, 선 플레이어가 홀수 번째 차례를, 후 플레이어가 짝수 번째 차례를 진행한다. 게임 시작 시 0 부터 n − 1 까지 고유한 번호가 부여된 평면 상의 점 n 개가 주어지며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 매 차례 마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 긋는데, 이전에 그린 선분을 다시 그을 수는 없지만 이미 그린 다른 선분과 교차하는 것은 가능하다. 게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료된다. 사이클 C는 플레이어가 그린 선분들의 부분집합으로, 다음 조건을 만족한다. C에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다. 이 문제를 해결하기 위해서 게임의 진행 상황이 주어지면 몇 번째 차례에서 사이클이 완성되었는지, 혹은 아직 게임이 진행 중인지를 판단하는 프로그램을 작성하려 한다.입력으로 점의 개수 n과 m 번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성 되었는지를 판단하고, 완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것인지를 출력하는 프로그램을 작성하시오.입력입력은 표준입력을 사용한다. 입력의 첫 번째 줄에는 점의 개수를 나타내는 정수 3 ≤ n ≤ 500,000 과 진행된 차례의 수를 나타내는 정수 3 ≤ m ≤ 1,000,000 이 주어진다. 게임에서 사용하는 n개의 점에는 0 부터 n − 1 까지 고유한 번호가 부여되어 있으며, 이 중 어느 세 점도 일직선 위에 놓이지 않는다. 이어지는 m 개의 입력 줄에는 각각 i번째 차례에 해당 플레이어가 선택한 두 점의 번호가 주어진다 (1 ≤ i ≤ m).출력출력은 표준출력을 사용한다. 입력으로 주어진 케이스에 대해, m 번째 차례까지 게임을 진행한 상황에서 이미 게임이 종료되었다면 사이클이 처음으로 만들어진 차례의 번호를 양의 정수로 출력하고, m 번의 차례를 모두 처리한 이후에도 종료되지 않았다면 0을 출력한다.import sysinput = sys.stdin.readlinen,t = map(int,input().split())res = 0parents = [i for i in range(n)]def find(x): if x == parents[x]: return x parents[x] = find(parents[x]) return parents[x]#맞음def union(a,b,idx): global res a = find(a) b = find(b) if a!=b: parents[max(a,b)] = min(a,b) elif res==0: res = idxfor idx in range(t): a,b = map(int,input().split()) union(a,b,idx+1)\"\"\"#틀림def union(a,b): a = find(a) b = find(b) if a!=b: parents[max(a,b)] = min(a,b) return False else: return Truefor idx in range(t): a,b = map(int,input().split()) if union(a,b): res=idx+1\"\"\"print(res)경험한 오류: sys.stdin.readline으로 받지 않아서 시간초과 union함수에서 global로 res를 사용하지 않고, a랑“문제는 선분을 여러 개 그리다 보면 사이클이 완성 되었는지의 여부를 판단하기 어려워 이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것이다.”이 부분을 간과했다… 두 점의 parents가 같더라도 ‘res==0’라는 조건을 넣어주지 않으면, 첫 싸이클 완성된 순간의 index가 아니라, 반복문이 끝나고 완성된 index를 반환하게 된다." }, { "title": "BOJ 1976번 여행가자 파이썬", "url": "/posts/1976%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 유니온 파인드", "date": "2022-03-18 00:00:00 +0900", "snippet": "1976번: 여행 가자문제동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.입력첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.출력첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.n = int(input()) #200이하의 값m = int(input()) #1000이하parents = [i for i in range(n)] #0부터 n까지 자기 자신을 갖게 됨#배열로 받고#배열을 순회하면서 1이면 그 좌표의 x와 y도시를 union해준다.#일단 부모로 자기 자신을 갖고 있다.#union을 해주면 자기보다 작은 값을 갖게 된다.#여행이 가능하려면 중복하더라도 서로 연결되어있어야 한다. 작은 수를 부모로 주기 때문에 숫자가 다 같으면 여행 가능하다def find(x): if x == parents[x]: return x else: y = find(parents[x]) return ydef union(a,b): a = find(a) b = find(b) if a&gt;b: parents[a] = b if a&lt;b: parents[b] = a passunion_status = [list(map(int,input().split())) for _ in range(n)]plan = map(int,input().split())final= []for i in range(n): for j in range(n): if union_status[i][j] == 1: union(i,j)for i in plan: final.append(find(i-1))if len(set(final)) == 1: print(\"YES\")else: print(\"NO\")저번에 혼자 힘으로 못 풀었어서 이번에 다시 풀어봤다.유니온파인드의 전형적인 느낌이라서 문제를 보고 이 개념을 떠올릴 수만 있으면 풀기 쉬울 것 같다.마지막에 len(set(final))가 1인지 확인해서 도시들이 연결되어있는거를 확인하는게 은근히 떠올리기 힘들었다." }, { "title": "BOJ 1912번 연속합 파이썬", "url": "/posts/1912%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-03-18 00:00:00 +0900", "snippet": "1912번: 연속합문제n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.입력첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.출력첫째 줄에 답을 출력한다.#처음 짜서 제출한 코드 (이것도 정답은 뜸)N = int(input())S = list(map(int,input().split()))dp = [0] * Ndef maxPrefixSum(): global dp if N==1: print(S[0]) return else: dp[0] = S[0] dp[1] = max(S[1],S[0]+S[1]) for i in range(2,N): dp[i] = max(dp[i-1]+S[i],S[i]) print(max(dp))maxPrefixSum()#불필요한 부분 제거한 코드#생각해보니 dp[0]만 사전에 넣어두고 시작하면 됨N = int(input())S = list(map(int,input().split()))dp = [0] * Ndef maxPrefixSum(): global dp dp[0] = S[0] for i in range(1,N): dp[i] = max(dp[i-1]+S[i],S[i]) print(max(dp))maxPrefixSum()DP 공부한지 이틀차, 여태 한 문제도 내 힘으로 못 풀다가 처음으로 스스로 푼 문제이다.직관적으로 이 문제는 재귀를 안 쓰고 반복문을 쓸 수 있겠다는 생각이 들었다.그 다음으로 어떻게 sub-problem으로 나눌 수 있을까 고민했고, DP라는 배열이 있다면 이 배열은 무엇을 나타내는 것일까 역으로 생각해봤다.DP의 각 원소는 S 배열에서 해당 인덱스 위치의 값이 그 이전 인덱스 값까지 가질 수 있는 연속 최대합이다.처음에는 DP 배열 하나만 있으면 되나 생각했는데, 연속합이 아닌 원래 수를 더해야하므로 원본 입력 숫자들을 갖고 있는 배열 하나가 더 필요하다 (S)max로 2개 이상의 기준을 비교해서 하나를 취해야 한다는 아이디어는 떠올랐는데, 이 기준 중 하나가 자기 자신이다.문제에서 힌트를 얻은 부분은 ‘단, 수는 한 개 이상 선택해야 한다.’이다.꼭 연속된 수와 더하지 않고 자신의 값을 그대로 가지고 있어도 되므로 비교 대상은 max로 큰 값을 취한다.점화식은 dp[n] =max(dp[n-1]+S[n],S[n])이다.반복문을 돌면서 각 Index는 더하지 않고 그대로 있던가, 아니면 그 전 값과 더하든가 선택한다.연속합 수열의 갯수가 아닌 연속 최대합을 출력하는 것이므로 반복문을 다 돌고 DP 배열에서 Max값을 출력해주면 된다." }, { "title": "BOJ 1715번 카드정렬 파이썬", "url": "/posts/1715%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-03-18 00:00:00 +0900", "snippet": "1715번: 카드 정렬하기등급: 골드문제정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.출력첫째 줄에 최소 비교 횟수를 출력한다.#heapify, heapq, heappop, heappushimport heapqn= int(input())cardlist = [int(input()) for _ in range(n) ]heapq.heapify(cardlist)res = 0while len(cardlist)!=1: a = heapq.heappop(cardlist) b = heapq.heappop(cardlist) res += a+b heapq.heappush(cardlist,a+b)print(res)" }, { "title": "BOJ 16953번 A → B 파이썬", "url": "/posts/16953%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-03-18 00:00:00 +0900", "snippet": "16953번: A → B문제정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다. 2를 곱한다. 1을 수의 가장 오른쪽에 추가한다.A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.입력첫째 줄에 A, B (1 ≤ A &lt; B ≤ 109)가 주어진다.출력A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.#경우의 수#뒤에 1만 붙이면 그 값이 되는경우#1을 붙이고 2를 곱해줘야 하는 경우#1을 붙이고 2를 곱해주고 다시 1을 붙이는 경우#만약 B뒤에 1이 있으면 1을 뺴고 그 값이 되는 순간 까지를차즌ㄴ다#아니면 뒤에 1이 나올때까지 2로 나눈다.a,b = map(int,input().split())cnt=1while b!=a:#while 끝내는 조건 if a&gt;b: cnt = -1 break if b%10 == 1: b//=10 cnt+=1 else: if b%2==0: b//=2 cnt+=1 else: cnt = -1 breakprint(cnt)풀이:역발상으로 (b에서 a로 가려면 어떻게 해야 되는가)를 생각하니까 쉽게 풀렸다.b의 끝이 1이면 1을 뒤에서 빼주고, 아니면 2로 나눈다. 근데 2로 나눌 때 2로 나눴을 때 나머지가 2인 경우만 나누고, 아니면 애초에 될 수 없는 값이므로 -1을 출력하고 끝낸다. (이 경우의 수를 안 생각해서, 테스트케이스만 돌려보고 처음에 틀렸었음)간단한 문제지만 잘 접근한 것 같아서 뿌듯하다." }, { "title": "BOJ 1629번 곱셈 파이썬", "url": "/posts/1629%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 분할정복", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.입력첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.출력첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.a,b,c = map(int,input().split())sum = 0#memo = {}def rec(x): #x는 b if x == 1: return a%c else: tmp = rec(x//2) if x%2 == 0: #짝수 return (tmp * tmp)%c else: return (tmp* tmp *a)%csum = rec(b)print(sum)a와 b에 너무 큰 수가 들어와서 오버플로우가 생겨도 시간초과가 나므로 미리 c로 나머지를 구한다.분배법칙에 의해서 다음과 같이 된다." }, { "title": "BOJ 15650 N과 M (2) 파이썬", "url": "/posts/15650%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-03-18 00:00:00 +0900", "snippet": "15650 N과 M (2) 파이썬문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 고른 수열은 오름차순이어야 한다.입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.# 15650번n,m = list(map(int,input().split()))s = []def dfs(x): if len(s)==m: print(' '.join(map(str,s))) return for i in range(x,n+1): if i not in s: s.append(i) dfs(i+1) s.pop()dfs(1)느낀점자기 자긴보다 작은 숫자는 추가하지 않기 위해서 for문을 자신 (x)부터 시작한다.이해했다고 생각했는데 재귀를 응용해서 써야하는 경우가 생기면 다시 이해가 느려진다." }, { "title": "BOJ 15649번 N과 M (1) 파이썬", "url": "/posts/15649%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.n,m = map(int,input().split())rs = []def rec(): if len(rs) == m: print(' '.join(map(str,rs))) return else: for i in range(1,n+1): if i not in rs: #본인을 제외한, 이미 배열에 없는 rs.append(i) #[1] rec() rs.pop() returnrec()처음에 도움을 받아서 풀었었는데 그때도 분명하게 이해되지 않았다.그래서 시간이 지나고 다시 풀어봤다.백트래킹의 가장 기초적인 형태인데 함수 내부에서 위의 가지치기 (if문)으로 특정 조건일때 원하는 결과를 출력하고, 그 외 나머지 경우 (else문)는 for을 통해 재귀로 스택에 쌓이면서 하나씩 깊게 파고 들어가면서 (dfs: depth first search)결국엔 끝까지 탐색한다.이 문제에서 눈 여겨볼 부분은 자신과 중복되는 숫자는 출력하면 안된다는 것이다.그걸 ‘if i not in rs’로 걸러주었다." }, { "title": "BOJ 14888번 연산자 끼어넣기 파이썬", "url": "/posts/14888%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 백트래킹", "date": "2022-03-18 00:00:00 +0900", "snippet": "14888번: 연산자 끼워넣기문제N개의 수로 이루어진 수열 A1, A2, …, AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다. 1+2+3-4×5÷6 1÷2+3+4-5×6 1+2÷3×4-5+6 1÷2×3-4+5+6식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다. 1+2+3-4×5÷6 = 1 1÷2+3+4-5×6 = 12 1+2÷3×4-5+6 = 5 1÷2×3-4+5+6 = 7N개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.입력첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.출력첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.from itertools import permutationsn = int(input())v = list(map(int,input().split()))#덧셈, 뺄샘, 곱셈, 나눗셈cmd = list(map(int,input().split()))new_cmd = []cmd_type = ['+','-','*','//']for idx,i in enumerate(cmd): for _ in range(i): new_cmd.append(cmd_type[idx])answer = []p = list(set(permutations(new_cmd, n-1))) # 순열for i in p: #p:[('+,+,-'),('+,+,-')] num = v[0] for j in range(n-1): if i[j] == '+': num+=v[j+1] elif i[j] == '-': num-=v[j+1] elif i[j] == '*': num*=v[j+1] else: if num//v[j+1] &lt;0: num = -(-num//v[j+1]) else: num = num//v[j+1] answer.append(num)print(max(answer))print(min(answer))일단 백트래킹 관련 문제인데 permutations를 set으로 받아서 (중복제거) 반복문으로 해결했다." }, { "title": "BOJ 14502번 연구소", "url": "/posts/14502%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그래프 탐색", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.2 1 0 0 1 1 01 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 1 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0바이러스가 퍼진 뒤의 모습은 아래와 같아진다.2 1 0 0 1 1 21 0 1 0 1 2 20 1 1 0 1 2 20 1 0 0 0 1 20 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.빈 칸의 개수는 3개 이상이다.출력첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.import copy\"\"\"Test Case n,m = 7,7 nm = [[2, 0, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 2, 0], [0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0]]\"\"\"n,m = map(int,input().split())nm = [list(map(int,input().split())) for _ in range(n)]dx = [-1,1,0,0]dy = [0,0,-1,1]virus_p = []max_safe = 0#바이러스 위치 기록for i in range(n): for j in range(m): if nm[i][j] == 2: virus_p.append([i,j])def make_wall(start,cnt): global max_safe #끝나는 조건 if cnt == 3: fake_nm = copy.deepcopy(nm) for p in virus_p: infect(fake_nm,p[0],p[1]) #안전구역 (0) 세기 safe_counts = sum(i.count(0) for i in fake_nm) max_safe = max(max_safe,safe_counts) return #재귀 조건 for i in range(start,n*m): x = i//m y = i%m if nm[x][y] == 0: nm[x][y] = 1 make_wall(i,cnt+1) nm[x][y] = 0#됨def infect(fake_nm,a,b): for i in range(4): nx = a+dx[i] ny = b+dy[i] if nx &gt;=0 and ny&gt;=0 and nx &lt;n and ny&lt;m: if fake_nm[nx][ny] ==0: fake_nm[nx][ny]=2 infect(fake_nm,nx,ny)#안됨 (IndexError: list index out of range)# def infect(fake_nm,a,b):# if a &lt;0 and b&lt;0 and a&gt;=n and b&gt;=m:# return False# for i in range(4):# nx = a+dx[i]# ny = b+dy[i]# if fake_nm[nx][ny] ==0:# fake_nm[nx][ny]=2# infect(fake_nm,nx,ny)make_wall(0,0)print(max_safe)역대급으로 진득하게 풀어본 문제아이디어보다 구현력 때문에 오래 걸렸다. 아직 dfs 개념이 완전히 익숙한 것 같지 않다.틀렸던 이유 정리 방향 벡터를 key값으로 주는게 아니라 ‘기존 좌표+벡터’로 했어야 함 dfs(infect)의 함수 상단에 끝나는 조건을 설정하려고 했는데 그렇게 못함.왜냐하면 해당 위치가 0인지 검증해야 하는데(fake_nm[nx][ny]) 만약 방향벡터가 범위 밖이면 배열에 접근했을때 IndexError: list index out of range 에러가 뜸 재귀 시 끝나는 조건 (if문)에서 Return 안해서 무한으로 돌았음." }, { "title": "BOJ 1439번 뒤집기 파이썬", "url": "/posts/1439%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-03-18 00:00:00 +0900", "snippet": "1439번: 뒤집기문제다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.입력첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.출력첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.n = input() #문자열total = len(n)#연속된거 개수 비교 0vs1cnt = {'0':0,'1':0}num = n[0]for i in n[1:]: if num == i : continue elif num != i: cnt[num]+=1 num = icnt[n[-1]] += 1print(min(list(cnt.values())))문제 Key Point 0과 1중 연속되는 개수가 적은게 답이다.주의할 Point 연속성이 끊어지는 point에서 cnt를 +1 해주고 있는데, 마지막에 비교할 대상이 없을때는 연속성이 끊어지는 point를 감지 못하기 때문에 반복문 밖에서 마지막 index (n[-1])에 한하여 +1을 해주었다." }, { "title": "BOJ 1427번 소트인사이드 파이썬", "url": "/posts/1427%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 문자열, 정렬", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.입력첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.출력첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.n = input()n2 = list(map(int,n))# sorted(n2, reverse=True)n2.sort(reverse=True)n2 = list(map(str,n2))final = \"\".join(n2)print(final)주의할 점 sort나 sorted는 int에 한해서 됨 join은 str에 한해서 됨 따라서 map을 적절히 사용해서 타입변경해줘야 함" }, { "title": "BOJ 1339번 단어 수학", "url": "/posts/1339%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 그리디", "date": "2022-03-18 00:00:00 +0900", "snippet": "1339번: 단어 수학등급: 골드문제민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.입력첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.출력첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.n = int(input())words = []alphabets = {}for _ in range(n): words.append(input())for w in words: square_root = len(w)-1 for l in w: if l in alphabets: alphabets[l] += pow(10,square_root) else: alphabets[l] = pow(10,square_root) square_root-=1alphabets_s = sorted(alphabets.values(),reverse=True)sum = 0num = 9for i in alphabets_s: #0-9 sum += i * num num-=1print(sum)문제 주요 Key: 자릿수가 높은 순서로 높은 값 (0-9)을 부여해야 최댓값이 나옴 약간의 계산을 실험 삼아서 해보면 금방 알 수 있다. 자료형은 배열과 딕셔너리를 사용한다. 배열은 단어들을 담는다. ([’AAA’, ‘BBB’]) 딕셔너리는 영문자를 key로, 자릿수값을 value로 갖는다. ex. A는 1000의 자리라면 {A:1000} A가 100의 자리에서 한번 더 나오게 되면 {A:1100}이 됨 100의 자리라면 10의 2제곱, 10의 자리라면 10의 1제곱 (pow()를 사용한다.) 이중 for문으로 접근한다. 첫번째 for문은 words 배열에 접근해서 해당 word의 길이를 10에 제곱할 값으로 삼는다. (마지막은 1의 자리라서 len(w)에 1을 빼준다) 두번째 for문은 해당 word의 각 letter (영문자)에 접근해서 해당 글자가 이미 dict에 존재한다면 10의 자릿수를 제곱한 값을 더하고, 아니라면 추가한다. 최댓값을 구하는 것이기 때문에 9에서 -1을 해가면서, 자릿수가 많은 값부터 곱해서 결과값에 더 할 것이다. 9에서 -1을 해가면서 곱할 것이기 때문에 딕셔너리 (alphabets)를 내림차순으로 정렬한다. 느낀 점: 알고리즘 문제를 풀면서 주로 딕셔너리를 안 사용하고도 풀렸어서, 이를 사용하지 않는 더 쉬운 방식이 있을거라고 생각하고 접근함 → 결과적으로 더 어려워짐 생각했다면 아마 영문자와 자릿수를 mapping하는 방식으로 딕셔너리를 구성하게 될 거라는거를 떠올릴 수 있었을 것 파이썬에서 pow()를 사용 안해봐서 이 또한 떠올리지 못함 구현력 부족 못 풀더라도 이러한 문제를 많이 접해보고 접근 방식을 역추적해서 배워야겠다고 느낌 영문자가 다른 자릿수에서 중복되어서 나타난다면, dict값에서 더해주면 될텐데, 따로 처리해주어야 된다고 생각함 수학적 사고의 부족 더 단순하게 할 수 있는거를 문자에서 표기된 방식 그대로, 혹은 일차원적으로 접근하는 경향이 있음 " }, { "title": "BOJ 11725번 트리의 부모 찾기 파이썬", "url": "/posts/11752%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, 트리", "date": "2022-03-18 00:00:00 +0900", "snippet": "11725번: 트리의 부모 찾기문제루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.입력첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.출력첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.import sys#안해주면 런타임 에러 (recursive error)sys.setrecursionlimit(10**6)n = int(input())tree = [[] for i in range(n+1)]roots = [-1]*(n+1)visited = [False]* (n+1)for i in range(1,n): a,b = map(int,input().split()) tree[a].append(b) tree[b].append(a)def dfs(x): visited[x]=True if not tree[x]: return for i in tree[x]: if not visited[i]: visited[i]=True dfs(i) roots[i] = x returndfs(1)for i in roots[2:]: print(i)틀렸던 포인트 setrecursionlimit을 안해줬었음 (N (2 ≤ N ≤ 100,000))파이썬의 재귀 깊이는 1000번 정도라서 보통 해줘야 한다고 한다. dfs 함수내에서 for문을 돌고 return을 안 써줬었고, 그 후에는 썼는데 for문 끝나고가 아니라 if문안에 썼었다 (이러면 for문 한번 돌고 끝나버린다.) 꼼꼼하게 봐야 한다. 무엇이 부모 노드인지 모르는 상태에서 두 정점 (노드)가 주어지기 때문에 tree[a].append(b)를 하고 tree[b].append(a)도 해주어야 했었는데 안해줌다르게 짤 수 있던 포인트 다른 사람 코드를 보니 나처럼 비어있는 배열을 찾았을때 return되면서 호출 당한 노드를 호출한 노드의 부모로 넣어준게 아니라, 애초에 dfs 함수를 호출하기전에, x 노드를 i 노드의 부모 노드로 만들고, 재귀 함수를 호출했다. 어차피 끝까지 탐색을 해야 하기 때문에 이건 어떤 식으로 방문처리를 할거냐의 문제인 것 같다 비록 재귀지만 안에서 끝나는 조건을 설정해줄 필요 없었던게, for i in tree[x] 구문에서 만약 배열 내에 아무것도 없으면 그냥 return된다." }, { "title": "BOJ 11742번 연결 요소의 개수 파이썬", "url": "/posts/11742%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, 그래프 탐색", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.출력첫째 줄에 연결 요소의 개수를 출력한다.#11742 연결 요소의 개수import syssys.setrecursionlimit(10000) # 재귀 제한을 확대해야 함.def dfs(x): if not visited[x]: visited[x] = True for i in graph[x]: dfs(i) return True return False #방문했었으면 return False#True가 될 때마다 1을 더한다n,m = map(int,input().split()) # [[],[2,3],[1,4]]visited = [False] * (n + 1)graph = [[] for _ in range(n+1)] #0 포함해서 생성for i in range(m): a,b = map(int,sys.stdin.readline().split()) # 1,2 graph[a].append(b) graph[b].append(a)sum = 0for i in range(1, n+1): if dfs(i) == True: sum+=1print(sum)틀렸던 이유: Recursion Error가 나서 sys.setrecursionlimit(10000)를 해주어야 함 이건 범위가 어떻게 주어졌을때 발생하는지 몰라서 시간 날때 제대로 공부해봐야겠다. 상하좌우로 가는 문제의 경우 dfs 인자의 범위를 정해주었는데, 여기선 그럴 필요 없는데 범위를 줬었다, 그것도 틀리게느낀 점: dfs 반환값이 True일때만 +1을 하는 문제의 경우, if (방문 처리 안되었을 경우)에 재귀, 그리고 return true하고 else(아닐 시)에는 return False를 해주어야 +1이 안된다. 1부터 시작하는 경우, 0은 생성하지만 무시하기 때문에, graph는 n+1만큼, visited도 n+1 만큼, 0은 무시하기 때문에 반복문은 1부터 n+1까지 돌린다." }, { "title": "BOJ 11721번 열 개씩 끊어 출력하기", "url": "/posts/11721%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, 그래프 탐색", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제알파벳 소문자와 대문자로만 이루어진 길이가 N인 단어가 주어진다.한 줄에 10글자씩 끊어서 출력하는 프로그램을 작성하시오.입력첫째 줄에 단어가 주어진다. 단어는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 100을 넘지 않는다. 길이가 0인 단어는 주어지지 않는다.출력입력으로 주어진 단어를 열 개씩 끊어서 한 줄에 하나씩 출력한다. 단어의 길이가 10의 배수가 아닌 경우에는 마지막 줄에는 10개 미만의 글자만 출력할 수도 있다.#제출한 코드s = input()cnt = 0w = ''if len(s)&lt;10: print(s)else: for i in s: cnt+=1 w+=i if cnt%10==0: print(w) w = ''if w != '': print(w)#간략하게 만든 코드word = input()for i in range(0,len(word),10): print(word[i:i+10])머리 식힐겸 간단한 브론즈 문자열 문제들을 풀어보고 있는데, 파이썬 문법의 기초 지식이 부족하다고 느꼈다.확실히 이런 기초문제들도 많이 풀어봐야겠다고 느꼈다.존재하지 않는 index를 범위의 끝점으로 주면 index error가 날거라고 생각했는데 범위로 주면 에러가 나지 않는다. 만약 해당 index에 값이 없다면 []이 반환될 뿐이다. 에러 남에러 안 남" }, { "title": "BOJ 1012번 유기농 배추 파이썬", "url": "/posts/1012%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS, 그래프 탐색", "date": "2022-03-18 00:00:00 +0900", "snippet": "1012번: 유기농 배추문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.import syssys.setrecursionlimit(10**6)def dfs(x,y): if x&gt;m or y&gt;n or x&lt;=-1 or y&lt;=-1: return False if graph[x][y]==1: graph[x][y] = 0 dfs(x,y+1) dfs(x,y-1) dfs(x+1,y) dfs(x-1,y) return True return Falset = int(input())for _ in range(t): m,n,k = map(int,input().split()) graph = [[0 for _ in range(n)] for _ in range(m)] for _ in range(k): a,b = map(int,input().split()) graph[a][b] = 1 cnt = 0 for i in range(m): for j in range(n): if dfs(i,j) == True: cnt+=1 print(cnt)느낀 점:다른 DFS 문제와 별반 다르지 않아서, 푸는 데 10분 정도밖에 안 걸린 것 같다.다음 번엔 BFS를 사용해봐야겠다. (아직 어떨 때 DFS가 유리하고, 어떨 때 BFS가 유리한 지 감이 없다)근데 recursion error가 떠서 처음에 뭘 잘못 짰나 했는데, 헤매다가 검색해보니 파이썬의 재귀 한도가 있어서import syssys.setrecursionlimit(10**6)로 한도를 늘려줘야 한다고 한다." }, { "title": "BOJ 1003번 피보나치 함수 파이썬", "url": "/posts/1003%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DP", "date": "2022-03-18 00:00:00 +0900", "snippet": "문제다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.int fibonacci(int n) { if (n == 0) { printf(\"0\"); return 0; } else if (n == 1) { printf(\"1\"); return 1; } else { return fibonacci(n‐1) + fibonacci(n‐2); }}fibonacci(3)을 호출하면 다음과 같은 일이 일어난다. fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다. fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다. 두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다. fibonacci(0)은 0을 출력하고, 0을 리턴한다. fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다. 첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다. fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.출력각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.t = int(input())memo = [0]*41dictt={}zero = 0one = 0def f(n): global zero global one if n==0: zero+=1 return 1 if n==1: one+=1 return 1 if memo[n]: zero+=dictt[str(n)][0] one+=dictt[str(n)][1] return memo[n] else: memo[n] = f(n-1)+f(n-2) dictt[str(n)] = [zero,one] return memo[n]for _ in range(t): zero,one = 0 ,0 f(int(input())) print(zero,one,sep=' ')우선 ‘시간 감소 피보나치’ → ‘메모이제이션’ 으로 Naive하게 접근했다.근데 memoization에서 기억해둔 값으로 return하면 zero랑 one이 count안되는 상황이 발생했다.그래서 0, 1의 카운트를 기억하는 dictt라는 또 다른 memoization을 사용해서, memo가 있는 상황에서는 이 딕셔너리로 카운트를 더해주었다.memo → 피보나치 값 기억용 메모이제이션dictt → 카운트 기억용 메모이제이션" }, { "title": "BOJ 10026번 적록색약 파이썬", "url": "/posts/10026%EB%B2%88/", "categories": "Algorithm", "tags": "알고리즘, 백준, DFS", "date": "2022-03-18 00:00:00 +0900", "snippet": "10026번: 적록색약문제적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)예를 들어, 그림이 아래와 같은 경우에RRRBBGGBBBBBBRRBBRRRRRRRR적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)둘째 줄부터 N개 줄에는 그림이 주어진다.출력적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.import syssys.setrecursionlimit(10000)# N = 5# S = [['R','R','R','B','B'],['G','G','B','B','B'],['B','B','B','R','R'],['B','B','R','R','R'],['R','R','R','R','R']]N = int(input())S = [list(map(str,input())) for _ in range(N)]visited = [[False for _ in range(N)] for _ in range(N)]dx = [-1,1,0,0]dy = [0,0,-1,1]def dfs(x,y): for i in range(4): nx = x+ dx[i] ny = y+ dy[i] if -1&lt;nx&lt;N and -1&lt;ny&lt;N: #일반 if S[nx][ny] == S[x][y] and not visited[nx][ny] : visited[nx][ny] = True dfs(nx,ny)cnt = 0#색약 아닐때for i in range(N): for j in range(N): if not visited[i][j]: a = dfs(i,j) cnt+=1print(cnt,end= \" \")#색약 일때visited = [[False for _ in range(N)] for _ in range(N)]cnt = 0for i in range(N): for j in range(N): if S[i][j]=='R': S[i][j] = 'G'for i in range(N): for j in range(N): if not visited[i][j]: dfs(i,j) cnt+=1print(cnt)코드를 전체적으로 맞게 짠 것 같은데 계속 값이 이상하게 나와서 이상하다고 생각했었다.알고보니 visited를 아래와 같이 생성했었다.visited = [[False * N] *N]위처럼 생성하면 안되는 이유는 만약에 N이 이라서 [[0,0],[0,0]] 이렇게 생성된다고 하면, [1][0]과 [1][1]은 [0][0]과 [0][1]을 참조하는 형식으로 생성된다. 그래서 [0][0]에서 값을 바꾸면 [1][0]도 값이 바뀌어버린다.예전에 찾아보고서 알고 있었는데, 실제로 경험해본적은 없어서 까먹고 엄청 고생했다.." }, { "title": "Elastic Beanstalk에 어플리케이션 배포 과정", "url": "/posts/eb_setup/", "categories": "AWS", "tags": "aws, elastic beanstalk", "date": "2022-03-18 00:00:00 +0900", "snippet": " Elastic Beanstalk는 AWS에서 제공하는 PaaS (Platform as a Service)입니다.장점이라면, 개발자가 코드를 업로드 (배포)하기만 한다면, 나머지 불필요하고 머리 아픈 과정을 AWS에서 전부 처리해줍니다.말하자면, Elastic Beanstalk는 AWS에서 제공하는 EC2, S3 등의 패키지 상품인 셈입니다.웹 어플리케이션 배포에 필수적인 서비스들이 묶어서 제공되고, 여기서 약간의 Customizing을 원한다면 관리 페이지에 들어가서 스펙을 변경해준다거나 할 수도 있습니다.근데 아무리 편의성을 제공하는 서비스라지만, 처음에 저느 하는대로 따라 했어도 여러 시행착오를 겪었습니다.이번에 다른 어플리케이션을 EB로 업로드 할 기회가 생겨서 셋업과정과 발생했던 에러들을 정리해보고자 합니다.AWS 공식 사이트 AWS 사이트에 들어가서 “Elastic Beanstalk”를 검색해서 들어가줍니다.환경 생성 들어가서 환경 설정을 하기 위해 ‘Create Application’을 누릅니다.환경 정보 입력이 step에서 애플리케이션 이름, 환경 이름 등을 순서대로 입력해주게 됩니다. (전 태그는 따로 입력해주지 않았습ㄴ디ㅏ)플랫폼의 경우, 저는 Flask 기반의 프레임워크인 Dash App을 업로드할것이기 때문에 Python을 선택하였습니다.우선 샘플 애플리케이션으로 업로드해줍니다. (Hello World처럼 처음에 자동으로 생성되는 페이지)이후에는 AWS의 Code Commit (Git 같은 버전관리 툴)을 이용해서 어플리케이션을 배포할 것입니다.IAM 사용자 생성Elastic Beanstalk 사용자 정책 관리AWS는 IAM 사용자를 사용해서 서비스를 관리하는 것을 권장하고 있습니다.현재 Administrator의 경우, 모든 정보를 관리하고 변경할 수 있는 역할을 갖고 있어서 보안의 위험이 생길 수 있기 때문에 IAM 사용자를 만들어서 각 일을 맡을 역할을 분담, 분산시켜주는 것입니다.검색창에 ‘IAM 사용자’를 검색해서 관리 페이지에 들어가서 아래 나오는 이미지 순서대로 사용자를 추가하고, 역할을 위임할 것입니다.사용자 추가AWS 엑세스 유형 선택 → 엑세스 키 선택권한 설정 → 기존 정책 연결 → Administrator Accesscsv 다운로드 (이후, CLI로 EB set up 과정에서 Username과 Password를 물어볼 때 여기 있는 정보를 입력하게 됩니다)추가적으로, 이후에 CodeCommit으로 배포를 할것이기 때문에, 위에서와 같은 방식으로 CodeCommit에 대한 HTTPS Git 자격 증명도 생성해줍니다.배포 과정 단계처음 배포하기 까지의 과정은 다음 절차를 수행해야 합니다.그 이후부터는 Code Commit에 push하고, eb deploy 명령어만 입력해주면 배포됩니다.명령어들은 cli에서 입력해주면 됩니다. eb cli 설치 pip3 install awsebcli –upgrade –use eb 리포지토리 구성 eb init eb 환경 생성 (aws 사이트에서 생성해주었으므로 생략) eb create requirements.txt 생성 (가상환경으로 패키지를 관리중이라면 활성화 상태에서) pip3 freeze &gt; requirements.txt Flask Application일 경우 파일명 변경 (app.py → application.py) 변수명 변경 (app.py 내의 app → application) 위 2개를 안해주면 에러 발생 (No module named ‘application’ Error while deploying simple web app to Elastic Beanstalk) Code Commit에 코드 Push 어플리케이션 배포 eb deploy 명령어 자 그럼 위에서 언급한 절차를 순서대로 진행해보겠습니다.1. eb cli 설치이미 설치했음으로 생략 생략2. EB 리포지토리 구성 여기서 주의할 점은 여러개의 AWS 계정을 사용하고 있다면 1번처럼 ‘eb init’이 아니라 2번처럼 ‘eb init —profile (계정이름)’으로 입력해주어야 합니다. 단일 계정 사용 시2) 다중 계정 사용 시사전에 AWS 사이트에서 생성해준 어플리케이션을 선택합니다.CodeCommit으로 관리한다고 설정해줍니다 (Y)아까 다운로드 해놓은 CSV의 정보를 입력해줍니다.리포지토리 구성이 끝나면, 다음과 같은 디렉토리와 리포지토리 정보를 담고 있는 yml파일이 생성됩니다.3. eb 환경 생성(aws 사이트에서 생성해주었으므로 생략)4. requirements.txt 생성 (가상환경으로 패키지를 관리중이라면 활성화 상태에서)pip freeze &gt; requirements.txt주의할 점:코드를 배포하면 EB Application이 requirements.txt를 참고해서 패키지들을 설치하게 됩니다.따라서 어플리케이션 사용에 필요한 모든 패키지 정보는 해당 파일에 있어야 합니다.그래서 만약 가상환경이 아닌 global에 설치되어 있는 패키지인데 해당 어플리케이션 사용에 필요하다면, requirements.txt. 파일에 수동으로 추가해줍시다.5. Flask Application일 경우 (아래와 같이 안하면 에러) 파일명 변경 (app.py → application.py) 변수명 변경 (app.py 내의 app → application)6. Code Commit에 코드 Push 기존으로 Git에서 관리하고 있던 Repository를 CodeCommit에 Migrate하려는 경우Git 리포지토리를 (AWS CodeCommitgit clone \\&lt;Git Repository 주소&gt;\\\t이미 해당 디렉토리일 경우 clone 생략git add .git commit -m \"First Code Commit\"git push \\&lt;CodeCommit Repository 주소&gt;\\ --all발생 가능 에러 (credential 문제)MacOS의 경우 git credential과 엉켜서 다음과 같은 에러가 날 수 있다고 합니다. 만약 에러가 난다면 아래 링크를 참고해보시기 바랍니다.fatal: repository 'https://git-codecommit.us-east-2.amazonaws.com/v1/repos/dashApp/' not found참고: https://1mini2.tistory.com/117주의할 점 1 (서버 지역):push 하고 나서 AWS CodeCommit에 들어갔는데, 코드가 Push되어 있지 않다면 혹시 AWS 사이트의 서버가 다른 지역으로 선택되어 있는건 아닌지 확인합니다. (ap-northeast-2를 선택했었다면 사이트 우측 상단에 이 부분도 똑같이 ap-northeast-2로 선택되어 있어야 합니다. 저도 us-east-1로 설정되어 있는거를 모르고 push가 안된 줄 알았었습니다.)주의할 점 2 (Default Branch):Migrate한 git repository에 branch가 있었다면, 해당 branch들까지 다 가져오는데 default가 master가 아닌 다른 branch로 설정되어 있더군요. 설정에 들어가서 기존에 default branch로 사용하던 브랜치로 설정해주면 됩니다. (아래의 경우는 master로 변경해준겁니다.)CodeCommit 배포 성공 화면7. 어플리케이션 배포eb deploy위의 명령어를 입력하면, 아래와 같이 로딩이 되면서 배포가 시작됩니다.근데 경우에 따라서 에러 메시지가 뜨면서 배포가 안 될 수 있습니다.발생 가능 에러 (git config에 codecommit remote 정보가 추가 안 되어 있을 때).git/config 파일을 vi editor로 열어서 위 사진에 나온 branch master 정보를 추가해줍니다.[branch \"master\"]\tremote = codecommit-origin\tmerge = refs/heads/master성공적으로 업로드되면 다행이지만 높은 확률로 다음과 같은 화면 (502 Bad Gateway)이 뜰 수 있습니다.AWS Elastic Beanstalk 관리 페이지에 가보면 상태도 Degraded로 변한 상태입니다.로그로 들어가서 어떤 것 때문에 에러가 발생한건지 확인해줍시다.Elastic Beanstalk를 사용한다면 에러 로그 보는것에 익숙해져야 합니다.로그 요청 마지막 100줄을 하고, 다운로드를 클릭하면 다음과 같이 에러 로그가 기록되어 있는 창이 뜹니다.단어 탐색 (Windows: Ctrl+F, Mac: Cmd+F)으로 Error을 검색해봅시다.저의 경우는 dash_daq를 제대로 설치해주지 않아서 생긴 에러였습니다.아까 위에서 언급했듯이 requirements.txt에는 해당 어플리케이션 사용에 필요한 모든 정보가 필요합니다.저는 처음에 가상환경 패키지 정보만 requirements.txt에 넘겨줬어서 다음과 같은 에러가 났습니다.수정해주고 다시 CodeCommit에 코드 Push EB Deploy를 해주니502 Bad Gateway가 사라졌습니다.물론 여기서 전부 언급하지 않았지만, 다음과 같은 에러들을 다 노가다로 수정해주어야 했습니다. (배포 → 에러 → 수정 → 배포 → 에러 → 수정…)로컬에서 작동하더라도 어떤 예상 못 한 경우에 의해서 에러가 흔하게 나는 것 같습니다.저처럼 에러가 난다면, 위에서 설명드린것처럼 에러로그 부분을 찾아서 구글링해서 해결해보시기 바랍니다.추가그리고 Flask의 경우 EB를 사용하려면 .ebextensinos 디렉토리를 추가하고 application.config를 만들어서 아래 사진의 2번 내용을 복사해주어야 함 (안 그러면 eb가 flask 경로를 못찾아서 502 badgateway)링크 출처https://stackoverflow.com/questions/20558747/how-to-deploy-structured-flask-app-on-aws-elastic-beanstalk" } ]
